<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Kin&#39;s Blog</title>
  <icon>https://mister-kin.github.io/images_public/favicon/Logo.svg</icon>
  <subtitle>计算机知识分享/软件应用讲解</subtitle>
  <link href="https://mister-kin.github.io/atom.xml" rel="self"/>
  
  <link href="https://mister-kin.github.io/"/>
  <updated>2022-02-07T10:54:42.869Z</updated>
  <id>https://mister-kin.github.io/</id>
  
  <author>
    <name>Mr. Kin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux总结</title>
    <link href="https://mister-kin.github.io/code/linux/"/>
    <id>https://mister-kin.github.io/code/linux/</id>
    <published>2022-02-05T17:14:25.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="终端符号输入">1 <a href="#终端符号输入" class="headerlink" title="终端符号输入"></a>终端符号输入</h1><ul><li>ctrl+c：停止</li><li>ctrl+z：停止输入</li></ul><h1 id="包管理器">2 <a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h1><h2 id="apt">2.1 <a href="#apt" class="headerlink" title="apt"></a>apt</h2><h3 id="apt-update证书验证错误">2.1.1 <a href="#apt-update证书验证错误" class="headerlink" title="apt update证书验证错误"></a>apt update证书验证错误</h3><p>错误信息：Certificate verification failed: The certificate is NOT trusted.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install --reinstall ca-certificates</span><br></pre></td></tr></table></figure><h1 id="硬盘和分区管理">3 <a href="#硬盘和分区管理" class="headerlink" title="硬盘和分区管理"></a>硬盘和分区管理</h1><h2 id="将-x2F-home目录挂载到新分区（或新硬盘）">3.1 <a href="#将-x2F-home目录挂载到新分区（或新硬盘）" class="headerlink" title="将&#x2F;home目录挂载到新分区（或新硬盘）"></a>将&#x2F;home目录挂载到新分区（或新硬盘）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过包管理器安装 gparted，进行新建分区或者格式化硬盘等操作。</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> /mnt/home</span><br><span class="line">sudo mount /dev/新分区 /mnt/home <span class="comment"># 挂载新分区到/mnt/home</span></span><br><span class="line">sudo rsync -aXS /home/ /mnt/home <span class="comment"># a归档模式（递归传输并保持文件属性），X保持扩展属性</span></span><br><span class="line">sudo <span class="built_in">mv</span> /home /home_old</span><br><span class="line">sudo <span class="built_in">mkdir</span> /home</span><br><span class="line">sudo umount /dev/新分区</span><br><span class="line">sudo mount /dev/新分区 /home</span><br><span class="line">blkid|grep /dev/新分区 <span class="comment"># 查看新分区的uuid</span></span><br><span class="line">sudo gedit /etc/fstab <span class="comment"># 将新分区的uuid填入fstab</span></span><br><span class="line">sudo <span class="built_in">rm</span> -rf /home_old <span class="comment"># 重启无异常，即可删除旧home目录</span></span><br></pre></td></tr></table></figure><h1 id="编译问题">4 <a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><h2 id="普通用户导致的编译问题">4.1 <a href="#普通用户导致的编译问题" class="headerlink" title="普通用户导致的编译问题"></a>普通用户导致的编译问题</h2><p>普通用户中如果在系统关键目录中，如<code>/opt</code>，执行<code>sudo make</code>可能会出现<code>xxx command not found</code>，这是因为有些命令在<code>sudo</code>下是不可见的，但如果不用<code>sudo</code>，<code>make</code>又无法在这些路径生成文件。</p><p>解决方式：使用<code>make -f</code>参数指定<code>makefile</code>文件，让它在有权限的路径中工作。例如，将工作路径切到<code>home</code>目录中，<code>make -f /opt/xxx/xxx/makefile</code>，<code>make</code>可在<code>home</code>路径中生成文件。</p><h1 id="账户管理">5 <a href="#账户管理" class="headerlink" title="账户管理"></a>账户管理</h1><h2 id="删除账户">5.1 <a href="#删除账户" class="headerlink" title="删除账户"></a>删除账户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel [-r] [user_account] <span class="comment"># 切换到其他账户再执行，建议是root账户</span></span><br><span class="line">userdel -r kin <span class="comment"># 删除账户kin，-r参数是移除该账户的home目录和用户邮箱（mail spool）</span></span><br></pre></td></tr></table></figure><h2 id="自动root登录">5.2 <a href="#自动root登录" class="headerlink" title="自动root登录"></a>自动root登录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gedit /etc/gdm/custom.conf</span><br><span class="line"># 在daemon下添加</span><br><span class="line">AutomaticLoginEnable=True</span><br><span class="line">AutomaticLogin=root</span><br></pre></td></tr></table></figure><h1 id="参考文献">6 <a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Ubuntu 18.04 apt update failed for https repository[EB&#x2F;OL]. <a href="https://askubuntu.com/questions/1229122/ubuntu%E2%80%9118%E2%80%9104%E2%80%91apt%E2%80%91update%E2%80%91failed%E2%80%91for%E2%80%91https%E2%80%91repository">https://askubuntu.com/questions/1229122/ubuntu‑18‑04‑apt‑update‑failed‑for‑https‑repository</a>.<br>[2] 将&#x2F;home 目录挂载到新分区（或新硬盘）[EB&#x2F;OL]. <a href="https://blog.51cto.com/runixcn/4605838">https://blog.51cto.com/runixcn/4605838</a>.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;终端符号输入&quot;&gt;1 &lt;a href=&quot;#终端符号输入&quot; class=&quot;headerlink&quot; title=&quot;终端符号输入&quot;&gt;&lt;/a&gt;终端符号输入&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ctrl+c：停止&lt;/li&gt;
&lt;li&gt;ctrl+z：停止输入&lt;/li&gt;
&lt;/ul&gt;
&lt;h1</summary>
        
      
    
    
    
    <category term="code" scheme="https://mister-kin.github.io/categories/code/"/>
    
    
    <category term="linux" scheme="https://mister-kin.github.io/tags/linux/"/>
    
    <category term="总结" scheme="https://mister-kin.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 第五版：第三章「字符串、向量和数组」习题答案</title>
    <link href="https://mister-kin.github.io/code-training/cpp-primer-v5/chap3/"/>
    <id>https://mister-kin.github.io/code-training/cpp-primer-v5/chap3/</id>
    <published>2022-01-28T08:54:42.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章：字符串、向量和数组"><a href="#第三章：字符串、向量和数组" class="headerlink" title="第三章：字符串、向量和数组"></a>第三章：字符串、向量和数组</h1><h2 id="练习3-1"><a href="#练习3-1" class="headerlink" title="练习3.1"></a>练习3.1</h2><blockquote><p>使用恰当的using声明重做1.4.1节（第11页）和2.6.2节（第67页）的练习。</p></blockquote><ul><li><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_1_1.cpp">1.4.1</a></li><li><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_1_2.cpp">2.6.2</a></li></ul><p>因为较为简单，每个小节就只写一个练习了。</p><p>using声明易造成名字冲突：</p><ul><li>使用using声明，一般建议为每个名字做独立的using声明，例如<code>using std::cin</code>，不太建议使用整个命名空间，例如<code>using namespace std</code>，易造成名字冲突。</li><li>头文件不应包含using声明：易造成名字冲突。</li></ul><h2 id="练习3-2"><a href="#练习3-2" class="headerlink" title="练习3.2"></a>练习3.2</h2><blockquote><p>编写一段程序从标准输入中一次读入一行，然后修改该程序使其一次读入一个词。</p></blockquote><ul><li><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_2_1.cpp">一次读入一行</a></li><li><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_2_2.cpp">一次读入一个词</a></li></ul><h2 id="练习3-3"><a href="#练习3-3" class="headerlink" title="练习3.3"></a>练习3.3</h2><blockquote><p>请说明string类的输入运算符和getline函数分别是如何处理空白字符的。</p></blockquote><ul><li>类似 cin &gt;&gt; str 的读取，string对象会忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。</li><li>类似 getline(cin, str) 的读取，string对象会从给定的输入流中读取内容，直到遇到换行符为止（换行符被读进来，但不会存放进对象）。</li></ul><h2 id="练习3-4"><a href="#练习3-4" class="headerlink" title="练习3.4"></a>练习3.4</h2><blockquote><p>编写一段程序读取两个字符串，比较其是否相等并输出结果。如果不相等，输出较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长，输出长度较大的那个字符串。</p></blockquote><ul><li><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_4_1.cpp">比较大的</a></li><li><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_4_2.cpp">长度大的</a></li></ul><h2 id="练习3-5"><a href="#练习3-5" class="headerlink" title="练习3.5"></a>练习3.5</h2><blockquote><p>编写一段程序从标准输入中读入多个字符串并将它们连接在一起，输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分隔开来。</p></blockquote><ul><li><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_5_1.cpp">无空格分隔</a></li><li><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_5_2.cpp">空格分隔</a></li></ul><p>string对象操作的一些总结：</p><ul><li><strong>定义、初始化和基本操作看下面代码（书本见P76和P77）。</strong></li><li>关系运算符&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;比较规则：依次比较每个位置上的字符大小，若都一样时，则长度更长的字符串就更大。</li><li><code>string</code>和字符字面值和字符串字面值混在一条语句中，必须确保加法运算符「+」两侧至少有一个<code>string</code>对象（因为标准库可以将字面值转换为<code>string</code>对象，但不允许两个字面值直接相加）</li><li><code>size()</code>函数返回的是<code>string::size_type</code>类型的值，是无符号数。表达式中如果有<code>size()</code>，切记不要再使用<code>int</code>。如果需要定义变量存储<code>size()</code>函数，使用<code>auto</code>或<code>decltype</code>，例如<code>auto len = str.size()</code></li><li><strong>注意字符串字面值不是<code>string</code>对象，和<code>string</code>是不同的类型（因为需要兼容C）。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义和初始化（等号是拷贝初始化，圆括号是直接初始化）</span></span><br><span class="line">string s1;     <span class="comment">//默认初始化为空串</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>; <span class="comment">// s2是s1的副本</span></span><br><span class="line">string s2 = s1; <span class="comment">// 同上，不过是拷贝初始化</span></span><br><span class="line">string s3 = (<span class="string">&quot;hello&quot;</span>); <span class="comment">// s3是字面值&quot;hello&quot;的副本（不包括字面值中的空字符）</span></span><br><span class="line">string s3 = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 同上</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(n, <span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">// s4初始化为由n个字符c组成的串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">os &lt;&lt; s; <span class="comment">// 将s写到输出流os，返回os</span></span><br><span class="line">is &gt;&gt; s; <span class="comment">// 将输入流is读取字符串赋值给s，字符串以空白分割，返回is</span></span><br><span class="line"><span class="built_in">getline</span>(is, s); <span class="comment">// 从输入流is读取一行赋值给s，返回is</span></span><br><span class="line">s.<span class="built_in">empty</span>(); <span class="comment">// s为空返回true，否则返回false</span></span><br><span class="line">s.<span class="built_in">size</span>(); <span class="comment">// 返回s中字符的个数</span></span><br><span class="line">s[n]; <span class="comment">// 返回s中第n个字符的引用，下标从0计起。</span></span><br><span class="line">s1 + s2; <span class="comment">// 返回s1和s2连接后的结果</span></span><br><span class="line">s1 = s2; <span class="comment">// 用s2的副本代替s1中原来的字符</span></span><br><span class="line">s1 == s2; <span class="comment">// 判断两个string对象是否相等，对字母大小写敏感</span></span><br><span class="line">s1 != s2;</span><br><span class="line">&lt;, &lt;=, &gt;, &gt;= ; <span class="comment">// 利用字符在字典中的顺序进行比较，对字母大小写敏感</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="练习3-6"><a href="#练习3-6" class="headerlink" title="练习3.6"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_6.cpp">练习3.6</a></h2><blockquote><p>编写一段程序，使用范围for语句将字符串内的所有字符用X代替。</p></blockquote><p><strong>for范围语句中引用的理解：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    c = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = s.<span class="built_in">begin</span>(); itr != s.<span class="built_in">end</span>(); ++itr) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;c = *itr; <span class="comment">// 每个迭代中用一个新引用绑定一个元素</span></span><br><span class="line">    c = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习3-7"><a href="#练习3-7" class="headerlink" title="练习3.7"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_7.cpp">练习3.7</a></h2><blockquote><p>就上一题完成的程序而言，如果将循环控制变量的类型设为char将发生什么？先估计一下结果，然后实际编程进行验证。</p></blockquote><p>字符串没有变化（因为c只是拷贝，即char，而非引用，即char &amp;，所以无法改变字符串的）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello, world!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : str)</span><br><span class="line">    c = <span class="string">&#x27;X&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="练习3-8"><a href="#练习3-8" class="headerlink" title="练习3.8"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_8.cpp">练习3.8</a></h2><blockquote><p>分别用while循环和传统for循环重写第一题的程序，你觉得哪种形式更好呢？为什么？</p></blockquote><p>范围for语句更好，因为不需要直接操作索引，更简洁。</p><h2 id="练习3-9"><a href="#练习3-9" class="headerlink" title="练习3.9"></a>练习3.9</h2><blockquote><p>下面的程序有何作用？它合法吗？如果不合法，为什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>不合法。使用下标访问空字符串是非法的行为（通过下标访问不存在元素的行为会导致缓冲区错误buffer overflow，本质上就是下标越界，试图访问非法内存区域）。</p><p><strong>只能对确知已存在的元素执行下标操作：建议设下标类型为<code>decltype(str.size())</code>，这样可以确保下标不会小于0。写程序逻辑时，自己确保下标小于<code>str.size()</code>即可（或者使用范围for语句遍历更方便，能有效地确保下标合法，不会出现下标越界）。</strong></p><h2 id="练习3-10"><a href="#练习3-10" class="headerlink" title="练习3.10"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_10.cpp">练习3.10</a></h2><blockquote><p>编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字符串剩余的部分。</p></blockquote><p><strong>C++标准库兼容C标准库</strong><br>C标准库头文件形如ctype.h，而在C++中，则是命名为cctype，即前面加一个c并且去除后缀.h。使用方式，标准库的名字可以在命名空间std找到。</p><h2 id="练习3-11"><a href="#练习3-11" class="headerlink" title="练习3.11"></a>练习3.11</h2><blockquote><p>下面的范围for语句合法吗？如果合法，c的类型是什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string s = <span class="string">&quot;Keep out!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>要根据for循环体中的代码来看是否合法，s是常量，c是string对象中字符的引用（const char &amp;）。因此如果for循环体中的代码重新给c赋值就会非法，如果不改变c的值，那么合法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; c;  <span class="comment">// 合法</span></span><br><span class="line">c = <span class="string">&#x27;X&#x27;</span>;    <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure><h2 id="练习3-12"><a href="#练习3-12" class="headerlink" title="练习3.12"></a>练习3.12</h2><blockquote><p>下列vector对象的定义有不正确的吗？如果有，请指出来。对于正确的，描述其执行结果；对于不正确的，说明其错误的原因。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ivec;         <span class="comment">// 在C++11当中合法，ivec的元素是vector对象</span></span><br><span class="line">vector&lt;string&gt; svec = ivec;       <span class="comment">// 不合法，类型不一样，ivec的元素是vector int，svec的元素是string</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;null&quot;</span>)</span></span>;  <span class="comment">// 合法，svec有10个字符串：&quot;null&quot;</span></span><br></pre></td></tr></table></figure><h2 id="练习3-13"><a href="#练习3-13" class="headerlink" title="练习3.13"></a>练习3.13</h2><blockquote><p>下列的vector对象各包含多少个元素？这些元素的值分别是多少？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1;         <span class="comment">// 0个，无值</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// 10个，都是0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>; <span class="comment">// 10个，都是42</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4&#123; <span class="number">10</span> &#125;;     <span class="comment">// 1个，10</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v5&#123; <span class="number">10</span>, <span class="number">42</span> &#125;; <span class="comment">// 2个，10和42</span></span><br><span class="line">vector&lt;string&gt; v6&#123; <span class="number">10</span> &#125;;  <span class="comment">// 10个，空串</span></span><br><span class="line">vector&lt;string&gt; v7&#123; <span class="number">10</span>, <span class="string">&quot;hi&quot;</span> &#125;;  <span class="comment">// 10个，都是&quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>初始化的括号区别：</p><ul><li>圆括号：构造vector对象，即圆括号声明容量和初值。</li><li>花括号：列表初始化，用花括号的值作为元素初始值。（当提供的值不能用来列表初始化时，就会用来构造对象。如<code>vector&lt;string&gt; v1&#123;10, &quot;hi&quot;&#125;;</code>，因为类型不同，所以构造成10个&quot;hi&quot;）</li></ul><h2 id="练习3-14"><a href="#练习3-14" class="headerlink" title="练习3.14"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_14.cpp">练习3.14</a></h2><blockquote><p>编写一段程序，用cin读入一组整数并把它们存入一个vector对象。</p></blockquote><p><strong>vctror对象能高效增长，在定义时设定其大小意义不大。开始时创建空vector，运行时再动态添加元素。</strong></p><h2 id="练习3-15"><a href="#练习3-15" class="headerlink" title="练习3.15"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_15.cpp">练习3.15</a></h2><blockquote><p>改写上题的程序，不过这次读入的是字符串。</p></blockquote><h2 id="练习3-16"><a href="#练习3-16" class="headerlink" title="练习3.16"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_16.cpp">练习3.16</a></h2><blockquote><p>编写一段程序，把练习3.13中vector对象的容量和具体内容输出出来。检验你之前的回答是否正确，如果不对，回过头重新学习3.3.1节（第87页）知道弄明白错在何处为止。</p></blockquote><h2 id="练习3-17"><a href="#练习3-17" class="headerlink" title="练习3.17"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_17.cpp">练习3.17</a></h2><blockquote><p>从cin读入一组词并把它们存入一个vector对象，然后设法把所有词都改写为大写形式。输出改变后的结果，每个词占一行。</p></blockquote><h2 id="练习3-18"><a href="#练习3-18" class="headerlink" title="练习3.18"></a>练习3.18</h2><blockquote><p>下面的程序合法吗？如果不合法，你准备如何修改？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line">ivec[<span class="number">0</span>] = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>不合法（ivec是空vector对象，对其执行下标操作是非法行为）。修正方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ivec.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><h2 id="练习3-19"><a href="#练习3-19" class="headerlink" title="练习3.19"></a>练习3.19</h2><blockquote><p>如果想定义一个含有10个元素的vector对象，所有元素的值都是42，请列举出三种不同的实现方法，哪种方式更好呢？为什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec1</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec2&#123; <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec3;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    ivec3.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>第一种方式最好。写法简洁。</p><h2 id="练习3-20"><a href="#练习3-20" class="headerlink" title="练习3.20"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_20.cpp">练习3.20</a></h2><blockquote><p>读入一组整数并把它们存入一个vector对象，将每对相邻整数的和输出出来。改写你的程序，这次要求先输出第1个和最后1个元素的和，接着输出第2个和倒数第2个元素的和，以此类推。</p></blockquote><h2 id="练习3-21"><a href="#练习3-21" class="headerlink" title="练习3.21"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_21.cpp">练习3.21</a></h2><blockquote><p>请使用迭代器重做3.3.3节（第94页）的第一个练习。</p></blockquote><p>迭代器的总结（本质上就是指针）：</p><ul><li>使用迭代器的循环体是用<code>!=</code>作为判断条件（像c或者java使用下标，多是用<code>&lt;</code>）。因为C++中标准库容器的迭代器都定义了<code>==</code>和<code>!=</code>，而只有string和vector某些库才有下标运算符。</li><li>容器为空时，begin和end返回的是同一个迭代器（尾后迭代器）。</li><li>尾后迭代器指示的是不存在的“尾后”元素，实际并不指示某个元素，因此不能进行递增或者解引用操作。</li><li>只需读操作时，可用cbegin和cend函数。</li><li>箭头运算符是结合解引用和成员访问两个操作，即<code>it-&gt;men</code>等同于<code>(*it).men</code>。</li><li>使用了迭代器的循环体，不要向其所属的容器添加元素。例如，在循环体中向vector对象push_back，这会导致迭代器失效。（类似的，也不能在范围for循环中向vector对象添加元素）</li></ul><h2 id="练习3-22"><a href="#练习3-22" class="headerlink" title="练习3.22"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_22.cpp">练习3.22</a></h2><blockquote><p>修改之前那个输出text第一段的程序，首先把text的第一段全都改成大写形式，然后输出它。</p></blockquote><h2 id="练习3-23"><a href="#练习3-23" class="headerlink" title="练习3.23"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_23.cpp">练习3.23</a></h2><blockquote><p>编写一段程序，创建一个含有10个整数的vector对象，然后使用迭代器将所有元素的值都变成原来的两倍。输出vector对象的内容，检验程序是否正确。</p></blockquote><h2 id="练习3-24"><a href="#练习3-24" class="headerlink" title="练习3.24"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_24.cpp">练习3.24</a></h2><blockquote><p>请使用迭代器重做3.3.3节（第94页）的最后一个练习。</p></blockquote><h2 id="练习3-25"><a href="#练习3-25" class="headerlink" title="练习3.25"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_25.cpp">练习3.25</a></h2><blockquote><p>3.3.3节（第93页）划分分数段的程序是使用下标运算符实现的，请利用迭代器改写该程序并实现完全相同的功能。</p></blockquote><h2 id="练习3-26"><a href="#练习3-26" class="headerlink" title="练习3.26"></a>练习3.26</h2><blockquote><p>在100页的二分搜索程序中，为什么用的是 mid &#x3D; beg + (end - beg) &#x2F; 2，而非 mid &#x3D; (beg + end) &#x2F; 2 ; ?</p></blockquote><p>因为两个迭代器之间支持的运算符只有<code>-</code>和<code>&gt;、&gt;=、&lt;、&lt;=</code>，而没有<code>+</code> 。<code>end - beg</code> 相减的结果是之间的距离，将之除以2然后与beg相加，表示将beg移动到一半的位置。</p><p>迭代器运算的理解：迭代器可以加减一个数（包括加减复合赋值运算符），但两个迭代器之间的运算符只有<code>-</code>和<code>&gt;、&gt;=、&lt;、&lt;=</code>关系运算符。</p><h2 id="练习3-27"><a href="#练习3-27" class="headerlink" title="练习3.27"></a>练习3.27</h2><blockquote><p>假设txt_size是一个无参数的函数，它的返回值是int。请回答下列哪个定义是非法的？为什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> buf_size = <span class="number">1024</span>;</span><br><span class="line">(a) <span class="type">int</span> ia[buf_size];</span><br><span class="line">(b) <span class="type">int</span> ia[<span class="number">4</span> * <span class="number">7</span> - <span class="number">14</span>];</span><br><span class="line">(c) <span class="type">int</span> ia[<span class="built_in">txt_size</span>()];</span><br><span class="line">(d) <span class="type">char</span> st[<span class="number">11</span>] = <span class="string">&quot;fundamental&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>(a) 非法。纬度必须是一个常量表达式。</li><li>(b) 合法。</li><li>(c) 非法。txt_size返回的是int，不是constexpr int。</li><li>(d) 非法。数组的大小应该是12，字符串字面值末尾还有个空字符&#39;\0&#39;。</li></ul><h2 id="练习3-28"><a href="#练习3-28" class="headerlink" title="练习3.28"></a>练习3.28</h2><blockquote><p>下列数组中元素的值是什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string sa[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> ia[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string sa2[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> ia2[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sa的元素值全部为空字符串，ia的元素值全部为0。sa2的元素值全部为空字符串，ia2的元素没有被初始化，初值全部未定义。</p><h2 id="练习3-29"><a href="#练习3-29" class="headerlink" title="练习3.29"></a>练习3.29</h2><blockquote><p>相比于vector来说，数组有哪些缺点，请列举一些。</p></blockquote><ul><li>数组的大小是固定的，不能随意增加元素</li><li>不允许拷贝和赋值</li><li>没有像vector那样的API</li></ul><h2 id="练习3-30"><a href="#练习3-30" class="headerlink" title="练习3.30"></a>练习3.30</h2><blockquote><p>指出下面代码中的索引错误。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> array_size = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> ia[array_size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> ix = <span class="number">1</span>; ix &lt;= array_size; ++ix)</span><br><span class="line">ia[ix] = ix;</span><br></pre></td></tr></table></figure><p>当ix等于10时，表达式ia[ix]属于未定义行为（UB），下标越界。</p><p><strong>通常将数组下标类型定义size_t，size_t定义在cstddef头文件，是一种机器相关的无符号类型，可以表示内存中任意对象的大小（因为被设计得足够大）。</strong></p><h2 id="练习3-31"><a href="#练习3-31" class="headerlink" title="练习3.31"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_31.cpp">练习3.31</a></h2><blockquote><p>编写一段程序，定义一个含有10个int的数组，令每个元素的值就是其下标值。</p></blockquote><h2 id="练习3-32"><a href="#练习3-32" class="headerlink" title="练习3.32"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_32.cpp">练习3.32</a></h2><blockquote><p>将上一题刚刚创建的数组拷贝给另外一个数组。利用vector重写程序，实现类似的功能。</p></blockquote><h2 id="练习3-33"><a href="#练习3-33" class="headerlink" title="练习3.33"></a>练习3.33</h2><blockquote><p>对于104页的程序来说，如果不初始化scores将会发生什么？</p></blockquote><p>数组中所有元素的值将会未定义（有可能不是0，会有脏数据存在）。</p><h2 id="练习3-34"><a href="#练习3-34" class="headerlink" title="练习3.34"></a>练习3.34</h2><blockquote><p>假定p1和p2都指向同一个数组中的元素，则下面程序的功能是什么？什么情况下该程序是非法的？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 += p2 - p1;</span><br></pre></td></tr></table></figure><p>将p1移动到p2的位置，即指向同一个地址。只要p1、p2值合法，该程序任何情况下都合法。</p><h2 id="练习3-35"><a href="#练习3-35" class="headerlink" title="练习3.35"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_35.cpp">练习3.35</a></h2><blockquote><p>编写一段程序，利用指针将数组中的元素置为0。</p></blockquote><p><strong>数组与指针的总结：</strong></p><ul><li>数组名是首指针（编译器会自动将其转换成一个指向数组首元素的指针）</li><li>类似迭代器，也可以获取数组的首尾指针（假设数组int array[10]&#x3D;{xxx}。<strong>类似尾迭代器，注意尾指针不指向具体元素，不能对其进行解引用或递增操作</strong>）<ul><li><code>int *begin = array; int *end = &amp;array[10];</code></li><li><code>int *begin = begin(array); int *end = end(array);</code> <strong>begin和end函数定义在iterator头文件（数组不是类类型，没有类似vector迭代器那种成员函数）</strong></li></ul></li><li>两个指针相减的结果类型是ptrdiff_t，是一种带符号类型，和size_t一样也定义在cstddef头文件。</li><li><strong>只要指针指向数组元素（或者尾元素的下一位置，即尾指针），都可以执行下标运算（当然，需要保证运算后的指针也是指向同一数组或者尾指针）。像数组这种C++语言内置的下标运算允许处理负值，但像标准库类型string和vector则限定下标是无符号类型。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;array[<span class="number">2</span>]; <span class="comment">// p指向索引为2的元素</span></span><br><span class="line"><span class="type">int</span> j = p[<span class="number">1</span>];       <span class="comment">// p[1]等价于*(p+1)，即array[3]</span></span><br><span class="line"><span class="type">int</span> k = p[<span class="number">-2</span>];      <span class="comment">// 即array[0]</span></span><br></pre></td></tr></table></figure><h2 id="练习3-36"><a href="#练习3-36" class="headerlink" title="练习3.36"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_36.cpp">练习3.36</a></h2><blockquote><p>编写一段程序，比较两个数组是否相等。再写一段程序，比较两个vector对象是否相等。</p></blockquote><h2 id="练习3-37"><a href="#练习3-37" class="headerlink" title="练习3.37"></a>练习3.37</h2><blockquote><p>下面的程序是何含义，程序的输出结果是什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> ca[] = &#123; <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cp = ca;</span><br><span class="line"><span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">    cout &lt;&lt; *cp &lt;&lt; endl;</span><br><span class="line">    ++cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会将ca字符数组中的元素打印出来，但是因为没有空字符&#39;\0&#39;的存在，循环不会终止，会打印出来很多无意义脏数据。</p><h2 id="练习3-38"><a href="#练习3-38" class="headerlink" title="练习3.38"></a>练习3.38</h2><blockquote><p>在本节中我们提到，将两个指针相加不但是非法的，而且也没什么意义。请问为什么两个指针相加没什么意义？</p></blockquote><p><strong>指针本质就是地址</strong>，将两个指针相减可以表示两个指针(在同一数组中)的距离，将指针加上一个整数也可以表示移动这个指针到某一位置。<strong>但是两个指针相加后的地址并没有逻辑上的意义。</strong></p><p><a href="https://stackoverflow.com/questions/2935038/why-cant-i-add-pointers">参考资料</a></p><h2 id="练习3-39"><a href="#练习3-39" class="headerlink" title="练习3.39"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_39.cpp">练习3.39</a></h2><blockquote><p>编写一段程序，比较两个string对象。再编写一段程序，比较两个C风格字符串的内容。</p></blockquote><p><strong>C标准库string函数（头文件cstring）</strong></p><ul><li>strlen(p) 返回p的长度，不计算空字符</li><li>strcmp(p1,p2) 比较p1和p2，<code>p1==p2</code>则返回0；<code>p1&gt;p2</code>则返回正值；<code>p1&lt;p2</code>则返回负值</li><li>strcat(p1,p2) p2附加到p1后，再返回p1</li><li>strcpy(p1,p2) p2拷贝给p1，再返回p1</li></ul><p><strong>注意这些函数的指针必须指向以空字符作为结束的数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125; <span class="comment">// 没有以空字符结束。</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt; endl; <span class="comment">// 严重错误，没有空字符，该函数有可能在内存中不断向前寻找，直至找到空字符。</span></span><br><span class="line"><span class="comment">// 修正方式：用字符串字面值给ca赋初值&quot;ab&quot;。</span></span><br></pre></td></tr></table></figure><h2 id="练习3-40"><a href="#练习3-40" class="headerlink" title="练习3.40"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_40.cpp">练习3.40</a></h2><blockquote><p>编写一段程序，定义两个字符数组并用字符串字面值初始化它们；接着再定义一个字符数组存放前面两个数组连接后的结果。使用strcpy和strcat把前两个数组的内容拷贝到第三个数组当中。</p></blockquote><h2 id="练习3-41"><a href="#练习3-41" class="headerlink" title="练习3.41"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_41.cpp">练习3.41</a></h2><blockquote><p>编写一段程序，用整型数组初始化一个vector对象。</p></blockquote><h2 id="练习3-42"><a href="#练习3-42" class="headerlink" title="练习3.42"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_42.cpp">练习3.42</a></h2><blockquote><p>编写一段程序，将含有整数元素的vector对象拷贝给一个整型数组。</p></blockquote><p><strong>使用数组初始化vector对象（不能用数组初始化数组；不能用vector对象初始化数组）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(begin(array), end(array))</span></span>; <span class="comment">// 使用首尾指针</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subv</span><span class="params">(array + <span class="number">1</span>, array + <span class="number">3</span>)</span></span>; <span class="comment">// 数组中的部分也可用来初始化</span></span><br></pre></td></tr></table></figure><p><strong>混用string对象和C风格字符串</strong></p><ul><li>允许使用以空字符结束的字符数组来初始化或赋值给string对象</li><li>string对象的加法运算允许以空字符结束的字符数组作为其中一个运算对象（加法运算符「+」两侧至少有一个string对象）</li><li>string复合赋值运算中允许以空字符结束的字符数组作为右侧运算对象</li><li>string对象不能直接初始化指向字符的指针，需要使用成员函数<code>c_str</code>返回指针，如<code>const char *str = s.c_str();</code></li></ul><h2 id="练习3-43"><a href="#练习3-43" class="headerlink" title="练习3.43"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_43.cpp">练习3.43</a></h2><blockquote><p>编写3个不同版本的程序，令其均能输出ia的元素。版本1使用范围for语句管理迭代过程；版本2和版本3都使用普通for语句，其中版本2要求使用下标运算符，版本3要求使用指针。此外，在所有3个版本的程序中都要直接写出数据类型，而不能使用类型别名、auto关键字和decltype关键字。</p></blockquote><h2 id="练习3-44"><a href="#练习3-44" class="headerlink" title="练习3.44"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_44.cpp">练习3.44</a></h2><blockquote><p>改写上一个练习中的程序，使用类型别名来代替循环控制变量的类型。</p></blockquote><h2 id="练习3-45"><a href="#练习3-45" class="headerlink" title="练习3.45"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_45.cpp">练习3.45</a></h2><blockquote><p>再一次改写程序，这次使用auto关键字。</p></blockquote><p><strong>多维数组和指针的总结</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多维数组本质上是数组的数组，初始化时内层嵌套的花括号也可去掉</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用范围for语句处理多维数组时，要将控制变量声明为引用类型（为避免编译器将其转换成指针）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义指向多维数组的指针注意写法（手动写较易写错，建议使用auto或者decltype）</span></span><br><span class="line"><span class="type">int</span> *ip[<span class="number">2</span>];          <span class="comment">// 整型指针的数组</span></span><br><span class="line"><span class="built_in">int</span>(*ip)[<span class="number">2</span>];         <span class="comment">// 指针，指向含有2个整数的数组</span></span><br><span class="line"><span class="built_in">int</span>(&amp;ip)[<span class="number">2</span>] = ia[<span class="number">0</span>]; <span class="comment">// 引用，指向含有2个整数的数组</span></span><br><span class="line"><span class="comment">// 类型别名简化写法，下面两行等同于int(*ip)[2];</span></span><br><span class="line"><span class="keyword">using</span> int_array = <span class="type">int</span>[<span class="number">2</span>];</span><br><span class="line">int_array *ip;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第三章：字符串、向量和数组&quot;&gt;&lt;a href=&quot;#第三章：字符串、向量和数组&quot; class=&quot;headerlink&quot; title=&quot;第三章：字符串、向量和数组&quot;&gt;&lt;/a&gt;第三章：字符串、向量和数组&lt;/h1&gt;&lt;h2 id=&quot;练习3-1&quot;&gt;&lt;a href=&quot;#练习3-1&quot; class=&quot;headerlink&quot; title=&quot;练习3.1&quot;&gt;&lt;/a&gt;练习3.1&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用恰当的using声明重做1.4.1节（第11页）和2.6.2节（第67页）的练习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_1_1.cpp&quot;&gt;1.4.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_1_2.cpp&quot;&gt;2.6.2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为较为简单，每个小节就只写一个练习了。&lt;/p&gt;
&lt;p&gt;using声明易造成名字冲突：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用using声明，一般建议为每个名字做独立的using声明，例如&lt;code&gt;using std::cin&lt;/code&gt;，不太建议使用整个命名空间，例如&lt;code&gt;using namespace std&lt;/code&gt;，易造成名字冲突。&lt;/li&gt;
&lt;li&gt;头文件不应包含using声明：易造成名字冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;练习3-2&quot;&gt;&lt;a href=&quot;#练习3-2&quot; class=&quot;headerlink&quot; title=&quot;练习3.2&quot;&gt;&lt;/a&gt;练习3.2&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;编写一段程序从标准输入中一次读入一行，然后修改该程序使其一次读入一个词。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_2_1.cpp&quot;&gt;一次读入一行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_2_2.cpp&quot;&gt;一次读入一个词&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;练习3-3&quot;&gt;&lt;a href=&quot;#练习3-3&quot; class=&quot;headerlink&quot; title=&quot;练习3.3&quot;&gt;&lt;/a&gt;练习3.3&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;请说明string类的输入运算符和getline函数分别是如何处理空白字符的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;类似 cin &amp;gt;&amp;gt; str 的读取，string对象会忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。&lt;/li&gt;
&lt;li&gt;类似 getline(cin, str) 的读取，string对象会从给定的输入流中读取内容，直到遇到换行符为止（换行符被读进来，但不会存放进对象）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;练习3-4&quot;&gt;&lt;a href=&quot;#练习3-4&quot; class=&quot;headerlink&quot; title=&quot;练习3.4&quot;&gt;&lt;/a&gt;练习3.4&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;编写一段程序读取两个字符串，比较其是否相等并输出结果。如果不相等，输出较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长，输出长度较大的那个字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_4_1.cpp&quot;&gt;比较大的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_4_2.cpp&quot;&gt;长度大的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;练习3-5&quot;&gt;&lt;a href=&quot;#练习3-5&quot; class=&quot;headerlink&quot; title=&quot;练习3.5&quot;&gt;&lt;/a&gt;练习3.5&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;编写一段程序从标准输入中读入多个字符串并将它们连接在一起，输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分隔开来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_5_1.cpp&quot;&gt;无空格分隔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap3/3_5_2.cpp&quot;&gt;空格分隔&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;string对象操作的一些总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义、初始化和基本操作看下面代码（书本见P76和P77）。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;关系运算符&amp;lt;、&amp;lt;&amp;#x3D;、&amp;gt;、&amp;gt;&amp;#x3D;比较规则：依次比较每个位置上的字符大小，若都一样时，则长度更长的字符串就更大。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt;和字符字面值和字符串字面值混在一条语句中，必须确保加法运算符「+」两侧至少有一个&lt;code&gt;string&lt;/code&gt;对象（因为标准库可以将字面值转换为&lt;code&gt;string&lt;/code&gt;对象，但不允许两个字面值直接相加）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size()&lt;/code&gt;函数返回的是&lt;code&gt;string::size_type&lt;/code&gt;类型的值，是无符号数。表达式中如果有&lt;code&gt;size()&lt;/code&gt;，切记不要再使用&lt;code&gt;int&lt;/code&gt;。如果需要定义变量存储&lt;code&gt;size()&lt;/code&gt;函数，使用&lt;code&gt;auto&lt;/code&gt;或&lt;code&gt;decltype&lt;/code&gt;，例如&lt;code&gt;auto len = str.size()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意字符串字面值不是&lt;code&gt;string&lt;/code&gt;对象，和&lt;code&gt;string&lt;/code&gt;是不同的类型（因为需要兼容C）。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义和初始化（等号是拷贝初始化，圆括号是直接初始化）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string s1;     &lt;span class=&quot;comment&quot;&gt;//默认初始化为空串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;string &lt;span class=&quot;title&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s1)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// s2是s1的副本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string s2 = s1; &lt;span class=&quot;comment&quot;&gt;// 同上，不过是拷贝初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string s3 = (&lt;span class=&quot;string&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// s3是字面值&amp;quot;hello&amp;quot;的副本（不包括字面值中的空字符）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string s3 = &lt;span class=&quot;string&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 同上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;string &lt;span class=&quot;title&quot;&gt;s4&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(n, &lt;span class=&quot;string&quot;&gt;&amp;#x27;c&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// s4初始化为由n个字符c组成的串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 基本操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;os &amp;lt;&amp;lt; s; &lt;span class=&quot;comment&quot;&gt;// 将s写到输出流os，返回os&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;is &amp;gt;&amp;gt; s; &lt;span class=&quot;comment&quot;&gt;// 将输入流is读取字符串赋值给s，字符串以空白分割，返回is&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;getline&lt;/span&gt;(is, s); &lt;span class=&quot;comment&quot;&gt;// 从输入流is读取一行赋值给s，返回is&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s.&lt;span class=&quot;built_in&quot;&gt;empty&lt;/span&gt;(); &lt;span class=&quot;comment&quot;&gt;// s为空返回true，否则返回false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;(); &lt;span class=&quot;comment&quot;&gt;// 返回s中字符的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s[n]; &lt;span class=&quot;comment&quot;&gt;// 返回s中第n个字符的引用，下标从0计起。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s1 + s2; &lt;span class=&quot;comment&quot;&gt;// 返回s1和s2连接后的结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s1 = s2; &lt;span class=&quot;comment&quot;&gt;// 用s2的副本代替s1中原来的字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s1 == s2; &lt;span class=&quot;comment&quot;&gt;// 判断两个string对象是否相等，对字母大小写敏感&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s1 != s2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;= ; &lt;span class=&quot;comment&quot;&gt;// 利用字符在字典中的顺序进行比较，对字母大小写敏感&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="code-training" scheme="https://mister-kin.github.io/categories/code-training/"/>
    
    <category term="cpp-primer-v5" scheme="https://mister-kin.github.io/categories/code-training/cpp-primer-v5/"/>
    
    
    <category term="C++" scheme="https://mister-kin.github.io/tags/C/"/>
    
    <category term="C++ Primer" scheme="https://mister-kin.github.io/tags/C-Primer/"/>
    
    <category term="习题答案" scheme="https://mister-kin.github.io/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
    <category term="第三章" scheme="https://mister-kin.github.io/tags/%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    
    <category term="字符串" scheme="https://mister-kin.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="向量" scheme="https://mister-kin.github.io/tags/%E5%90%91%E9%87%8F/"/>
    
    <category term="数组" scheme="https://mister-kin.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 第五版：第二章「变量和基本类型」习题答案</title>
    <link href="https://mister-kin.github.io/code-training/cpp-primer-v5/chap2/"/>
    <id>https://mister-kin.github.io/code-training/cpp-primer-v5/chap2/</id>
    <published>2022-01-19T11:56:31.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章：变量和基本类型"><a href="#第二章：变量和基本类型" class="headerlink" title="第二章：变量和基本类型"></a>第二章：变量和基本类型</h1><h2 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2.1"></a>练习2.1</h2><blockquote><p>类型 int、long、long long 和 short 的区别是什么？无符号类型和带符号类型的区别是什么？float 和 double的区别是什么？</p></blockquote><p>C++ 规定 <code>short</code> 和 <code>int</code> 至少16位，<code>long</code> 至少32位，<code>long long</code> 至少64位。<br>带符号类型能够表示正数、负数和 0 ，而无符号类型只能够表示 0 和正整数。<br>通常，单精度<code>float</code>用1个字表示（4个字节，32bit），双精度<code>double</code>用2个字表示（8个字节，64bit）。</p><p>用法（类型的选择）：</p><ul><li>如果确认数据是非负的，那么就使用 <code>unsigned</code> 无符号类型。</li><li>一般使用 <code>int</code> 做整数运算，<code>short</code> 因为太小在实际中用的少，<code>long</code> 通常和 <code>int</code> 有着相同的大小。如果数据非常大，可以使用 <code>long long</code> 。</li><li>算术表达式不用 <code>char</code> 或 <code>bool</code> ，这二者只建议用于存放字符或布尔值。因为<code>char</code>在某些机器上是有符号的，在另一些机器上是无符号型的，则使用 <code>char</code> 进行运算容易出问题。如果需要较小的整数，就明确指定 <code>signed char</code> 或者 <code>unsigned char</code>。</li><li>执行浮点运算时用 <code>double</code> ，因为 <code>float</code> 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。</li></ul><p>参考：</p><ul><li><a href="https://isocpp.org/wiki/faq/newbie#choosing-int-size">What are the criteria for choosing between short &#x2F; int &#x2F; long data types?</a></li><li><a href="http://stackoverflow.com/questions/2386772/difference-between-float-and-double">Difference between float and double</a></li></ul><h3 id="float有效位理解"><a href="#float有效位理解" class="headerlink" title="float有效位理解"></a>float有效位理解</h3><p>IEEE规定<code>float</code>为32bit，尾数用23位存储，加上隐含的小数点前的1位1，2^(23+1) &#x3D; 16777216。因为 10^7 &lt; 16777216 &lt; 10^8，所以说单精度浮点数的有效位数是7位（能保证7位有效数字，当然，并非说第8位一定是非有效数字，它也有可能是准确的）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> i = <span class="number">12345678.76348</span>;</span><br><span class="line">    <span class="type">float</span> j = <span class="number">46857.9874</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n%f\n%.3f\n%.8f&quot;</span>, i, j, j, j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12345679.000000</span><br><span class="line">46857.988281</span><br><span class="line">46857.988</span><br><span class="line">46857.98828125</span><br></pre></td></tr></table></figure><p>从以上数据可以看出，第八个数字之后就不精确了。另外，要注意，有效数字的位数与指定输出的小数位数（%.7f，保留7位有效数字）是两码事，如第三第四个输出，这个是程序指定的输出格式，和类型本身能够存储的精度不是一回事。</p><h2 id="练习2-2"><a href="#练习2-2" class="headerlink" title="练习2.2"></a>练习2.2</h2><blockquote><p>计算按揭贷款时，对于利率、本金和付款分别应选择何种数据类型？说明你的理由。</p></blockquote><p>使用 <code>double</code> 或 <code>float</code> 。</p><h2 id="练习2-3"><a href="#练习2-3" class="headerlink" title="练习2.3"></a>练习2.3</h2><blockquote><p>读程序写结果。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> u = <span class="number">10</span>, u2 = <span class="number">42</span>;</span><br><span class="line">std::cout &lt;&lt; u2 - u &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; u - u2 &lt;&lt; std::endl;</span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>, i2 = <span class="number">42</span>;</span><br><span class="line">std::cout &lt;&lt; i2 - i &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; i - i2 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; i - u &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; u - i &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">32</span><br><span class="line">4294967264 // -32=(-1)×2^32+4294967264</span><br><span class="line">32</span><br><span class="line">-32</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="类型转换的总结"><a href="#类型转换的总结" class="headerlink" title="类型转换的总结"></a>类型转换的总结</h3><ul><li>非布尔类型转换布尔类型时，0转换成false，非0则true（包括负数）。</li><li>布尔值转换非布尔类型时，false转换为0，true则1。</li><li>浮点数转换整数时，仅保留小数点之前的部分（即整数部分，小数部分直接截断），这是精度损失；当浮点数表示的值大过整型值，会发生溢出。</li><li>整数转浮点数时，小数部分记为0。不会发生溢出，但当整数值数据较大时，转换浮点数可能会发生精度丢失。例如，<code>int</code> 有31bit用来拓展精度，<code>float</code> 只有24bit，即当int值大于2^24或者小于-2^24时，转换<code>float</code>就会精度丢失。</li><li>给无符号类型赋值超过其表示范围时，实际值是初始值对无符号类型表示数值总数取模后的余数。8bit的<code>unsigned char</code>表示0-255，赋值超出范围时，实际值为该值对256取模后的余数。因此将-1赋给8bit的<code>unsigned char</code>时，结果值为255。</li><li>赋给带符号类型一个超出范围的值时，结果是未定义的。此时，程序可能工作、可能崩溃、也可能生成垃圾数据。</li></ul><p><strong>无符号类型和有符号类型计算，结果为负数时，结果值的计算方法</strong></p><p>给定一个正整数p，任意一个整数n，一定存在等式n&#x3D;kp+r</p><p>其中k、r是整数，且0&lt;&#x3D;r&lt;p，称k为n除以p的商，r为n除以p的余数。</p><p>定义取模运算：a % p（或a mod p），表示a除以p的余数。</p><p><strong>实际运用场景</strong>：将-1赋给8bit的<code>unsigned char</code>时，结果值为255。<br>计算过程：-1&#x3D;(-1)×256+255</p><p>二进制表示的本质：用补码表示，先看原码（符号位为1，数值位只有一个1）对原码取反加1（符号位不变），转换成补码后，所有位都是1。</p><h3 id="类型转换的使用场景总结"><a href="#类型转换的使用场景总结" class="headerlink" title="类型转换的使用场景总结"></a>类型转换的使用场景总结</h3><ul><li>不要混用带符号类型和无符号类型：表达式中含有这两种类型时，带符号数会自动转换成无符号数（此时，一个负数转换成无符号数后，真值将很大）。</li><li>循环中的判断条件慎用无符号数：无符号数表示范围为正整数，不会小于0，尤其是当循环的临界条件是0时。如以下代码，就是死循环，当u&#x3D;0时，循环条件依然满足，继续执行，--u就是-1，但无符号数只能表示整数，-1被自动地转换成一个合法的无符号数，即正整数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> u = <span class="number">10</span>; u &gt;= <span class="number">0</span>; --u)</span><br><span class="line">    std::cout &lt;&lt; u &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>解决方式：</p><ol><li>用有符号类型</li><li>用while语句，代码如下。</li><li>类似while语句，将for语句的--u置于cout语句中。</li><li>2和3本质上就是保证u不会变为-1。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> u = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">while</span> (u &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    --u;</span><br><span class="line">    std::cout &lt;&lt; u &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习2-4"><a href="#练习2-4" class="headerlink" title="练习2.4"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap2/2_4.cpp">练习2.4</a></h2><blockquote><p>编写程序检查你的估计是否正确，如果不正确，请仔细研读本节直到弄明白问题所在。</p></blockquote><span id="more"></span><h2 id="练习2-5"><a href="#练习2-5" class="headerlink" title="练习2.5"></a>练习2.5</h2><blockquote><p>指出下述字面值的数据类型并说明每一组内几种字面值的区别：</p></blockquote><ul><li>(a) &#39;a&#39;, L&#39;a&#39;, &quot;a&quot;, L&quot;a&quot;</li><li>(b) 10, 10u, 10L, 10uL, 012, 0xC</li><li>(c) 3.14, 3.14f, 3.14L</li><li>(d) 10, 10u, 10., 10e-2</li></ul><p>(a): 字符字面值，宽字符字面值，字符串字面值，宽字符串字面值。</p><p>(b): 十进制整型，十进制无符号整型，十进制长整型，十进制无符号长整型，八进制整型，十六进制整型。</p><p>(c): double, float, long double</p><p>(d): 十进制整型，十进制无符号整型，double, double</p><p>P.S. 要注意&#39;a&#39;和&quot;a&quot;不一样，&quot;a&quot;包含两个字符，字母和空字符（字符串字面值是由常量字符构成的数组，编译器会在字符串结尾处添加一个空字符&#39;\0&#39;）。</p><h2 id="练习2-6"><a href="#练习2-6" class="headerlink" title="练习2.6"></a>练习2.6</h2><blockquote><p>下面两组定义是否有区别，如果有，请叙述之：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> month = <span class="number">9</span>, day = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> month = <span class="number">09</span>, day = <span class="number">07</span>;</span><br></pre></td></tr></table></figure><p>第一行定义的是十进制整型。<br>第二行定义的是八进制整型，但是 month 变量无效，因为八进制没有 9 。</p><h2 id="练习2-7"><a href="#练习2-7" class="headerlink" title="练习2.7"></a>练习2.7</h2><blockquote><p>下述字面值表示何种含义？它们各自的数据类型是什么？</p></blockquote><ul><li>(a) &quot;Who goes with F\145rgus?\012&quot;</li><li>(b) 3.14e1L</li><li>(c) 1024f</li><li>(d) 3.14L</li></ul><p>(a): Who goes with Fergus?(换行)，string 类型：\145转为二进制001100101，ASCII表查询为e；\012转为二进制000001010，ASCII表查询为转义字符\n，即换行。</p><p>(b): long double</p><p>(c): 无效，因为后缀 f 只能用于浮点字面量，而 1024 是整型。</p><p>(d): long double</p><p>参考：</p><ul><li><a href="https://www.ascii-code.com/">ASCII Code</a></li><li><a href="http://www.asciitable.com/">ASCII Table</a></li></ul><p>转义序列的格式：</p><ul><li>反斜杠\后面跟着八进制的数字超过3个时，只有前三个与\构成转义序列。例如&quot;\1234&quot;表示两个字符，字符\123和字符4</li><li>\x会用到后面所有数字，例如&quot;\x1234&quot;表示一个16bit的字符，这种16bit字符一般都是与扩展字符集使用（用前缀表示，如u8啥的）。</li></ul><h2 id="练习2-8"><a href="#练习2-8" class="headerlink" title="练习2.8"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap2/2_8.cpp">练习2.8</a></h2><blockquote><p>请利用转义序列编写一段程序，要求先输出 2M，然后转到新一行。修改程序使其先输出 2，然后输出制表符，再输出 M，最后转到新一行。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\062\115\012&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\062\t\115\012&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习2-9"><a href="#练习2-9" class="headerlink" title="练习2.9"></a>练习2.9</h2><blockquote><p>解释下列定义的含义，对于非法的定义，请说明错在何处并将其改正。</p></blockquote><ul><li>(a) std::cin &gt;&gt; int input_value;</li><li>(b) int i &#x3D; { 3.14 };</li><li>(c) double salary &#x3D; wage &#x3D; 9999.99;</li><li>(d) int i &#x3D; 3.14;</li></ul><p>(a): 应该先定义再使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> input_value = <span class="number">0</span>;</span><br><span class="line">std::cin &gt;&gt; input_value;</span><br></pre></td></tr></table></figure><p>(b): 用列表初始化内置类型的变量时，如果存在丢失信息的风险，则编译器将报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> i = &#123; <span class="number">3.14</span> &#125;;</span><br></pre></td></tr></table></figure><p>(c): 在这里 wage 是未定义的，应该在此之前将其定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> wage;</span><br><span class="line"><span class="type">double</span> salary = wage = <span class="number">9999.99</span>;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> wage, salary = wage = <span class="number">9999.99</span>;</span><br></pre></td></tr></table></figure><p>(d): 不报错，但是小数部分会被截断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> i = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><h2 id="练习2-10"><a href="#练习2-10" class="headerlink" title="练习2.10"></a>练习2.10</h2><blockquote><p>下列变量的初值分别是什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::string global_str;</span><br><span class="line"><span class="type">int</span> global_int;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_int;</span><br><span class="line">    std::string local_str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>global_int</code> 是全局变量，所以初值为 0 。<br><code>local_int</code> 是局部变量并且没有初始化，它的初值是未定义的。<br><code>global_str</code> 和 <code>local_str</code> 是 string 类的对象，该对象定义了默认的初始化方式，即初始化为空字符串。</p><p><strong>P.S. 要养成良好习惯，初始化每个内置类型的变量，避免这种未定义造成程序运行故障（无法预计的故障）。</strong></p><h2 id="练习2-11"><a href="#练习2-11" class="headerlink" title="练习2.11"></a>练习2.11</h2><blockquote><p>指出下面的语句是声明还是定义：</p></blockquote><ul><li>(a) extern int ix &#x3D; 1024;</li><li>(b) int iy;</li><li>(c) extern int iz;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a): 定义</span><br><span class="line">(b): 定义</span><br><span class="line">(c): 声明</span><br></pre></td></tr></table></figure><h2 id="练习2-12"><a href="#练习2-12" class="headerlink" title="练习2.12"></a>练习2.12</h2><blockquote><p>请指出下面的名字中哪些是非法的？</p></blockquote><ul><li>(a) int double &#x3D; 3.14;</li><li>(b) int _;</li><li>(c) int catch-22;</li><li>(d) int 1_or_2 &#x3D; 1;</li><li>(e) double Double &#x3D; 3.14;</li></ul><p><code>(a)</code>, <code>(c)</code>, <code>(d)</code> 非法。</p><p>标识符由<strong>字母、数字和下划线</strong>组成。开头必须是<strong>字母或下划线</strong>。（C++中用户自定义的标识符，<strong>不能连续出现两个下划线，不能以下划线紧连大写字母开头</strong>）</p><h2 id="练习2-13"><a href="#练习2-13" class="headerlink" title="练习2.13"></a>练习2.13</h2><blockquote><p>下面程序中 j 的值是多少？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>j</code> 的值是 <code>100</code> ，局部变量 <code>i</code> 覆盖了全局变量 <code>i</code> 。</p><h2 id="练习2-14"><a href="#练习2-14" class="headerlink" title="练习2.14"></a>练习2.14</h2><blockquote><p>下面的程序合法吗？如果合法，它将输出什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">100</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    sum += i;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>合法。输出是 <code>100 45</code> 。</p><h2 id="练习2-15"><a href="#练习2-15" class="headerlink" title="练习2.15"></a>练习2.15</h2><blockquote><p>下面的哪个定义是不合法的？为什么？</p></blockquote><ul><li>(a) int ival &#x3D; 1.01;</li><li>(b) int &amp;rval1 &#x3D; 1.01;</li><li>(c) int &amp;rval2 &#x3D; ival;</li><li>(d) int &amp;rval3;</li></ul><p><code>(b)</code> 和 <code>(d)</code> 不合法，<code>(b)</code> 引用必须绑定在对象上，<code>(d)</code> 引用必须初始化。</p><p><strong>引用（左值引用）只能绑定在对象上，而且必须初始化。</strong></p><h2 id="练习2-16"><a href="#练习2-16" class="headerlink" title="练习2.16"></a>练习2.16</h2><blockquote><p>考察下面的所有赋值然后回答：哪些赋值是不合法的？为什么？哪些赋值是合法的？它们执行了哪些操作？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 0, &amp;r1 = i; double d = 0, &amp;r2 = d;</span><br><span class="line">- (a) r2 = 3.14159;</span><br><span class="line">- (b) r2 = r1;</span><br><span class="line">- (c) i = r2;</span><br><span class="line">- (d) r1 = d;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a): 合法。给 d 赋值为 3.14159。</span><br><span class="line">(b): 合法。会执行自动转换（这里的自动转换不是指改变原有类型，int-&gt;double，先转换再赋值）。</span><br><span class="line">(c): 合法。会发生小数截断。</span><br><span class="line">(d): 合法。会发生小数截断。</span><br></pre></td></tr></table></figure><h2 id="练习2-17"><a href="#练习2-17" class="headerlink" title="练习2.17"></a>练习2.17</h2><blockquote><p>执行下面的代码段将输出什么结果？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, &amp;ri = i;</span><br><span class="line">i = <span class="number">5</span>; ri = <span class="number">10</span>;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ri &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 10</span><br></pre></td></tr></table></figure><h2 id="练习2-18"><a href="#练习2-18" class="headerlink" title="练习2.18"></a>练习2.18</h2><blockquote><p>编写代码分别改变指针的值以及指针所指对象的值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;a, *p2 = p1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// change the value of a pointer.</span></span><br><span class="line">p1 = &amp;b;</span><br><span class="line"><span class="comment">// change the value to which the pointer points</span></span><br><span class="line">*p2 = b;</span><br></pre></td></tr></table></figure><h2 id="练习2-19"><a href="#练习2-19" class="headerlink" title="练习2.19"></a>练习2.19</h2><blockquote><p>说明指针和引用的主要区别</p></blockquote><ol><li>引用是另一个对象的别名（但不是对象），而指针本身就是一个对象。</li><li>引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。而指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。</li></ol><h2 id="练习2-20"><a href="#练习2-20" class="headerlink" title="练习2.20"></a>练习2.20</h2><blockquote><p>请叙述下面这段代码的作用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;i;</span><br><span class="line">*p1 = *p1 * *p1;</span><br></pre></td></tr></table></figure><p>让指针 <code>pi</code> 指向 <code>i</code>，然后将 <code>i</code> 的值重新赋值为 42 * 42 (1764)。</p><h2 id="练习2-21"><a href="#练习2-21" class="headerlink" title="练习2.21"></a>练习2.21</h2><blockquote><p>请解释下述定义。在这些定义中有非法的吗？如果有，为什么？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">(a) double* dp = &amp;i;</span><br><span class="line">(b) int *ip = i;</span><br><span class="line">(c) int *p = &amp;i;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a): 非法。不能将一个指向 `double` 的指针指向 `int` 。</span><br><span class="line">(b): 非法。不能将 `int` 变量赋给指针。</span><br><span class="line">(c): 合法。</span><br></pre></td></tr></table></figure><h2 id="练习2-22"><a href="#练习2-22" class="headerlink" title="练习2.22"></a>练习2.22</h2><blockquote><p>假设 p 是一个 int 型指针，请说明下述代码的含义。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p) <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (*p) <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><code>if (p) // ...</code>  判断 p 是不是一个空指针,<br><code>if (*p) // ...</code> 判断 p 所指向的对象的值是不是为 0</p><h2 id="练习2-23"><a href="#练习2-23" class="headerlink" title="练习2.23"></a>练习2.23</h2><blockquote><p>给定指针 p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因。</p></blockquote><p>不能，因为首先要确定这个指针是不是合法的，才能判断它所指向的对象是不是合法的。</p><p>书本P47，指针具有4种状态，指向对象只是状态之一。</p><h2 id="练习2-24"><a href="#练习2-24" class="headerlink" title="练习2.24"></a>练习2.24</h2><blockquote><p>在下面这段代码中为什么 p 合法而 lp 非法？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">void</span> *p = &amp;i;</span><br><span class="line"><span class="type">long</span> *lp = &amp;i;</span><br></pre></td></tr></table></figure><p><code>void *</code> 是（从C语言那里继承过来的，这句话存疑，暂未查证），可以指向任何类型的对象（即可以存放任意对象的地址）。而其他指针类型必须要与所指对象严格匹配。</p><p>注意，<code>void *</code>不是空指针，空指针是null pointer，不指向任何对象，字面值常用<code>nullptr</code>。</p><h2 id="练习2-25"><a href="#练习2-25" class="headerlink" title="练习2.25"></a>练习2.25</h2><blockquote><p>说明下列变量的类型和值。</p></blockquote><ul><li>(a) int* ip, i, &amp;r &#x3D; i;</li><li>(b) int i, *ip &#x3D; 0;</li><li>(c) int* ip, ip2;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a): ip是一个指向int的指针（块作用域内不赋初值），i是一个int（块作用域内不赋初值）, r是i的引用（同上）。</span><br><span class="line">(b): i是int（块作用域内不赋初值），ip是一个空指针（不指向任何对象）。</span><br><span class="line">(c): ip是一个指向int的指针（块作用域内不赋初值）, ip2是一个 int（块作用域内不赋初值）。</span><br></pre></td></tr></table></figure><p>作用域：全局作用域（global scope）和块作用域（block scope），一般块作用域习惯称为局部作用域。</p><p>面对一条复杂的指针或引用的声明语句时，从右往左阅读：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival;</span><br><span class="line"><span class="type">int</span> **ppi = &amp;pi; <span class="comment">// ppi是指向指针的指针</span></span><br><span class="line"><span class="type">int</span> **ppi = <span class="number">0</span><span class="comment">// 为访问最原始的对象，需要两次解引用 **ppi</span></span><br><span class="line"><span class="type">int</span> *&amp;r = pi <span class="comment">// 从右往左阅读，&amp;r是一个引用，*说明r引用的是指针，int类型则具体说明了r引用的是int指针。</span></span><br></pre></td></tr></table></figure><h2 id="练习2-26"><a href="#练习2-26" class="headerlink" title="练习2.26"></a>练习2.26</h2><blockquote><p>下面哪些语句是合法的？如果不合法，请说明为什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> buf;      <span class="comment">// 不合法, const 对象必须初始化</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;        <span class="comment">// 合法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = cnt; <span class="comment">// 合法</span></span><br><span class="line">++cnt; ++sz;        <span class="comment">// ++sz不合法, const 对象不能被改变</span></span><br></pre></td></tr></table></figure><h2 id="练习2-27"><a href="#练习2-27" class="headerlink" title="练习2.27"></a>练习2.27</h2><blockquote><p>下面的哪些初始化是合法的？请说明原因。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>;         <span class="comment">// 不合法, r必须引用一个对象（非常量引用的初始值必须是一个对象）</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p2 = &amp;i2;        <span class="comment">// 合法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>;   <span class="comment">// 合法，常量引用可以非常量的对象、绑定字面值、一般表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = &amp;i2;  <span class="comment">// 合法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;i2;        <span class="comment">// 合法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;<span class="type">const</span> r2;        <span class="comment">// 不合法, r2是引用，引用没有顶层 const（引用只是对象的别名）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i2 = i, &amp;r = i;   <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure><h2 id="练习2-28"><a href="#练习2-28" class="headerlink" title="练习2.28"></a>练习2.28</h2><blockquote><p>说明下面的这些定义是什么意思，挑出其中不合法的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, *<span class="type">const</span> cp;       <span class="comment">// 不合法，cp未初始化，const指针必须初始化（指针常量要初始化）</span></span><br><span class="line"><span class="type">int</span> *p1, *<span class="type">const</span> p2;     <span class="comment">// 不合法，p2未初始化，const指针必须初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ic, &amp;r = ic;  <span class="comment">// 不合法，ic未初始化，const int必须初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3;    <span class="comment">// 不合法，p3未初始化，const指针必须初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p;           <span class="comment">// 合法。一个指针，指向 const int（常量指针）</span></span><br></pre></td></tr></table></figure><p><strong>一个常量对象必须初始化，一旦初始化其值就不能再改变。</strong></p><h2 id="练习2-29"><a href="#练习2-29" class="headerlink" title="练习2.29"></a>练习2.29</h2><blockquote><p>假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说明原因。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = ic;     <span class="comment">// 合法, 常量赋值给普通变量</span></span><br><span class="line">p1 = p3;    <span class="comment">// 不合法, p3是一个指向int常量的常量指针常量，p1是指向int变量的指针。指向const的指针，不能给普通指针赋值。</span></span><br><span class="line">p1 = &amp;ic;   <span class="comment">// 不合法, 普通指针不能指向常量</span></span><br><span class="line">p3 = &amp;ic;   <span class="comment">// 不合法, p3是常量指针常量，是一个常量，无法改变常量的值。</span></span><br><span class="line">p2 = p1;    <span class="comment">// 不合法，p2是指针常量，无法改变常量的值。</span></span><br><span class="line">ic = *p3;   <span class="comment">// 不合法, 虽然对p3解引用是一个int常量，但ic本身就是一个int常量，无法改变常量的值。</span></span><br></pre></td></tr></table></figure><p>常量指针不能赋值给普通指针，因为它是指向常量（存储着常量的地址），如果允许赋值给普通指针，就意味着可以通过其他指针修改那个常量。不过可以赋值给另一个常量指针，因为它们都是指向常量，都是底层const。</p><p>而指针常量（const指针）是可以给普通指针赋值的。</p><p>引用的类型必须与其所引用的对象的类型一致，指针的类型必须与其所指对象的类型一致。但有例外情况（例如允许一个指向常量的指针指向一个非常量对象，当然，仅限于常量和非常量的区别，不是指int和double这种类型区别）。</p><p><strong>例外情况的解释：</strong><br>指向常量的指针或引用，并未规定所指的对象必须是一个常量。所谓的「指向常量」，只是规定不能通过指针或引用来改变对象的值（并未规定那个对象的值不能改变，这个值可以通过其他渠道改变）。通俗点讲：就是指针或引用“自以为是”，觉得自己指向了常量，所以会自觉地不去改变所指对象的值。</p><h2 id="练习2-30"><a href="#练习2-30" class="headerlink" title="练习2.30"></a>练习2.30</h2><blockquote><p>对于下面的这些语句，请说明对象被声明成了顶层const还是底层const？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> v2 = <span class="number">0</span>; <span class="type">int</span> v1 = v2;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;v1, &amp;r1 = v1;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;v2, *<span class="type">const</span> p3 = &amp;i, &amp;r2 = v2;</span><br></pre></td></tr></table></figure><p>v2是顶层const，v1是普通int；p1是普通指针，r1是对v1的引用；p2是底层const，p3既是顶层const也是底层const，r2是底层const。</p><ul><li>顶层const：表示任意对象是常量，对任意数据类型都适用。顶层const指本身就是常量，常量只能初始化，不能被赋值。</li><li>底层const：表示所指或所引用对象是常量，只与指针、引用等复合类型的基本类型部分有关。（用于声明引用的const都是底层const）。拷贝时，要求两个对象具有相同的底层const或者两个对象之间的数据类型可以转换（非常量可以转常量）。</li></ul><p>常量表达式是指值不会改变，在编译过程中就能得到计算结果的表达式。</p><p>constexpr类型声明的变量是由编译器验证变量的值是否是一个常量表达式。用constexpr声明的对象会把它置为顶层const，比如constexpr int *q &#x3D; nullptr就相当于int *const q &#x3D; nullptr。</p><h2 id="练习2-31"><a href="#练习2-31" class="headerlink" title="练习2.31"></a>练习2.31</h2><blockquote><p>假设已有上一个练习中所做的那些声明，则下面的哪些语句是合法的？请说明顶层const和底层const在每个例子中有何体现。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r1 = v2; <span class="comment">// 合法，顶层const在拷贝时不受影响</span></span><br><span class="line">p1 = p2; <span class="comment">// 不合法，p2是底层const，如果要拷贝必须要求p1也是底层const</span></span><br><span class="line">p2 = p1; <span class="comment">// 合法，int* 可以转换成const int*</span></span><br><span class="line">p1 = p3; <span class="comment">// 不合法，p3是一个底层const，p1不是</span></span><br><span class="line">p2 = p3; <span class="comment">// 合法，p2和p3都是底层const，拷贝时忽略掉顶层const</span></span><br></pre></td></tr></table></figure><h2 id="练习2-32"><a href="#练习2-32" class="headerlink" title="练习2.32"></a>练习2.32</h2><blockquote><p>下面的代码是否合法？如果非法，请设法将其修改正确。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int null = 0, *p = null;</span><br></pre></td></tr></table></figure><p>非法。（书本P49）把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。<br>修正方式1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int null = 0, *p = 0;</span><br></pre></td></tr></table></figure><p>修正方式2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> null = <span class="number">0</span>, *p = &amp;null;</span><br></pre></td></tr></table></figure><h2 id="练习2-33"><a href="#练习2-33" class="headerlink" title="练习2.33"></a>练习2.33</h2><blockquote><p>利用本节定义的变量，判断下列语句的运行结果。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">42</span>; <span class="comment">// a 是 int</span></span><br><span class="line">b=<span class="number">42</span>; <span class="comment">// b 是一个 int,(ci的顶层const在拷贝时被忽略掉了)</span></span><br><span class="line">c=<span class="number">42</span>; <span class="comment">// c 也是一个int</span></span><br><span class="line">d=<span class="number">42</span>; <span class="comment">// d 是一个 int *，所以语句非法</span></span><br><span class="line">e=<span class="number">42</span>; <span class="comment">// e 是一个 const int *，所以语句非法</span></span><br><span class="line">g=<span class="number">42</span>; <span class="comment">// g 是一个 const int 的引用，引用都是底层const，所以不能被赋值</span></span><br></pre></td></tr></table></figure><p><strong>类型别名（typedef和using）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages</span><br><span class="line"><span class="keyword">using</span> wages=<span class="type">double</span></span><br><span class="line"><span class="comment">// 注意指针和类型别名的应用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// cstr是指向char的指针常量。注意不要理解成 cosnt char *cstr = 0，这是错误的，const在这里是修饰整个类型，应该是顶层const。</span></span><br><span class="line"><span class="type">const</span> pstring *ps; <span class="comment">// ps是一个指针（实际就是指针的指针），它的对象是指向char的指针常量。</span></span><br></pre></td></tr></table></figure><p><strong>auto关键字（让编译器通过初始值推断类型）</strong></p><ul><li>auto定义的变量必须有初值。</li><li>auto一般会忽略掉顶层const，同时底层const会保留下来（若希望推断出的auto类型一个顶层const，明确指出const auto）。</li><li>引用的类型也可以设为auto，例如<code>auto &amp;a=i</code>，但注意顶层const依然是会被忽略，<code>auto &amp;b=42</code>是错误的，<code>const auto &amp;b=42</code>才是正确的。</li></ul><h2 id="练习2-34"><a href="#练习2-34" class="headerlink" title="练习2.34"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap2/2_34.cpp">练习2.34</a></h2><blockquote><p>基于上一个练习中的变量和语句编写一段程序，输出赋值前后变量的内容，你刚才的推断正确吗？如果不对，请反复研读本节的示例直到你明白错在何处为止。</p></blockquote><h2 id="练习2-35"><a href="#练习2-35" class="headerlink" title="练习2.35"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap2/2_35.cpp">练习2.35</a></h2><blockquote><p>判断下列定义推断出的类型是什么，然后编写程序进行验证。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="type">const</span> <span class="keyword">auto</span> &amp;k = i; <span class="keyword">auto</span> *p = &amp;i;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> j2 = i, &amp;k2 = i;</span><br></pre></td></tr></table></figure><p>j 是 int，k 是 const int的引用，p 是const int *，j2 是const int，k2 是 const int 的引用。</p><p>验证依靠hint即可（鼠标悬停在变量上），无需编译。</p><h2 id="练习2-36"><a href="#练习2-36" class="headerlink" title="练习2.36"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap2/2_36.cpp">练习2.36</a></h2><blockquote><p>关于下面的代码，请指出每一个变量的类型以及程序结束时它们各自的值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;</span><br><span class="line"><span class="keyword">decltype</span>((b)) d = a;</span><br><span class="line">++c;</span><br><span class="line">++d;</span><br></pre></td></tr></table></figure><p>a、b、c都是int类型，d是int &amp;类型，即引用，绑定到a。<br>程序结束时的值：a、b、c、d都为4。</p><p><strong>decltype关键字（让编译器分析表达式来得到类型，不计算表达式的值）</strong></p><ul><li>变量是否需要赋初值，看类型，如int可以不赋初值，引用必须要初值。</li><li>decltype使用的表达式是一个变量时，则返回该变量的类型（包括顶层const和引用）。</li><li>decltype使用的表达式不是一个变量时，则返回表达式结果的类型。</li></ul><p><strong>decltype返回引用类型的情况：</strong></p><ol><li>decltype(variable)时，variable本身是一个引用，返回引用类型。</li><li>双层括号decltype((variable))返回的结果永远是引用类型。</li><li>decltype(表达式为解引用操作，如*p)，返回引用类型（解引用指针操作，得到指针所指的对象，还能给这个对象赋值）。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r) a = i;   <span class="comment">// a是引用，绑定到变量i</span></span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;   <span class="comment">// b是int，b是一个未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) c = i; <span class="comment">// c是引用，绑定到变量i</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) d = i;  <span class="comment">// d是引用，绑定到变量i</span></span><br></pre></td></tr></table></figure><h2 id="练习2-37"><a href="#练习2-37" class="headerlink" title="练习2.37"></a>练习2.37</h2><blockquote><p>赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i&#x3D;x 的类型是 int&amp;。根据这一特点，请指出下面的代码中每一个变量的类型和值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;</span><br><span class="line"><span class="keyword">decltype</span>(a = b) d = a;</span><br></pre></td></tr></table></figure><p>a、b、c都是int类型，d是int &amp;类型，即引用，绑定到a。<br>a的值为3，b的值为4，c的值为3，d的值为3。</p><h2 id="练习2-38"><a href="#练习2-38" class="headerlink" title="练习2.38"></a>练习2.38</h2><blockquote><p>说明由decltype 指定类型和由auto指定类型有何区别。请举一个例子，decltype指定的类型与auto指定的类型一样；再举一个例子，decltype指定的类型与auto指定的类型不一样。</p></blockquote><ul><li>decltype依据类型决定是否需要赋初值，auto必须要有初值。</li><li>decltype处理顶层const方式与auto不同，decltype会将顶层const保留起来，auto会忽略掉顶层const。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="comment">// 相同 都是int</span></span><br><span class="line"><span class="keyword">auto</span> a = i;</span><br><span class="line"><span class="keyword">decltype</span>(i) b = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同 d 是一个 int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> c = r;</span><br><span class="line"><span class="keyword">decltype</span>(r) d = r;</span><br></pre></td></tr></table></figure><p>stackoverflow的<a href="http://stackoverflow.com/questions/21369113/what-is-the-difference-between-auto-and-decltypeauto-when-returning-from-a-fun">参考1</a>和<a href="http://stackoverflow.com/questions/12084040/decltype-vs-auto">参考2</a>有更多的讨论。</p><h2 id="练习2-39"><a href="#练习2-39" class="headerlink" title="练习2.39"></a>练习2.39</h2><blockquote><p>编译下面的程序观察其运行结果，注意，如果忘记写类定义体后面的分号会发生什么情况？记录下相关的信息，以后可能会有用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123; <span class="comment">/* 此处为空  */</span> &#125; <span class="comment">// 注意：没有分号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示应输入分号。</p><p><strong>关键字<code>class</code>和<code>struct</code>都可以用来定义数据类型（类）。</strong></p><h2 id="练习2-40"><a href="#练习2-40" class="headerlink" title="练习2.40"></a>练习2.40</h2><blockquote><p>根据自己的理解写出 Sales_data 类，最好与书中的例子有所区别。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sale_data</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    std::string bookName;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习2-41"><a href="#练习2-41" class="headerlink" title="练习2.41"></a>练习2.41</h2><blockquote><p>使用你自己的Sale_data类重写1.5.1节（第20页）、1.5.2节（第21页）和1.6节（第22页）的练习。眼下先把Sales_data类的定义和main函数放在一个文件里。</p></blockquote><h3 id="1-5-1节"><a href="#1-5-1节" class="headerlink" title="1.5.1节"></a>1.5.1节</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sale_data</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sale_data book;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    std::cin &gt;&gt; book.bookNo &gt;&gt; book.units_sold &gt;&gt; price;</span><br><span class="line">    book.revenue = book.units_sold * price;</span><br><span class="line">    std::cout &lt;&lt; book.bookNo &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; book.units_sold &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; book.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-2节"><a href="#1-5-2节" class="headerlink" title="1.5.2节"></a>1.5.2节</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sale_data</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sale_data book1, book2;</span><br><span class="line">    <span class="type">double</span> price1, price2;</span><br><span class="line">    std::cin &gt;&gt; book1.bookNo &gt;&gt; book1.units_sold &gt;&gt; price1;</span><br><span class="line">    std::cin &gt;&gt; book2.bookNo &gt;&gt; book2.units_sold &gt;&gt; price2;</span><br><span class="line">    book1.revenue = book1.units_sold * price1;</span><br><span class="line">    book2.revenue = book2.units_sold * price2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (book1.bookNo == book2.bookNo)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> totalCnt = book1.units_sold + book2.units_sold;</span><br><span class="line">        <span class="type">double</span> totalRevenue = book1.revenue + book2.revenue;</span><br><span class="line">        std::cout &lt;&lt; book1.bookNo &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; totalCnt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; totalRevenue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (totalCnt != <span class="number">0</span>)</span><br><span class="line">            std::cout &lt;&lt; totalRevenue / totalCnt &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;(no sales)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Data must refer to same ISBN&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// indicate failure</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6节"><a href="#1-6节" class="headerlink" title="1.6节"></a>1.6节</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sale_data</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sale_data total;</span><br><span class="line">    <span class="type">double</span> totalPrice;</span><br><span class="line">    <span class="keyword">if</span> (std::cin &gt;&gt; total.bookNo &gt;&gt; total.units_sold &gt;&gt; totalPrice)</span><br><span class="line">    &#123;</span><br><span class="line">        total.revenue = total.units_sold * totalPrice;</span><br><span class="line"></span><br><span class="line">        Sale_data trans;</span><br><span class="line">        <span class="type">double</span> transPrice;</span><br><span class="line">        <span class="keyword">while</span> (std::cin &gt;&gt; trans.bookNo &gt;&gt; trans.units_sold &gt;&gt; transPrice)</span><br><span class="line">        &#123;</span><br><span class="line">            trans.revenue = trans.units_sold * transPrice;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (total.bookNo == trans.bookNo)</span><br><span class="line">            &#123;</span><br><span class="line">                total.units_sold += trans.units_sold;</span><br><span class="line">                total.revenue += trans.revenue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; total.bookNo &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; total.units_sold &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; total.revenue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (total.units_sold != <span class="number">0</span>)</span><br><span class="line">                    std::cout &lt;&lt; total.revenue / total.units_sold &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;(no sales)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                total.bookNo = trans.bookNo;</span><br><span class="line">                total.units_sold = trans.units_sold;</span><br><span class="line">                total.revenue = trans.revenue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; total.bookNo &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; total.units_sold &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; total.revenue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (total.units_sold != <span class="number">0</span>)</span><br><span class="line">            std::cout &lt;&lt; total.revenue / total.units_sold &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;(no sales)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No data?!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// indicate failure</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习2-42"><a href="#练习2-42" class="headerlink" title="练习2.42"></a>练习2.42</h2><blockquote><p>根据你自己的理解重写一个Sales_data.h头文件，并以此为基础重做2.6.2节（第67页）的练习。</p></blockquote><ul><li><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap2/2_42_1.cpp">1.5.1节</a></li><li><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap2/2_42_2.cpp">1.5.2节</a></li><li><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap2/2_42_3.cpp">1.6节</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第二章：变量和基本类型&quot;&gt;&lt;a href=&quot;#第二章：变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;第二章：变量和基本类型&quot;&gt;&lt;/a&gt;第二章：变量和基本类型&lt;/h1&gt;&lt;h2 id=&quot;练习2-1&quot;&gt;&lt;a href=&quot;#练习2-1&quot; class=&quot;headerlink&quot; title=&quot;练习2.1&quot;&gt;&lt;/a&gt;练习2.1&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;类型 int、long、long long 和 short 的区别是什么？无符号类型和带符号类型的区别是什么？float 和 double的区别是什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C++ 规定 &lt;code&gt;short&lt;/code&gt; 和 &lt;code&gt;int&lt;/code&gt; 至少16位，&lt;code&gt;long&lt;/code&gt; 至少32位，&lt;code&gt;long long&lt;/code&gt; 至少64位。&lt;br&gt;带符号类型能够表示正数、负数和 0 ，而无符号类型只能够表示 0 和正整数。&lt;br&gt;通常，单精度&lt;code&gt;float&lt;/code&gt;用1个字表示（4个字节，32bit），双精度&lt;code&gt;double&lt;/code&gt;用2个字表示（8个字节，64bit）。&lt;/p&gt;
&lt;p&gt;用法（类型的选择）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果确认数据是非负的，那么就使用 &lt;code&gt;unsigned&lt;/code&gt; 无符号类型。&lt;/li&gt;
&lt;li&gt;一般使用 &lt;code&gt;int&lt;/code&gt; 做整数运算，&lt;code&gt;short&lt;/code&gt; 因为太小在实际中用的少，&lt;code&gt;long&lt;/code&gt; 通常和 &lt;code&gt;int&lt;/code&gt; 有着相同的大小。如果数据非常大，可以使用 &lt;code&gt;long long&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;算术表达式不用 &lt;code&gt;char&lt;/code&gt; 或 &lt;code&gt;bool&lt;/code&gt; ，这二者只建议用于存放字符或布尔值。因为&lt;code&gt;char&lt;/code&gt;在某些机器上是有符号的，在另一些机器上是无符号型的，则使用 &lt;code&gt;char&lt;/code&gt; 进行运算容易出问题。如果需要较小的整数，就明确指定 &lt;code&gt;signed char&lt;/code&gt; 或者 &lt;code&gt;unsigned char&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;执行浮点运算时用 &lt;code&gt;double&lt;/code&gt; ，因为 &lt;code&gt;float&lt;/code&gt; 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://isocpp.org/wiki/faq/newbie#choosing-int-size&quot;&gt;What are the criteria for choosing between short &amp;#x2F; int &amp;#x2F; long data types?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2386772/difference-between-float-and-double&quot;&gt;Difference between float and double&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;float有效位理解&quot;&gt;&lt;a href=&quot;#float有效位理解&quot; class=&quot;headerlink&quot; title=&quot;float有效位理解&quot;&gt;&lt;/a&gt;float有效位理解&lt;/h3&gt;&lt;p&gt;IEEE规定&lt;code&gt;float&lt;/code&gt;为32bit，尾数用23位存储，加上隐含的小数点前的1位1，2^(23+1) &amp;#x3D; 16777216。因为 10^7 &amp;lt; 16777216 &amp;lt; 10^8，所以说单精度浮点数的有效位数是7位（能保证7位有效数字，当然，并非说第8位一定是非有效数字，它也有可能是准确的）。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;12345678.76348&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;46857.9874&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;%f\n%f\n%.3f\n%.8f&amp;quot;&lt;/span&gt;, i, j, j, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;12345679.000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46857.988281&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46857.988&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46857.98828125&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;从以上数据可以看出，第八个数字之后就不精确了。另外，要注意，有效数字的位数与指定输出的小数位数（%.7f，保留7位有效数字）是两码事，如第三第四个输出，这个是程序指定的输出格式，和类型本身能够存储的精度不是一回事。&lt;/p&gt;
&lt;h2 id=&quot;练习2-2&quot;&gt;&lt;a href=&quot;#练习2-2&quot; class=&quot;headerlink&quot; title=&quot;练习2.2&quot;&gt;&lt;/a&gt;练习2.2&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算按揭贷款时，对于利率、本金和付款分别应选择何种数据类型？说明你的理由。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;double&lt;/code&gt; 或 &lt;code&gt;float&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;练习2-3&quot;&gt;&lt;a href=&quot;#练习2-3&quot; class=&quot;headerlink&quot; title=&quot;练习2.3&quot;&gt;&lt;/a&gt;练习2.3&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;读程序写结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;unsigned&lt;/span&gt; u = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, u2 = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;std::cout &amp;lt;&amp;lt; u2 - u &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;std::cout &amp;lt;&amp;lt; u - u2 &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, i2 = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;std::cout &amp;lt;&amp;lt; i2 - i &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;std::cout &amp;lt;&amp;lt; i - i2 &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;std::cout &amp;lt;&amp;lt; i - u &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;std::cout &amp;lt;&amp;lt; u - i &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4294967264 // -32=(-1)×2^32+4294967264&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;类型转换的总结&quot;&gt;&lt;a href=&quot;#类型转换的总结&quot; class=&quot;headerlink&quot; title=&quot;类型转换的总结&quot;&gt;&lt;/a&gt;类型转换的总结&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;非布尔类型转换布尔类型时，0转换成false，非0则true（包括负数）。&lt;/li&gt;
&lt;li&gt;布尔值转换非布尔类型时，false转换为0，true则1。&lt;/li&gt;
&lt;li&gt;浮点数转换整数时，仅保留小数点之前的部分（即整数部分，小数部分直接截断），这是精度损失；当浮点数表示的值大过整型值，会发生溢出。&lt;/li&gt;
&lt;li&gt;整数转浮点数时，小数部分记为0。不会发生溢出，但当整数值数据较大时，转换浮点数可能会发生精度丢失。例如，&lt;code&gt;int&lt;/code&gt; 有31bit用来拓展精度，&lt;code&gt;float&lt;/code&gt; 只有24bit，即当int值大于2^24或者小于-2^24时，转换&lt;code&gt;float&lt;/code&gt;就会精度丢失。&lt;/li&gt;
&lt;li&gt;给无符号类型赋值超过其表示范围时，实际值是初始值对无符号类型表示数值总数取模后的余数。8bit的&lt;code&gt;unsigned char&lt;/code&gt;表示0-255，赋值超出范围时，实际值为该值对256取模后的余数。因此将-1赋给8bit的&lt;code&gt;unsigned char&lt;/code&gt;时，结果值为255。&lt;/li&gt;
&lt;li&gt;赋给带符号类型一个超出范围的值时，结果是未定义的。此时，程序可能工作、可能崩溃、也可能生成垃圾数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;无符号类型和有符号类型计算，结果为负数时，结果值的计算方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个正整数p，任意一个整数n，一定存在等式n&amp;#x3D;kp+r&lt;/p&gt;
&lt;p&gt;其中k、r是整数，且0&amp;lt;&amp;#x3D;r&amp;lt;p，称k为n除以p的商，r为n除以p的余数。&lt;/p&gt;
&lt;p&gt;定义取模运算：a % p（或a mod p），表示a除以p的余数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际运用场景&lt;/strong&gt;：将-1赋给8bit的&lt;code&gt;unsigned char&lt;/code&gt;时，结果值为255。&lt;br&gt;计算过程：-1&amp;#x3D;(-1)×256+255&lt;/p&gt;
&lt;p&gt;二进制表示的本质：用补码表示，先看原码（符号位为1，数值位只有一个1）对原码取反加1（符号位不变），转换成补码后，所有位都是1。&lt;/p&gt;
&lt;h3 id=&quot;类型转换的使用场景总结&quot;&gt;&lt;a href=&quot;#类型转换的使用场景总结&quot; class=&quot;headerlink&quot; title=&quot;类型转换的使用场景总结&quot;&gt;&lt;/a&gt;类型转换的使用场景总结&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不要混用带符号类型和无符号类型：表达式中含有这两种类型时，带符号数会自动转换成无符号数（此时，一个负数转换成无符号数后，真值将很大）。&lt;/li&gt;
&lt;li&gt;循环中的判断条件慎用无符号数：无符号数表示范围为正整数，不会小于0，尤其是当循环的临界条件是0时。如以下代码，就是死循环，当u&amp;#x3D;0时，循环条件依然满足，继续执行，--u就是-1，但无符号数只能表示整数，-1被自动地转换成一个合法的无符号数，即正整数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;unsigned&lt;/span&gt; u = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; u &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; --u)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; u &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;解决方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用有符号类型&lt;/li&gt;
&lt;li&gt;用while语句，代码如下。&lt;/li&gt;
&lt;li&gt;类似while语句，将for语句的--u置于cout语句中。&lt;/li&gt;
&lt;li&gt;2和3本质上就是保证u不会变为-1。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;unsigned&lt;/span&gt; u = &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (u &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    --u;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; u &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;练习2-4&quot;&gt;&lt;a href=&quot;#练习2-4&quot; class=&quot;headerlink&quot; title=&quot;练习2.4&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap2/2_4.cpp&quot;&gt;练习2.4&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;编写程序检查你的估计是否正确，如果不正确，请仔细研读本节直到弄明白问题所在。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="code-training" scheme="https://mister-kin.github.io/categories/code-training/"/>
    
    <category term="cpp-primer-v5" scheme="https://mister-kin.github.io/categories/code-training/cpp-primer-v5/"/>
    
    
    <category term="C++" scheme="https://mister-kin.github.io/tags/C/"/>
    
    <category term="C++ Primer" scheme="https://mister-kin.github.io/tags/C-Primer/"/>
    
    <category term="习题答案" scheme="https://mister-kin.github.io/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
    <category term="第二章" scheme="https://mister-kin.github.io/tags/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 第五版：第一章「开始」习题答案</title>
    <link href="https://mister-kin.github.io/code-training/cpp-primer-v5/chap1/"/>
    <id>https://mister-kin.github.io/code-training/cpp-primer-v5/chap1/</id>
    <published>2022-01-18T06:42:13.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：开始"><a href="#第一章：开始" class="headerlink" title="第一章：开始"></a>第一章：开始</h1><h2 id="练习1-1"><a href="#练习1-1" class="headerlink" title="练习1.1"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_1.cpp">练习1.1</a></h2><blockquote><p>查阅你使用的编译器文档，确定它所使用的文件命名约定。编译并运行第2页的main程序。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习1-2"><a href="#练习1-2" class="headerlink" title="练习1.2"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_2.cpp">练习1.2</a></h2><blockquote><p>改写程序，让它返回-1。返回值-1通常被当作程序错误的标识。重新编译并运行你的程序，观察你的系统如何处理main返回的错误标识。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后在命令行运行程序，之后通过<code>echo</code>查看。</p><p>cmd: <code>echo %ERRORLEVEL%</code>，输出-1</p><p>bash: <code>echo $?</code>，输出127</p><h2 id="练习1-3"><a href="#练习1-3" class="headerlink" title="练习1.3"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_3.cpp">练习1.3</a></h2><blockquote><p>编写程序，在标准输出上打印 Hello, World。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习1-4"><a href="#练习1-4" class="headerlink" title="练习1.4"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_4.cpp">练习1.4</a></h2><blockquote><p>我们的程序使用加法运算符+来将两个数相加。编写程序使用乘法运算符*，来打印两个数的积。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The product of &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2</span><br><span class="line">              &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 * v2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习1-5"><a href="#练习1-5" class="headerlink" title="练习1.5"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_5.cpp">练习1.5</a></h2><blockquote><p>我们将所有输出操作放在一条很长的语句中。重写程序，将每个运算对象的打印操作放在一条独立的语句中。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The product of &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; v1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; and &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; v2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; is &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; v1 * v2;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="练习1-6"><a href="#练习1-6" class="headerlink" title="练习1.6"></a>练习1.6</h2><blockquote><p>解释下面程序片段是否合法。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1;</span><br><span class="line">          &lt;&lt; &quot; and &quot; &lt;&lt; v2;</span><br><span class="line">          &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><blockquote><p>如果程序是合法的，它的输出是什么？如果程序不合法，原因何在？应该如何修正？</p></blockquote><p>不合法。<br><strong>分号「;」之间会被编译器处理成一条语句，所有第二、第三行没有cout对象（&lt;&lt;运算符要求左侧的运算对象必须是一个ostream对象），所以不合法。</strong></p><p>修正方式1：二三行添加cout对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>修正方式2：删除一二行多余的分号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1</span><br><span class="line">          &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2</span><br><span class="line">          &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h2 id="练习1-7"><a href="#练习1-7" class="headerlink" title="练习1.7"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_7.cpp">练习1.7</a></h2><blockquote><p>编译一个包含不正确的嵌套注释的程序，观察编译器返回的错误信息。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* /* 内层注释 */</span> 外层注释 */</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习1-8"><a href="#练习1-8" class="headerlink" title="练习1.8"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_8.cpp">练习1.8</a></h2><blockquote><p>指出下列哪些输出语句是合法的(如果有的话)：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;/*&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;*/&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="comment">/* &quot;*/</span><span class="string">&quot; */;</span></span><br><span class="line"><span class="string">std::cout &lt;&lt; /* &quot;</span>*/<span class="string">&quot; /* &quot;</span><span class="comment">/*&quot; */</span>;</span><br></pre></td></tr></table></figure><blockquote><p>预测编译这些语句会产生什么样的结果，实际编译这些语句来验证你的答案（编写一个小程序，每次将上述一条语句作为其主体），改正每个编译错误。</p></blockquote><p>第三行不合法，编译出错，修正：增加一个双引号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="comment">/* &quot;*/</span><span class="string">&quot; */&quot;</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**/ */ /*</span><br></pre></td></tr></table></figure><h2 id="练习1-9"><a href="#练习1-9" class="headerlink" title="练习1.9"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_9.cpp">练习1.9</a></h2><blockquote><p>编写程序，使用while循环将50到100的整数相加。</p></blockquote><h2 id="练习1-10"><a href="#练习1-10" class="headerlink" title="练习1.10"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_10.cpp">练习1.10</a></h2><blockquote><p>除了++运算符将运算对象的值增加1之外，还有一个递减运算符（--）实现将值减少1。编写程序，使用递减运算符在循环中按递减顺序打印出10到0之间的整数。</p></blockquote><h2 id="练习1-11"><a href="#练习1-11" class="headerlink" title="练习1.11"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_11.cpp">练习1.11</a></h2><blockquote><p>编写程序，提示用户输入两个整数，打印出这两个整数所指定的范围内的所有整数。</p></blockquote><h2 id="练习1-12"><a href="#练习1-12" class="headerlink" title="练习1.12"></a>练习1.12</h2><blockquote><p>下面的for循环完成了什么功能？sum的终值是多少？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">for (int i = -100; i &lt;= 100; ++i)</span><br><span class="line">    sum += i;</span><br></pre></td></tr></table></figure><p>从-100加到100，sum的终值为0。</p><h2 id="练习1-13"><a href="#练习1-13" class="headerlink" title="练习1.13"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_13.cpp">练习1.13</a></h2><blockquote><p>使用for循环重做1.4.1节中的所有练习（第11页）。</p></blockquote><h2 id="练习1-14"><a href="#练习1-14" class="headerlink" title="练习1.14"></a>练习1.14</h2><blockquote><p>对比for循环和while循环，两种形式的优缺点各是什么？</p></blockquote><p>对比 for 循环和 while 循环的优缺点：for 循环的变量可以在语句中定义，而 while 语句中直接就是判断循环的条件，无法在语句中定义变量。如此看来，for 语句中定义的变量所占用的内存可以在循环结束后回收，减少了内存的占用。</p><p><a href="http://stackoverflow.com/questions/2950931/for-vs-while-in-c-programming">在Stack Overflow上面有与这个相似的问题</a></p><h2 id="练习1-15"><a href="#练习1-15" class="headerlink" title="练习1.15"></a>练习1.15</h2><blockquote><p>编写程序，包含第14页“再探编译”中讨论的常见错误。熟悉编译器生成的错误信息。</p></blockquote><p>编译器可检查的错误：</p><ol><li>语法错误（syntax error）：比如main参数列表漏掉括号；语句结束之处用冒号而非分号；字符串字面值常量两侧漏掉引号。</li><li>类型错误（type error）：比如向一个期望参数为int的函数传递一个字符串字面值常量。</li><li>声明错误（declaration error）：比如对来自标准库的名字忘记使用std::以及标识符名字拼写错误。</li></ol><h2 id="练习1-16"><a href="#练习1-16" class="headerlink" title="练习1.16"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_16.cpp">练习1.16</a></h2><blockquote><p>编写程序，从cin读取一组数，输出其和。</p></blockquote><p><code>&lt;&lt;</code>输入运算符返回其左侧运算对象，而istream对象遇到文件结束符（end-of-file）或无效输入（类型不同）时就会变得无效，即条件变为假。</p><p>从键盘向程序输入数据时，如何输入文件结束符：</p><ul><li>Windows：ctrl+z</li><li>UNIX（包括Mac OS X）：ctrl+d</li></ul><h2 id="练习1-17"><a href="#练习1-17" class="headerlink" title="练习1.17"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_18.cpp">练习1.17</a></h2><blockquote><p>如果输入的所有值都是相等的，本节的程序会输出什么？如果没有重复值，输出又会是怎样的？</p></blockquote><ol><li>输入全部相等的值：程序只会打印出一个数字及它出现的次数。</li><li>输入没有重复的值：程序会打印每个数值，次数都为1。</li></ol><h2 id="练习1-18"><a href="#练习1-18" class="headerlink" title="练习1.18"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_18.cpp">练习1.18</a></h2><blockquote><p>编译并运行本节的程序，给它输入全都相等的值。再次运行程序，输入没有重复的值。</p></blockquote><h2 id="练习1-19"><a href="#练习1-19" class="headerlink" title="练习1.19"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_11.cpp">练习1.19</a></h2><blockquote><p>修改你为1.4.1节练习1.11（第11页）所编写的程序（打印一个范围内的数），使其能处理用户输入的第一个数比第二个数小的情况。</p></blockquote><h2 id="练习1-20"><a href="#练习1-20" class="headerlink" title="练习1.20"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_20.cpp">练习1.20</a></h2><blockquote><p>在网站<a href="http://www.informit.com/title/032174113">http://www.informit.com/title/032174113</a> 上，第1章的代码目录包含了头文件Sales_item.h。将它拷贝到你自己的工作目录中。用它编写一个程序，读取一组书籍销售记录，将每条记录打印到标准输出上。</p></blockquote><h2 id="练习1-21"><a href="#练习1-21" class="headerlink" title="练习1.21"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_21.cpp">练习1.21</a></h2><blockquote><p>编写程序，读取两个ISBN相同的Sales_item对象，输出他们的和。</p></blockquote><h2 id="练习1-22"><a href="#练习1-22" class="headerlink" title="练习1.22"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_22.cpp">练习1.22</a></h2><blockquote><p>编写程序，读取多个具有相同ISBN的销售记录，输出所有记录的和。</p></blockquote><h2 id="练习1-23"><a href="#练习1-23" class="headerlink" title="练习1.23"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_23.cpp">练习1.23</a></h2><blockquote><p>编写程序，读取多条销售记录，并统计每个ISBN（每本书）有几条销售记录。</p></blockquote><h2 id="练习1-24"><a href="#练习1-24" class="headerlink" title="练习1.24"></a>练习1.24</h2><blockquote><p>输入表示多个ISBN的多条销售记录来测试上一个程序，每个ISBN的记录应该聚在一起。</p></blockquote><h2 id="练习1-25"><a href="#练习1-25" class="headerlink" title="练习1.25"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_25.cpp">练习1.25</a></h2><blockquote><p>借助网站上的Sales_item.h头文件，编译并运行本节给出的书店程序。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一章：开始&quot;&gt;&lt;a href=&quot;#第一章：开始&quot; class=&quot;headerlink&quot; title=&quot;第一章：开始&quot;&gt;&lt;/a&gt;第一章：开始&lt;/h1&gt;&lt;h2 id=&quot;练习1-1&quot;&gt;&lt;a href=&quot;#练习1-1&quot; class=&quot;headerlink&quot; title=&quot;练习1.1&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_1.cpp&quot;&gt;练习1.1&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;查阅你使用的编译器文档，确定它所使用的文件命名约定。编译并运行第2页的main程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;练习1-2&quot;&gt;&lt;a href=&quot;#练习1-2&quot; class=&quot;headerlink&quot; title=&quot;练习1.2&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_2.cpp&quot;&gt;练习1.2&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;改写程序，让它返回-1。返回值-1通常被当作程序错误的标识。重新编译并运行你的程序，观察你的系统如何处理main返回的错误标识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;编译后在命令行运行程序，之后通过&lt;code&gt;echo&lt;/code&gt;查看。&lt;/p&gt;
&lt;p&gt;cmd: &lt;code&gt;echo %ERRORLEVEL%&lt;/code&gt;，输出-1&lt;/p&gt;
&lt;p&gt;bash: &lt;code&gt;echo $?&lt;/code&gt;，输出127&lt;/p&gt;
&lt;h2 id=&quot;练习1-3&quot;&gt;&lt;a href=&quot;#练习1-3&quot; class=&quot;headerlink&quot; title=&quot;练习1.3&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_3.cpp&quot;&gt;练习1.3&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;编写程序，在标准输出上打印 Hello, World。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, World&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;练习1-4&quot;&gt;&lt;a href=&quot;#练习1-4&quot; class=&quot;headerlink&quot; title=&quot;练习1.4&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_4.cpp&quot;&gt;练习1.4&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们的程序使用加法运算符+来将两个数相加。编写程序使用乘法运算符*，来打印两个数的积。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Enter two numbers:&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; v1 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, v2 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;The product of &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; v1 &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; and &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; v2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; is &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; v1 * v2 &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;练习1-5&quot;&gt;&lt;a href=&quot;#练习1-5&quot; class=&quot;headerlink&quot; title=&quot;练习1.5&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap1/1_5.cpp&quot;&gt;练习1.5&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们将所有输出操作放在一条很长的语句中。重写程序，将每个运算对象的打印操作放在一条独立的语句中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Enter two numbers:&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; v1 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, v2 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;The product of &amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; v1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; and &amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; v2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; is &amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; v1 * v2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="code-training" scheme="https://mister-kin.github.io/categories/code-training/"/>
    
    <category term="cpp-primer-v5" scheme="https://mister-kin.github.io/categories/code-training/cpp-primer-v5/"/>
    
    
    <category term="C++" scheme="https://mister-kin.github.io/tags/C/"/>
    
    <category term="C++ Primer" scheme="https://mister-kin.github.io/tags/C-Primer/"/>
    
    <category term="第一章" scheme="https://mister-kin.github.io/tags/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    
    <category term="习题答案" scheme="https://mister-kin.github.io/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>翻译计划</title>
    <link href="https://mister-kin.github.io/translations/translation-plan/"/>
    <id>https://mister-kin.github.io/translations/translation-plan/</id>
    <published>2022-01-16T08:21:06.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计划重启缘由">1 <a href="#计划重启缘由" class="headerlink" title="计划重启缘由"></a>计划重启缘由</h1><p>2018年末之际，我发布了一篇博文<a href="/translations/translation-roadmap/">「翻译规划（作废）」</a>，计划着翻译一些视频教程和文档等，但因诸多原因，一直未能有效按计划进行，后来也就不了了之，将此篇博文就此作废。现在看来，这个计划完成的进度可能都不及5%，真的是个巨难填补的巨坑啊，哈哈哈……</p><p>翻译本身就是无偿行为，毕竟原作品不是自己创作的，平台投稿时又无法投原创自制。一想到这个，就没啥了驱动力，毕竟没法总是为爱发电。</p><p>由于编写<a href="https://github.com/Mister-Kin/BatchTools">批处理工具</a>时需要进行测试，因此又接触到了视频压制和字幕处理。在测试的过程中，又有想法要重新开启翻译计划。</p><p>不过本次的计划重启，与上次那样庞大的目标的不同，这次的翻译目标仅限于自己的看过并感兴趣的视频。</p><h1 id="翻译计划表">2 <a href="#翻译计划表" class="headerlink" title="翻译计划表"></a>翻译计划表</h1><p><strong>注：点击列表中的英文视频名即可访问相应的视频链接。</strong></p><h2 id="Blender开放动画电影">2.1 <a href="#Blender开放动画电影" class="headerlink" title="Blender开放动画电影"></a>Blender开放动画电影</h2><table><thead><tr><th align="center">视频名</th><th align="center">中译名</th><th align="center">完成进度</th><th align="center">字幕下载</th></tr></thead><tbody><tr><td align="center">[Sprite Fright][]</td><td align="center">惊悚小精灵</td><td align="center">已翻译</td><td align="center">[点击跳转][subtitles]</td></tr><tr><td align="center">[The Daily Dweebs][]</td><td align="center">每日蠢事</td><td align="center">已翻译</td><td align="center">[点击跳转][subtitles]</td></tr></tbody></table><h2 id="Blender-fundamental-教程">2.2 <a href="#Blender-fundamental-教程" class="headerlink" title="Blender fundamental 教程"></a>Blender fundamental 教程</h2><table><thead><tr><th align="center">视频名</th><th align="center">中译名</th><th align="center">完成进度</th><th align="center">字幕下载</th></tr></thead></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;计划重启缘由&quot;&gt;1 &lt;a href=&quot;#计划重启缘由&quot; class=&quot;headerlink&quot; title=&quot;计划重启缘由&quot;&gt;&lt;/a&gt;计划重启缘由&lt;/h1&gt;&lt;p&gt;2018年末之际，我发布了一篇博文&lt;a</summary>
        
      
    
    
    
    <category term="translations" scheme="https://mister-kin.github.io/categories/translations/"/>
    
    
    <category term="翻译" scheme="https://mister-kin.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="计划" scheme="https://mister-kin.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
    <category term="字幕" scheme="https://mister-kin.github.io/tags/%E5%AD%97%E5%B9%95/"/>
    
  </entry>
  
  <entry>
    <title>看翻译学英语 —— blender开放动画电影《Sprite Fright》</title>
    <link href="https://mister-kin.github.io/translations/blender-animation/sprite-fright/"/>
    <id>https://mister-kin.github.io/translations/blender-animation/sprite-fright/</id>
    <published>2022-01-15T15:34:22.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻译的感想">1 <a href="#翻译的感想" class="headerlink" title="翻译的感想"></a>翻译的感想</h1><p>抽空翻译了blender的开放动画电影《Sprite Fright》，该动画电影是一部恐怖喜剧，台词有部分俚语，总体的翻译难度比一般的教学类视频要高一点。</p><h1 id="观看动画电影">2 <a href="#观看动画电影" class="headerlink" title="观看动画电影"></a>观看动画电影</h1><style>.bbplayer{width: 100%; max-width: auto; margin: auto}</style><div class="bbplayer"><iframe class="bbplayer" id="mmedia-GhdMckbpvQtmMUPK" src="https://player.bilibili.com/player.html?bvid=1eS4y1j7ay&page=1&high_quality=1&danmaku=false" allowfullscreen="allowfullscreen" scrolling="no" border="0" frameborder="0" framespacing="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups"></iframe></div><script> document.getElementById("mmedia-GhdMckbpvQtmMUPK").style.height=document.getElementById("mmedia-GhdMckbpvQtmMUPK").scrollWidth*0.76+"px";    window.onresize = function(){      document.getElementById("mmedia-GhdMckbpvQtmMUPK").style.height=document.getElementById("mmedia-GhdMckbpvQtmMUPK").scrollWidth*0.76+"px";    }; </script><h1 id="下载字幕">3 <a href="#下载字幕" class="headerlink" title="下载字幕"></a>下载字幕</h1><p>字幕采用aegisub软件制作，已同步分享至Github仓库「<a href="https://github.com/Mister-Kin/OpenDocs/tree/master/translations/subtitles/blender_animation">OpenDocs</a>」，有需要的朋友可下载学习或者观看。</p><h1 id="本期翻译的英语词汇总结">4 <a href="#本期翻译的英语词汇总结" class="headerlink" title="本期翻译的英语词汇总结"></a>本期翻译的英语词汇总结</h1><ul><li>tree hugger 抱树者（意指给环保主义者贴上过于情绪化和不理性的标签）</li><li>sugar buns&#x2F;sweet cakes&#x2F;love muffin 这三个都是用作爱称，意思同sweetheart</li><li>get wasted 喝醉，形容大醉</li><li>way ahead of you 形容比别人更早地完成或者解决某事</li><li>dilly-dally v. 犹豫，磨蹭</li><li>fungis n. 真菌（这个用法有问题，fungi本身就是复数，加s应该只是为了配合台词fun guys）</li><li>dorkwad n. 傻瓜，呆子（俚语，意思同dork）</li><li>be supposed to do&#x2F;be sth. 应当……</li><li>piss break 指上厕所的休息过程（例如在听一个无聊的讲座时，可以说piss break，然后离场去休息）</li><li>make yourself useful 让对方别闲着，干点事情（差不多就是get off your ass and do something）</li><li>innit 表示强调，用于陈述句后代替附加疑问句（tag question）<ul><li>She&#39;s a real weenie that one, innit? 她是一个真正的窝囊废，不是吗？（innit相当于isn’t she）</li></ul></li><li>gnome n. 守护精灵（童话故事中的地下宝藏守护神，外形像戴着尖顶帽的小人）</li><li>shag v. 和……性交（该词我根据上下文来翻译了）<ul><li>It&#39;s like a gnome shagged a mushroom. 这就像一个守护精灵头顶一只蘑菇</li></ul></li><li>peppermint n. （常用于糖果的）薄荷</li><li>sprite n. 小精灵（该词本身只是名词，但动画中原创了动词用法，因此我根据上下文来翻译动词意思了）<ul><li>We sprite balance to the forest. 我们让森林保持平衡</li><li>Sprite them! 净化他们</li></ul></li><li>son of a spriteberry 狗娘养的（意思同son of a bitch，不过动画中小精灵用的是spriteberry）</li><li>treat sth. as sth. 把……视为……，把……看作……</li></ul><h1 id="参考文献">5 <a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] BRIDGERS B. What it Means to be Called a Tree Hugger[EB&#x2F;OL]. <a href="https://www.newamerica.org/millennials/dm/what-it-means-be-called-tree-hugger/">https://www.newamerica.org/millennials/dm/what-it-means-be-called-tree-hugger/</a>.<br>[2] What does Way ahead of you. mean?[EB&#x2F;OL]. <a href="https://hinative.com/en-US/questions/166902">https://hinative.com/en-US/questions/166902</a>.<br>[3] What is the difference between get lit and get wasted and get hammered?[EB&#x2F;OL]. <a href="https://hinative.com/en-US/questions/17881208">https://hinative.com/en-US/questions/17881208</a>.<br>[4] What does Make yourself useful. mean?[EB&#x2F;OL]. <a href="https://hinative.com/en-US/questions/15910440">https://hinative.com/en-US/questions/15910440</a>.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;翻译的感想&quot;&gt;1 &lt;a href=&quot;#翻译的感想&quot; class=&quot;headerlink&quot; title=&quot;翻译的感想&quot;&gt;&lt;/a&gt;翻译的感想&lt;/h1&gt;&lt;p&gt;抽空翻译了blender的开放动画电影《Sprite</summary>
        
      
    
    
    
    <category term="translations" scheme="https://mister-kin.github.io/categories/translations/"/>
    
    <category term="blender-animation" scheme="https://mister-kin.github.io/categories/translations/blender-animation/"/>
    
    
    <category term="blender" scheme="https://mister-kin.github.io/tags/blender/"/>
    
    <category term="翻译" scheme="https://mister-kin.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="字幕" scheme="https://mister-kin.github.io/tags/%E5%AD%97%E5%B9%95/"/>
    
    <category term="英语" scheme="https://mister-kin.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
    <category term="开放动画" scheme="https://mister-kin.github.io/tags/%E5%BC%80%E6%94%BE%E5%8A%A8%E7%94%BB/"/>
    
    <category term="动画" scheme="https://mister-kin.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
    <category term="动画电影" scheme="https://mister-kin.github.io/tags/%E5%8A%A8%E7%94%BB%E7%94%B5%E5%BD%B1/"/>
    
    <category term="电影" scheme="https://mister-kin.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>给联想z500安装deepin linux（深度系统）</title>
    <link href="https://mister-kin.github.io/os/install-deepin-on-lenovo-z500/"/>
    <id>https://mister-kin.github.io/os/install-deepin-on-lenovo-z500/</id>
    <published>2022-01-14T13:28:29.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因">1 <a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>前几日，老父亲向我反应：手提电脑在使用过程中，偶尔会出现不响应的状态。我一想，多半是机子的老配置跟不上win10了，于是回应说抽空我给换装另一个系统。</p><p>这个手提电脑是联想在2012年推出的erazer z500系列机型，大概是2013年或是2014年买的吧。用到现在，这个老本子大修过好几次，换过屏幕，换过电源适配器，换过电池……总之是遇到过不少大大小小的毛病。</p><p>印象中，这本子最初的系统是win7，后来换过win8和win8.1，现在用的是win10。不过整体配置确实是不太适合新版win10了，毕竟CPU是3代的i5，频率也不高，系统空载时占用的内存也不少。</p><h1 id="解决方案">2 <a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>既然是系统不太合适，那就更换系统呗！我凭借自身的知识储备，大致想出了如下的系统更换方案：</p><ol><li>老版的win10</li><li>精简版win10</li><li>win8.1</li><li>win7</li><li>linux</li></ol><p>方案1的老版win10换汤不换药，感觉很大机率还是会出现卡顿的现象，不作考虑。</p><p>方案2，网上论坛流传的精简版镜像基本都会添加私货（各种乱七八糟的预装软件，同时可能也会有后门软件，不安全），自己动手制作精简版镜像倒也行，不过现在都没啥精力折腾这些东西了，这个方案也pass。</p><p>方案3，网卡驱动会有问题，以前这本子用win8.1的时候就遇到过无法连接某些wifi信号，pass。</p><p>方案4的win7系统太老了，直接pass。</p><p>最后也就只剩方案5——linux系统。linux确实很适合老配置的机子，系统本身就不会消耗过多的硬件资源。不过，linux的软件生态和驱动远不如windows平台，并且发行版众多。现在暂且不考虑软件生态和驱动问题，如何选择linux的发行版呢？</p><span id="more"></span><p>arch？不行！没啥精力折腾了。</p><p>ubuntu？嗯，倒还行，不过有点臃肿，而且不太适合国内的使用习惯。</p><p>这个时候，deepin出现在我的脑海中。deepin和ubuntu都是基于debian，而且deepin的桌面gui比较符合国内使用习惯，虽然对硬件要求比ubuntu高，但我认为z500的配置应该足够了。</p><p>至于linux的软件生态问题，毕竟现在这老本子是家里长辈在使用，老父亲平时也就只用酷狗听一下歌。酷狗好像没有linux客户端，不过没关系，大不了用安卓版或是wine（应该能解决吧？(＞﹏＜)）。</p><p>至于驱动，应该是双显卡驱动和网卡驱动可能会有点问题。</p><p>多思无益，先安装再说吧，走一步，看一步！</p><h1 id="deepin的安装步骤">3 <a href="#deepin的安装步骤" class="headerlink" title="deepin的安装步骤"></a>deepin的安装步骤</h1><h2 id="备份数据">3.1 <a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h2><p>安装系统前，第一步当然是备份数据。数据无价，可别因为懒而导致丢失宝贵的数据。</p><h2 id="制作启动盘">3.2 <a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><ol><li>下载系统镜像和启动盘制作工具：<a href="https://www.deepin.org/zh/download/">点击跳转下载地址</a>。</li><li>准备一个大于2G的U盘，备份U盘数据。</li><li>利用启动盘制作工具，制作深度系统启动盘（格式化U盘制作）。</li></ol><h2 id="安装deepin">3.3 <a href="#安装deepin" class="headerlink" title="安装deepin"></a>安装deepin</h2><ol><li>插入U盘，开机，摁Fn+F12进入快速启动项（本机的BIOS开启了Fn功能键），选择U盘启动项。</li><li>按照提示进行安装，这里不一一列出。</li><li>安装时，勾选集成的闭源显卡驱动。</li><li>我是手动分区的（分区方案如下），不懂的朋友可以选择全盘安装。</li><li>完成安装，重启系统，拔出U盘。</li></ol><p><strong>分区方案（120G的固态硬盘，列表顺序就是实际的分区顺序）</strong></p><ul><li><code>/boot/efi</code> 300M</li><li><code>/boot</code> 1G</li><li><code>swap</code> 12G（8G×1.5）</li><li><code>/</code> 剩余的空间</li><li><code>/home</code> 40G</li></ul><h2 id="驱动安装">3.4 <a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h2><p><strong>安装显卡驱动</strong></p><ol><li>打开商店，搜索并安装「显卡驱动管理器」。</li><li>选择prime显卡方案。</li><li>按照提示重启系统。</li></ol><p><strong>安装蓝牙管理器</strong></p><ol><li>打开终端</li><li>输入命令：<code>sudo apt-get install blueman</code></li></ol><p>安装完显卡驱动和蓝牙管理器之后，驱动这方面基本没啥问题。</p><h2 id="几个值得注意的地方">3.5 <a href="#几个值得注意的地方" class="headerlink" title="几个值得注意的地方"></a>几个值得注意的地方</h2><ul><li><strong>不需要关闭BIOS的安全启动</strong>：deepin v20.2.2及之后的版本都能较好的支持安全启动，因此安装deepin不需要专门关闭BIOS的安全启动。</li><li><strong>未安装蓝牙管理器之前，不要使用无线鼠标</strong>：deepin默认状态下没有蓝牙管理器，因此，使用无线鼠标会出现一些莫名其妙的bug（例如，若不关闭安全启动，安装过程中则无法点击；即使关闭安全启动后安装系统时，点击操作也会导致UI变成外文语言；安装系统后初次启动时，无线鼠标使用正常，但重启后就会出现异常卡顿现象，甚至无法点击）。这些bug当时困扰了我许久，后来我想起无线鼠标的原理，才准确地定位出问题所在。只有安装蓝牙管理器之后，才能正常使用无线鼠标。</li></ul><h1 id="常规软件的安装和使用">4 <a href="#常规软件的安装和使用" class="headerlink" title="常规软件的安装和使用"></a>常规软件的安装和使用</h1><p>目前深度商店的软件应用数量已经比以前增加了很多，在商店中搜索并安装自己想用的软件即可。</p><p>让我最为惊喜的是，商店竟然有酷狗，而且不是网页版或者安卓版。这点不错，也省去了我手动折腾wine的麻烦。</p><p>至此，z500算是获得了新生。</p><h1 id="参考文献">5 <a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] 如何安装[EB&#x2F;OL]. <a href="https://www.deepin.org/zh/installation/">https://www.deepin.org/zh/installation/</a>.<br>[2] 蓝牙[EB&#x2F;OL]. <a href="https://wiki.deepin.org/wiki/%E8%93%9D%E7%89%99">https://wiki.deepin.org/wiki/%E8%93%9D%E7%89%99</a>.<br>[3] Recommended Partitioning Scheme[EB&#x2F;OL]. <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-x86">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-x86</a>.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;1 &lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;前几日，老父亲向我反应：手提电脑在使用过程中，偶尔会出现不响应的状态。我一想，多半是机子的老配置跟不上win10了，于是回应说抽空我给换装另一个系统。&lt;/p&gt;
&lt;p&gt;这个手提电脑是联想在2012年推出的erazer z500系列机型，大概是2013年或是2014年买的吧。用到现在，这个老本子大修过好几次，换过屏幕，换过电源适配器，换过电池……总之是遇到过不少大大小小的毛病。&lt;/p&gt;
&lt;p&gt;印象中，这本子最初的系统是win7，后来换过win8和win8.1，现在用的是win10。不过整体配置确实是不太适合新版win10了，毕竟CPU是3代的i5，频率也不高，系统空载时占用的内存也不少。&lt;/p&gt;
&lt;h1 id=&quot;解决方案&quot;&gt;2 &lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h1&gt;&lt;p&gt;既然是系统不太合适，那就更换系统呗！我凭借自身的知识储备，大致想出了如下的系统更换方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;老版的win10&lt;/li&gt;
&lt;li&gt;精简版win10&lt;/li&gt;
&lt;li&gt;win8.1&lt;/li&gt;
&lt;li&gt;win7&lt;/li&gt;
&lt;li&gt;linux&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方案1的老版win10换汤不换药，感觉很大机率还是会出现卡顿的现象，不作考虑。&lt;/p&gt;
&lt;p&gt;方案2，网上论坛流传的精简版镜像基本都会添加私货（各种乱七八糟的预装软件，同时可能也会有后门软件，不安全），自己动手制作精简版镜像倒也行，不过现在都没啥精力折腾这些东西了，这个方案也pass。&lt;/p&gt;
&lt;p&gt;方案3，网卡驱动会有问题，以前这本子用win8.1的时候就遇到过无法连接某些wifi信号，pass。&lt;/p&gt;
&lt;p&gt;方案4的win7系统太老了，直接pass。&lt;/p&gt;
&lt;p&gt;最后也就只剩方案5——linux系统。linux确实很适合老配置的机子，系统本身就不会消耗过多的硬件资源。不过，linux的软件生态和驱动远不如windows平台，并且发行版众多。现在暂且不考虑软件生态和驱动问题，如何选择linux的发行版呢？&lt;/p&gt;</summary>
    
    
    
    <category term="os" scheme="https://mister-kin.github.io/categories/os/"/>
    
    
    <category term="linux" scheme="https://mister-kin.github.io/tags/linux/"/>
    
    <category term="deepin" scheme="https://mister-kin.github.io/tags/deepin/"/>
    
    <category term="系统" scheme="https://mister-kin.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="深度系统" scheme="https://mister-kin.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="联想" scheme="https://mister-kin.github.io/tags/%E8%81%94%E6%83%B3/"/>
    
    <category term="lenovo" scheme="https://mister-kin.github.io/tags/lenovo/"/>
    
    <category term="z500" scheme="https://mister-kin.github.io/tags/z500/"/>
    
  </entry>
  
  <entry>
    <title>站点导航和公告</title>
    <link href="https://mister-kin.github.io/navigation-announcement/"/>
    <id>https://mister-kin.github.io/navigation-announcement/</id>
    <published>2020-08-09T15:23:00.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<center><div style="margin-top: -35px; margin-bottom: 25px"><div class="dropdown-menu">    <button class="dropdown-menu-btn">镜像网站</button>    <div class="dropdown-menu-content">        <a href="https://mister-kin.gitee.io/">GiteePages</a>    </div></div><div class="dropdown-menu">    <button class="dropdown-menu-btn">软件作品</button>    <div class="dropdown-menu-content">        <a href="/manuals/toggle-language/">切换语言</a>    </div></div><div class="dropdown-menu">    <button class="dropdown-menu-btn">蓝图规划</button>    <div class="dropdown-menu-content">        <a href="/roadmap/#切换语言-Blender-插件">切换语言</a>    </div></div><div class="dropdown-menu">    <button class="dropdown-menu-btn">关于我</button>    <div class="dropdown-menu-content">        <a href="/about">关于我</a>        <a href="/about/#联系方式">联系我</a>        <a href="/about/#关注我">关注我</a>        <a href="/about/#免费支持我">支持我</a>    </div></div><div class="dropdown-menu">    <button class="dropdown-menu-btn">关于本站</button>    <div class="dropdown-menu-content">        <a href="/about/about-site">关于本站</a>        <a href="/about/about-site/#本站许可协议">许可说明</a>        <a href="/about/logs">更新日志</a>        <a href="/about/third-party-declaration/">第三方声明</a>        <a href="/about/post-offline-download/">离线下载</a>    </div></div></div><div class="note info no-icon"><p><strong>置顶公告1：点击访问本站的「<a href="https://mister-kin.gitee.io/">基于 Gitee Pages 的镜像网站</a>」，以解决国内访问 Github Pages 时网络不畅的问题。</strong></p></div><div class="note info no-icon"><p><strong>置顶公告2：本站一些重要的博文会有对应的PDF及LaTeX源码，可以下载用以离线查看，具体详看「<a href="/about/post-offline-download/">博文离线下载</a>」。</strong></p></div><div class="note danger no-icon"><p><strong>当前公告：随缘更新</strong></p></div></center><style type="text/css">.dropdown-menu {    position: relative;    display: inline-block;}.dropdown-menu-btn {    background: var(--btn-default-bg);    border: 5px solid var(--btn-default-border-color);    border-radius: 5px;    color: var(--btn-default-color);    display: inline-block;    font-weight: bold;    font-size: 25px;    line-height: 2;    padding: 0 12px;    text-decoration: none;    transition-property: background-color;    transition-delay: 0s;    transition-duration: .2s;    transition-timing-function: ease-in-out;    margin-right: -5px;}.dropdown-menu:hover .dropdown-menu-btn {    background: var(--btn-default-hover-bg);    border-color: var(--btn-default-hover-border-color);    color: var(--btn-default-hover-color);    cursor: pointer;}.dropdown-menu-content {    display: none;    position: absolute;    z-index: 9999;    border: 3px solid var(--btn-default-border-color);    border-radius: 3px;    width: 100%;}.dropdown-menu:hover .dropdown-menu-content {    display: block;    border-color: var(--btn-default-hover-border-color);}.dropdown-menu-content a {    display: block;    font-size: 22px;    color: var(--btn-default-color);    background-color: var(--btn-default-bg);    padding:  5px 5px;}.dropdown-menu-content a:hover {    color: var(--btn-default-hover-color);    background: var(--btn-default-hover-bg);    cursor: pointer;}</style>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;center&gt;
&lt;div style=&quot;margin-top: -35px; margin-bottom: 25px&quot;&gt;

&lt;div class=&quot;dropdown-menu&quot;&gt;
    &lt;button</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>翻译规划（作废）</title>
    <link href="https://mister-kin.github.io/translations/translation-roadmap/"/>
    <id>https://mister-kin.github.io/translations/translation-roadmap/</id>
    <published>2018-12-16T02:24:40.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger no-icon"><p><strong>注：本文撰写进度：90%</strong></p></div><h1 id="计划声明">1 <a href="#计划声明" class="headerlink" title="计划声明"></a>计划声明</h1><p>开个大坑，期望自己能够一直坚持做下去吧！在此开个页面算是打卡吧，也方便大家了解进度及访问相应的链接。</p><h2 id="B站视频教程翻译">1.1 <a href="#B站视频教程翻译" class="headerlink" title="B站视频教程翻译"></a>B站视频教程翻译</h2><p>目前本人已暂停搬运教程，正在编写一个字幕处理程序，以此加快我翻译的速度。程序完成后，会重新开始译制教程，并在过往的投稿中选择我认为较为重要的机翻教程教程进行精翻。</p><div class="note info no-icon"><p><strong>程序完成进度：10%。</strong>啊，无奈，缓慢的编写进度！ (ಥ﹏ಥ)</p></div><h2 id="文档翻译">1.2 <a href="#文档翻译" class="headerlink" title="文档翻译"></a>文档翻译</h2><span id="more"></span><h1 id="B站翻译计划表">2 <a href="#B站翻译计划表" class="headerlink" title="B站翻译计划表"></a>B站翻译计划表</h1><p><strong>注：点击列表中的英文视频名即可访问相应的B站链接。</strong></p><h2 id="未完成（已搬运）">2.1 <a href="#未完成（已搬运）" class="headerlink" title="未完成（已搬运）"></a>未完成（已搬运）</h2><h2 id="精翻熟肉">2.2 <a href="#精翻熟肉" class="headerlink" title="精翻熟肉"></a>精翻熟肉</h2><table><thead><tr><th align="center">视频名</th><th align="center">中译名</th><th align="center">视频总数量</th><th align="center">待完成</th></tr></thead><tbody><tr><td align="center"><a href="https://www.bilibili.com/video/av22248395/">Too Busy to Learn Blender</a></td><td align="center">没时间学Blender？</td><td align="center">1P</td><td align="center">应评论第六楼朋友的要求，细调06：36左右的字幕</td></tr></tbody></table><h2 id="机翻（即未完成精翻）">2.3 <a href="#机翻（即未完成精翻）" class="headerlink" title="机翻（即未完成精翻）"></a>机翻（即未完成精翻）</h2><table><thead><tr><th align="center">视频名</th><th align="center">中译名</th><th align="center">视频总数量</th><th align="center">完成进度</th></tr></thead><tbody><tr><td align="center"><a href="https://www.bilibili.com/video/av21352168/">Blender Inside Out</a></td><td align="center">从里到外学习Blender</td><td align="center">56P</td><td align="center">已精翻共7P（P1-P6），剩余机翻共48P（P7-P56）</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av23309388/">The Cycles Node Editor</a></td><td align="center">Blender Cycles节点编辑器教程</td><td align="center">3P</td><td align="center">已精翻共P1（P1），剩余机翻共2P（P2-P3）</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22416165/">Lighting and Baking Workflow- Blender Tutorial</a></td><td align="center">照明和烘培的工作流 - Blender教程</td><td align="center">1P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22437199/">18 Ways to Speed Up Blender Cycles Rendering</a></td><td align="center">18种加速 Blender Cycles 渲染的方法</td><td align="center">1P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22518346/">Blender Tutorial Quick Water Animation</a></td><td align="center">Blender教程-快速流体动画</td><td align="center">1P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22533845/">Smoke Simulation Tutorial - Blender Cycles</a></td><td align="center">Blender Cycles烟雾模拟教程</td><td align="center">1P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22675108/">Introduction to Modeling in Blender</a></td><td align="center">Blender建模介绍</td><td align="center">24P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22696450/">Blender Blend&amp;Paint</a></td><td align="center">Blender贴图绘制</td><td align="center">22P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22732936/">Money doesn&#39;t interest me - Creator of Blender talks about its future</a></td><td align="center">我对钱不感兴趣 - Blender创造者谈及它的未来</td><td align="center">1P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22800138/">How I learned to draw&#39; with RossDraws</a></td><td align="center">如何跟RossDraws学画画？【Ross Tran采访】</td><td align="center">1P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22903574/">Official Blender Open Movies</a></td><td align="center">官方Blender开源电影</td><td align="center">9P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22909325/">Comic book tutorial - Krita</a></td><td align="center">漫画教程 - Krita</td><td align="center">7P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22915300/">A comicpage creator for Krita</a></td><td align="center">krita漫画模板生成工具</td><td align="center">1P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22668940/">Auto-Flatting Comic with Krita (+Gmic plugin)</a></td><td align="center">Krita漫画自动上色 - Gmic插件</td><td align="center">1P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av23002211/">Natron for Beginners - Intro _ Overview</a></td><td align="center">Natron新手教程-介绍概述</td><td align="center">1P</td><td align="center">未精翻</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22529905/">A New FREE Render Engine!</a></td><td align="center">一个新的免费渲染引擎（Radeon Pro Render）</td><td align="center">1P</td><td align="center">未精翻（等支持BL 2.8后开始）</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av23636374/">AMD Radeon™ ProRender</a></td><td align="center">AMD Radeon™ ProRender 官方教程 - 无字幕</td><td align="center">17P</td><td align="center">未精翻（等支持BL 2.8后开始）</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av23634562/">Real-Time Ray Tracing with Radeon ProRender</a></td><td align="center">Radeon ProRender 实时光线追踪</td><td align="center">1P</td><td align="center">未精翻（等支持BL 2.8后开始）</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av23635797/">Radeon™ ProRender Real Time Ray Tracing Explained</a></td><td align="center">Radeon™ ProRender 实时光线追踪解释</td><td align="center">1P</td><td align="center">未精翻（等支持BL 2.8后开始）</td></tr></tbody></table><h2 id="未搬运">2.4 <a href="#未搬运" class="headerlink" title="未搬运"></a>未搬运</h2><ul><li>暂无</li></ul><h2 id="已完成">2.5 <a href="#已完成" class="headerlink" title="已完成"></a>已完成</h2><p><strong><center>Blender 教程</center></strong></p><table><thead><tr><th align="center">视频名</th><th align="center">中译名</th><th align="center">视频总数量</th></tr></thead><tbody><tr><td align="center"><a href="https://www.bilibili.com/video/av22327776">Is Blender Actually Hard to Learn</a></td><td align="center">Blender真的很难学吗？</td><td align="center">1P</td></tr></tbody></table><p><strong><center>Blender 插件教程</center></strong></p><table><thead><tr><th align="center">视频名</th><th align="center">中译名</th><th align="center">视频总数量</th></tr></thead><tbody><tr><td align="center"><a href="https://www.bilibili.com/video/av21226233">VSE Quick Functions Demo 0.91</a></td><td align="center">Blender VSE快速功能演示</td><td align="center">1P</td></tr><tr><td align="center"><a href="https://www.bilibili.com/video/av22523468/">Radeon Pro Render</a></td><td align="center">Radeon Pro Render 官方宣传视频</td><td align="center">1P</td></tr></tbody></table><h1 id="文档翻译计划表">3 <a href="#文档翻译计划表" class="headerlink" title="文档翻译计划表"></a>文档翻译计划表</h1><h2 id="开源软件的参考文档翻译">3.1 <a href="#开源软件的参考文档翻译" class="headerlink" title="开源软件的参考文档翻译"></a>开源软件的参考文档翻译</h2><h2 id="已参与">3.2 <a href="#已参与" class="headerlink" title="已参与"></a>已参与</h2><ul><li><a href="https://docs.krita.org/en/">Krita文档翻译</a></li></ul><h2 id="未参与（计划）">3.3 <a href="#未参与（计划）" class="headerlink" title="未参与（计划）"></a>未参与（计划）</h2><ul><li><a href="https://docs.blender.org/manual/en/dev/">Blender文档</a></li><li><a href="https://docs.gimp.org/2.10/zh_CN/">GIMP文档</a></li></ul><h2 id="渲染器的参考文档翻译（未实施）">3.4 <a href="#渲染器的参考文档翻译（未实施）" class="headerlink" title="渲染器的参考文档翻译（未实施）"></a>渲染器的参考文档翻译（未实施）</h2><p>这些文档在官网上没有提供在线文档浏览，因此我有想法在Github上开个公共 Repo 来建立翻译的储存库，也方便文档有新内容时可以实时更新吧！有想法的朋友可以共同参与！</p><p>目前暂定两个文档：</p><ul><li><a href="https://www.amd.com/en/technologies/radeon-prorender-downloads">Redoen Pro Render 的文档</a></li><li><a href="http://www.mitsuba-renderer.org/docs.html">Mitsuba Render 的文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note danger no-icon&quot;&gt;&lt;p&gt;&lt;strong&gt;注：本文撰写进度：90%&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h1 id=&quot;计划声明&quot;&gt;1 &lt;a href=&quot;#计划声明&quot; class=&quot;headerlink&quot; title=&quot;计划声明&quot;&gt;&lt;/a&gt;计划声明&lt;/h1&gt;&lt;p&gt;开个大坑，期望自己能够一直坚持做下去吧！在此开个页面算是打卡吧，也方便大家了解进度及访问相应的链接。&lt;/p&gt;
&lt;h2 id=&quot;B站视频教程翻译&quot;&gt;1.1 &lt;a href=&quot;#B站视频教程翻译&quot; class=&quot;headerlink&quot; title=&quot;B站视频教程翻译&quot;&gt;&lt;/a&gt;B站视频教程翻译&lt;/h2&gt;&lt;p&gt;目前本人已暂停搬运教程，正在编写一个字幕处理程序，以此加快我翻译的速度。程序完成后，会重新开始译制教程，并在过往的投稿中选择我认为较为重要的机翻教程教程进行精翻。&lt;/p&gt;
&lt;div class=&quot;note info no-icon&quot;&gt;&lt;p&gt;&lt;strong&gt;程序完成进度：10%。&lt;/strong&gt;啊，无奈，缓慢的编写进度！ (ಥ﹏ಥ)&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;文档翻译&quot;&gt;1.2 &lt;a href=&quot;#文档翻译&quot; class=&quot;headerlink&quot; title=&quot;文档翻译&quot;&gt;&lt;/a&gt;文档翻译&lt;/h2&gt;</summary>
    
    
    
    <category term="translations" scheme="https://mister-kin.github.io/categories/translations/"/>
    
    
    <category term="翻译" scheme="https://mister-kin.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="计划" scheme="https://mister-kin.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>火狐浏览器拓展推荐</title>
    <link href="https://mister-kin.github.io/recommended-firefox-addons/"/>
    <id>https://mister-kin.github.io/recommended-firefox-addons/</id>
    <published>2018-12-11T08:47:37.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="火狐浏览器的几点说明">0.1 <a href="#火狐浏览器的几点说明" class="headerlink" title="火狐浏览器的几点说明"></a>火狐浏览器的几点说明</h2><p><strong>注：火狐浏览器国内版离线安装包：<a href="http://www.firefox.com.cn/download/">下载链接</a></strong></p><div class="flex-column"><img data-src="/images/recommended_firefox_addons/firefox-offline-installer.png">国内版离线安装包下载示意</div><span id="more"></span><h2 id="拓展插件推荐">0.2 <a href="#拓展插件推荐" class="headerlink" title="拓展插件推荐"></a>拓展插件推荐</h2><h3 id="标签页优化">0.2.1 <a href="#标签页优化" class="headerlink" title="标签页优化"></a>标签页优化</h3><h3 id="附件组件管理器">0.2.2 <a href="#附件组件管理器" class="headerlink" title="附件组件管理器"></a>附件组件管理器</h3><h3 id="云盘万能钥匙">0.2.3 <a href="#云盘万能钥匙" class="headerlink" title="云盘万能钥匙"></a>云盘万能钥匙</h3><h3 id="Dark-Night-Mode">0.2.4 <a href="#Dark-Night-Mode" class="headerlink" title="Dark Night Mode"></a>Dark Night Mode</h3><h3 id="Gesturefy">0.2.5 <a href="#Gesturefy" class="headerlink" title="Gesturefy"></a>Gesturefy</h3><h3 id="QiuReader">0.2.6 <a href="#QiuReader" class="headerlink" title="QiuReader"></a>QiuReader</h3><h3 id="Tampermonkey">0.2.7 <a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h3><h3 id="uBlock-Origin">0.2.8 <a href="#uBlock-Origin" class="headerlink" title="uBlock Origin"></a>uBlock Origin</h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;火狐浏览器的几点说明&quot;&gt;0.1 &lt;a href=&quot;#火狐浏览器的几点说明&quot; class=&quot;headerlink&quot; title=&quot;火狐浏览器的几点说明&quot;&gt;&lt;/a&gt;火狐浏览器的几点说明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注：火狐浏览器国内版离线安装包：&lt;a href=&quot;http://www.firefox.com.cn/download/&quot;&gt;下载链接&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;flex-column&quot;&gt;
&lt;img data-src=&quot;/images/recommended_firefox_addons/firefox-offline-installer.png&quot;&gt;国内版离线安装包下载示意
&lt;/div&gt;</summary>
    
    
    
    
    <category term="开源软件" scheme="https://mister-kin.github.io/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="资料整理" scheme="https://mister-kin.github.io/tags/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    
    <category term="火狐浏览器" scheme="https://mister-kin.github.io/tags/%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Blender自学资料向（干货整理）</title>
    <link href="https://mister-kin.github.io/blender-learning-resources/"/>
    <id>https://mister-kin.github.io/blender-learning-resources/</id>
    <published>2018-10-05T08:31:45.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/images/blender_learning_resources/cover.jpg" style="width: 580px"><p>本文主要介绍自学资料的获取途径。</p><h2 id="官方资料【强烈推荐】">0.1 <a href="#官方资料【强烈推荐】" class="headerlink" title="官方资料【强烈推荐】"></a>官方资料【强烈推荐】</h2><h3 id="Blender官方用户手册（User-Manual）【强烈推荐】">0.1.1 <a href="#Blender官方用户手册（User-Manual）【强烈推荐】" class="headerlink" title="Blender官方用户手册（User Manual）【强烈推荐】"></a>Blender官方用户手册（User Manual）<strong>【强烈推荐】</strong></h3><p>获取条件：不需翻墙。</p><p>描述：手册是一个十分重要的学习资源，其中包含着大量的关于Blender的基本知识及基础操作，不懂操作时，多翻翻手册。我推荐各位是去看英文文档的，因为这领域不少术语都没有很好的中文翻译。并且目前手册还有不少模块并没有中文化翻译，这也属正常，因为文档的翻译总是落后于源文档的更新，但文档翻译参与者数量不多也是一大原因。本人目前参与Krita文档的中文化翻译，对此感触颇深，这领域的翻译者着实太少了，像Krita的文档翻译者，用手指头就能数过来了。目前本人暂无过多精力，可能未来会有计划参与Blender的文档中文化翻译。</p><p>入口：<a href="https://docs.blender.org/manual/en/dev/">官方手册链接</a></p><span id="more"></span><div class="flex-row"><div class="flex-column"><img data-src="/images/blender_learning_resources/manual-279.jpg">2.79版本用户手册页面部分截图</div><div class="flex-column"><img data-src="/images/blender_learning_resources/manual-280.jpg">2.80版本用户手册页面部分截图</div></div><p><strong>注：2.8手册刚刚开写，所以内容跟2.79基本一样。(目前网站上已可以正常切换中文版手册)<del>且现在官网上也无法正常切换到中文版的手册，估计是官方忙着写新手册吧。</del></strong></p><h3 id="Blender官方完整文档（Blender-WiKi）【推荐】">0.1.2 <a href="#Blender官方完整文档（Blender-WiKi）【推荐】" class="headerlink" title="Blender官方完整文档（Blender WiKi）【推荐】"></a>Blender官方完整文档（Blender WiKi）<strong>【推荐】</strong></h3><p>条件：不需翻墙。</p><p>描述：WiKi上记录着很多Blender的资料，包括各版本的发布记录，记录详情可在Reference&#x2F;Release Notes条目中找到，在这你能了解到Blender各模块发展情况。此外，WiKi上还有FAQ等内容，这些就不多介绍了。</p><p>入口：<a href="https://wiki.blender.org/">Wiki网站链接</a></p><div class="flex-column"><img data-src="/images/blender_learning_resources/developer-wiki.png">WiKi网站部分截图</div><h3 id="Blender官网网站支持页面（Support）【推荐】">0.1.3 <a href="#Blender官网网站支持页面（Support）【推荐】" class="headerlink" title="Blender官网网站支持页面（Support）【推荐】"></a>Blender官网网站支持页面（Support）<strong>【推荐】</strong></h3><p>条件：不需翻墙。</p><p>描述：该页面包含许多链接。如下图，文档类、教程类，社区支持等。用户手册地址都可以从这访问。教程类列出很多链接，其中含有Blender Cloud，经济条件允许的朋友可以选择支持下，注册为云成员。云上面有很多录制的视频教程，它也包含着开源电影的相关资源。云上面有一个《Blender Inside Out》系列视频，这个十分适合从其他三维平台转到Blender上的朋友去学习，讲得很细致。但因为里面有着很多硬基础知识，因此不适合完全零基础的人。（这个系列我也搬运到B站上，目前完成了第一章翻译，其余暂时都还是油管的机翻字幕，视频请戳<a href="https://www.bilibili.com/video/av21352168">这里</a>）</p><p>入口：<a href="https://www.blender.org/support/">Support页面链接</a></p><div class="flex-row"><div class="flex-column"><img data-src="/images/blender_learning_resources/support.png">Support页面部分截图</div></div><h3 id="Blender官方教程（Blender-Old-WiKi）【旧址】【不推荐】">0.1.4 <a href="#Blender官方教程（Blender-Old-WiKi）【旧址】【不推荐】" class="headerlink" title="Blender官方教程（Blender Old WiKi）【旧址】【不推荐】"></a><del>Blender官方教程（Blender Old WiKi）</del><strong>【旧址】【不推荐】</strong></h3><p>条件：不需翻墙。注：可能部分外部教程链接需要翻墙或者失效了。</p><p>描述：其实就是旧WiKi，但该旧WiKi已全部迁至新WiKi地址了，且该网站已经停止更新。大部分内容都是文字。</p><p>入口：<a href="https://en.blender.org/">教程网站新链接</a></p><p>旧址：<del><a href="https://wiki.blender.org/index.php/Doc:2.6/Tutorials">https://wiki.blender.org/index.php/Doc:2.6/Tutorials</a></del> 【已失效，新入口在上方】</p><div class="flex-row"><div class="flex-column"><img data-src="/images/blender_learning_resources/wiki2.6.png">旧WiKi部分截图</div></div><h2 id="站点推荐">0.2 <a href="#站点推荐" class="headerlink" title="站点推荐"></a>站点推荐</h2><h3 id="国外篇">0.2.1 <a href="#国外篇" class="headerlink" title="国外篇"></a>国外篇</h3><h4 id="Blender-Guru-【强烈推荐】">0.2.1.1 <a href="#Blender-Guru-【强烈推荐】" class="headerlink" title="Blender Guru 【强烈推荐】"></a>Blender Guru 【强烈推荐】</h4><p>条件：无需翻墙。但实际上该站点的视频是存放于油管上的，所以想看视频是需要搭梯子翻出去的。</p><p>描述：Guru站点我不必多言了，相信很多朋友都看过Guru站点的教程，教程都是免费的。Guru站点有个一个初学者的系列视频，十分适合完全三维零基础的朋友去学习，就是下方右图的“甜甜圈&quot;视频系列。（视频请戳<a href="https://www.blenderguru.com/tutorials/blender-beginner-tutorial-series">这里</a>）。站长Andrew Price是个十分帅气幽默的小伙。想了解Guru网站的成立由来可以戳这个：<a href="https://www.blenderguru.com/about/">Guru站点由来</a></p><p>入口：<a href="https://www.blenderguru.com/">Guru站点链接</a></p><div class="flex-row"><div class="flex-column"><img data-src="/images/blender_learning_resources/andrew-price.png" style="width: 611px">Andrew Price 本人</div><div class="flex-column"><img data-src="/images/blender_learning_resources/blender-guru.png">Guru站点部分截图</div></div><p><strong>注：后面国外篇的站点，本人不经常访问，不太了解详情，所以有些就不作描述了</strong></p><h4 id="Blender-Community-【推荐】">0.2.1.2 <a href="#Blender-Community-【推荐】" class="headerlink" title="Blender Community 【推荐】"></a>Blender Community 【推荐】</h4><p>入口：<a href="https://blender.community/c/">Blender Community站点</a></p><h4 id="Creative-Shrimp-【推荐】">0.2.1.3 <a href="#Creative-Shrimp-【推荐】" class="headerlink" title="Creative Shrimp 【推荐】"></a>Creative Shrimp 【推荐】</h4><p>描述：没怎么具体了解过，我猜应该是Gleb Alexandrov搭建的。最初是通过Gleb的一个加速渲染的视频了解到他的，视频详情请戳<a href="https://www.bilibili.com/video/av22416165/"><strong>这里</strong></a>。</p><p>入口：<a href="http://www.creativeshrimp.com/">Creative Shrimp站点链接</a></p><h4 id="CG-Geek">0.2.1.4 <a href="#CG-Geek" class="headerlink" title="CG Geek"></a>CG Geek</h4><p>入口：<a href="https://www.deviantart.com/cg-geek">CG Geek站点链接</a></p><h4 id="CG-Masters">0.2.1.5 <a href="#CG-Masters" class="headerlink" title="CG Masters"></a>CG Masters</h4><p>入口：<a href="https://cgmasters.net/">CG Masters站点链接</a></p><h4 id="Blender-Cookie">0.2.1.6 <a href="#Blender-Cookie" class="headerlink" title="Blender Cookie"></a>Blender Cookie</h4><p>入口：<a href="https://cgcookie.com/">Blender Cookie站点链接</a></p><h4 id="BlenderDiplom">0.2.1.7 <a href="#BlenderDiplom" class="headerlink" title="BlenderDiplom"></a>BlenderDiplom</h4><p>描述：Blender官方云上有一本关于Cycles引擎教程的电子书——《The Cycles Encylopedia v1.4》，该书的两位作者都活跃于该站点上。</p><p>入口：<a href="http://www.blenderdiplom.com/en/">BlenderDiplom站点链接</a></p><h4 id="Blender-Nation">0.2.1.8 <a href="#Blender-Nation" class="headerlink" title="Blender Nation"></a>Blender Nation</h4><p>入口：<a href="https://www.blendernation.com/">Blender Nation站点链接</a></p><h4 id="Blender-Artists">0.2.1.9 <a href="#Blender-Artists" class="headerlink" title="Blender Artists"></a>Blender Artists</h4><p>入口：<a href="https://blenderartists.org/">Blender Artists站点链接</a></p><h4 id="Blender-Nerd【不推荐】">0.2.1.10 <a href="#Blender-Nerd【不推荐】" class="headerlink" title="Blender Nerd【不推荐】"></a><del>Blender Nerd</del>【不推荐】</h4><p>描述：该站点目前改成了Richard Harby，不清楚该站点什么规划。以前不怎么上这站点，所以我不做跟进了解。</p><p>入口：<a href="http://www.blendernerd.com/">Blender Nerd站点链接</a></p><h3 id="国内篇">0.2.2 <a href="#国内篇" class="headerlink" title="国内篇"></a>国内篇</h3><h4 id="Blender中国社区（斑斓中国）【推荐】">0.2.2.1 <a href="#Blender中国社区（斑斓中国）【推荐】" class="headerlink" title="Blender中国社区（斑斓中国）【推荐】"></a>Blender中国社区（斑斓中国）【推荐】</h4><p>入口：<a href="http://www.blendercn.org/">斑斓中国站点链接</a></p><h4 id="Blender-Get-【推荐】">0.2.2.2 <a href="#Blender-Get-【推荐】" class="headerlink" title="Blender Get 【推荐】"></a>Blender Get 【推荐】</h4><p>描述：Blender Get是罗聪翼先生搭建的站点，罗先生著有全球首本中文著作《Blender权威指南》。</p><p>入口：<a href="http://www.blenderget.com/">Blender Get站点链接</a></p><h2 id="B站篇UP推荐">0.3 <a href="#B站篇UP推荐" class="headerlink" title="B站篇UP推荐"></a>B站篇UP推荐</h2><h3 id="翻译UP">0.3.1 <a href="#翻译UP" class="headerlink" title="翻译UP"></a>翻译UP</h3><h4 id="Mr-Kin-【强烈推荐】">0.3.1.1 <a href="#Mr-Kin-【强烈推荐】" class="headerlink" title="Mr. Kin 【强烈推荐】"></a>Mr. Kin 【强烈推荐】</h4><div class="flex-row-left-start"><div class="flex-column"><img data-src="/images/blender_learning_resources/comical-face.png" style="width: 200px">没错，就是我，滑稽护体。</div></div><p><a href="https://space.bilibili.com/17025250/#/">空间入口请戳</a>。<strong>（明示支持三连，滑稽.jpg）</strong></p><div class="flex-row"><div class="flex-column"><img data-src="/images/blender_learning_resources/my-bili-zone.png">我的Bilibili空间截图</div></div><h4 id="随波远流">0.3.1.2 <a href="#随波远流" class="headerlink" title="随波远流"></a>随波远流</h4><p><a href="https://space.bilibili.com/24808665/#/">空间入口请戳</a></p><div class="flex-row"><div class="flex-column"><img data-src="/images/blender_learning_resources/suibozhuliu-zone.png">随波远流的Bilibili空间截图</div></div><h4 id="CGGAP">0.3.1.3 <a href="#CGGAP" class="headerlink" title="CGGAP"></a>CGGAP</h4><p><a href="https://space.bilibili.com/50678221/#/">空间入口请戳</a></p><div class="flex-row"><div class="flex-column"><img data-src="/images/blender_learning_resources/cggap-zone.png">CGGA的Bilibili空间截图</div></div><p><strong>注：其他不作介绍了，大家自己去寻找吧！</strong></p><h3 id="原创UP">0.3.2 <a href="#原创UP" class="headerlink" title="原创UP"></a>原创UP</h3><h4 id="blenderCN-黑马赛克-【推荐】">0.3.2.1 <a href="#blenderCN-黑马赛克-【推荐】" class="headerlink" title="blenderCN-黑马赛克 【推荐】"></a>blenderCN-黑马赛克 【推荐】</h4><p><a href="https://space.bilibili.com/7549097/#/">空间入口请戳</a></p><div class="flex-row"><div class="flex-column"><img data-src="/images/blender_learning_resources/blendercn-zone.png">blenderCN-黑马赛克的Bilibili空间截图</div></div><h4 id="顺子老师">0.3.2.2 <a href="#顺子老师" class="headerlink" title="顺子老师"></a>顺子老师</h4><p><a href="https://space.bilibili.com/38988725/#/">空间入口请戳</a></p><div class="flex-row"><div class="flex-column"><img data-src="/images/blender_learning_resources/shunzi-zone.png">顺子老师的Bilibili空间截图</div></div><h4 id="我是栗子菌">0.3.2.3 <a href="#我是栗子菌" class="headerlink" title="我是栗子菌"></a>我是栗子菌</h4><p><a href="https://space.bilibili.com/20444678/#/">空间入口请戳</a></p><div class="flex-row"><div class="flex-column"><img data-src="/images/blender_learning_resources/shunzi-zone.png">我是栗子菌的Bilibili空间截图</div></div><p><strong>注：其他不作介绍了，大家自己去寻找吧！</strong></p><h2 id="Youtube专讲【强烈推荐】">0.4 <a href="#Youtube专讲【强烈推荐】" class="headerlink" title="Youtube专讲【强烈推荐】"></a>Youtube专讲【强烈推荐】</h2><h3 id="概述">0.4.1 <a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>条件：翻墙。也可通过镜像链接来访问，即不需翻墙，但肯定不如原网站链接好使，且油管的镜像链接经常失效。<strong>推荐搭梯子翻墙</strong>，不推荐使用镜像链接直翻。</p><p>作为全球最大的视频网站，油管有着许多优质的教程，以上有些站点的视频教程便是放在油管上的，例如Guru。建议朋友们上油管搜索教程，搜索也是有不少技巧的，以下列出一些关键字：</p><ul><li>搜索Blender，关键字【blender】</li><li>搜索教程时，关键字【tutorial】或【training】</li><li>具体搜索某个模块时，比如建模，关键字【modeling】；角色建模，关键字【character modeling】</li><li>纹理贴图，关键字【texture】</li><li>材质，关键字【material】</li><li>渲染，关键字【rendering】</li><li>灯光，关键字【lighting】</li><li>动画，关键字【animate】【animation】</li><li>其余以此类推</li></ul><p>关于油管的使用，对于英文不太好的朋友来说，如果视频没有自带中文字幕，可以选择观看油管的自动翻译字幕。如果原视频带有其他语言的字幕，此时自动翻译的质量还是不错的。但如果原视频没有自带任何字幕，只能看机器是否能够识别出来语言来了，例如视频开头若有很长一段背景音乐就无法识别了。使用选项如下图：<br><img data-src="/images/blender_learning_resources/youtube.png"></p><h3 id="Youtuber推荐">0.4.2 <a href="#Youtuber推荐" class="headerlink" title="Youtuber推荐"></a>Youtuber推荐</h3><ul><li>Blender Developers</li><li>Blender</li><li>Blender Guru</li><li>Daniel Kreuter</li><li>CG Master</li><li>CG Geek</li><li>Gleb Alexandrov</li><li>CG Cookie - Blender Training</li></ul><p><strong>注：其他靠大家寻找了，不过多列举了。</strong></p><h2 id="结语">0.5 <a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于英语资料的阅读技巧：</p><ul><li>提高英语水平 —— 应对所有状况</li><li>给浏览器装上页面翻译的拓展插件 —— 应对网站上文字类资料</li><li>Youtube的自动翻译选项 —— 应对视频（前提：油管上有该视频且满足自动翻译的条件）</li></ul><p>以上很多资料都是英文居多，非以英语为母语的我们，观看时难免会有阅读障碍。拿我自己举个例子吧，虽然我能看懂听译这些教程，但其实速度上远远不及阅读中文的速度，相比于看英文，看中文的速度就像是开挂加速的。而这对于想要快速通过教程资料上手BL的朋友们来说，中文无疑是成为了一个很重要的因素。所以，这也是我做翻译的一个原因，同时也是为了方便自个看吧。但由于个人精力有限，因此我此前搬运的大部分视频教程的中文字幕是油管上的机翻字幕，所以也同时贴出英文字幕（油管上英文字幕准确率还是可以的）。至于有些没字幕的，才会去听译，但听译极其耗费时间和精力。</p><p>目前本人已暂停搬运教程，正在编写一个字幕处理程序，以此加快我翻译的速度。程序完成后，会重新开始译制教程，并在过往的投稿选择我认为较为重要的机翻教程教程进行精翻。</p><p>Anyways, 其实掌握了基础的语法和音标，把词汇量提上去，英语学习基本上是没有障碍的了。汉语是语义型语言，注重内容的意会性；英语是语法型语言，表现形式完整、严谨。这一点认识对于英语的学习来说也是很重要的，意识到这个，要有针对性地学习，我们就不能用汉语的思维去学习英语。而关于词汇量的提高方法，不赘述了，仅告诫大家一点，切忌死记硬背，放在语境中去理解来记更好，比如多去阅读英文资料。更多时候英文资料看不看得下去，其实是<strong>心态问题</strong>。</p><p>Alright! Hope you guys could enjoy learning Blender! Adios!</p><p><em><strong>注：最后呼吁喜欢这领域且英语不错的朋友能够参与该领域的翻译，无论是文档或是程序本体亦或是教程视频。十分感谢！欢迎和我交流！</strong></em></p><p><a href="https://www.bilibili.com/read/cv553195">本文B站链接</a></p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/images/blender_learning_resources/cover.jpg&quot; style=&quot;width: 580px&quot;&gt;

&lt;p&gt;本文主要介绍自学资料的获取途径。&lt;/p&gt;
&lt;h2 id=&quot;官方资料【强烈推荐】&quot;&gt;0.1 &lt;a href=&quot;#官方资料【强烈推荐】&quot; class=&quot;headerlink&quot; title=&quot;官方资料【强烈推荐】&quot;&gt;&lt;/a&gt;官方资料【强烈推荐】&lt;/h2&gt;&lt;h3 id=&quot;Blender官方用户手册（User-Manual）【强烈推荐】&quot;&gt;0.1.1 &lt;a href=&quot;#Blender官方用户手册（User-Manual）【强烈推荐】&quot; class=&quot;headerlink&quot; title=&quot;Blender官方用户手册（User Manual）【强烈推荐】&quot;&gt;&lt;/a&gt;Blender官方用户手册（User Manual）&lt;strong&gt;【强烈推荐】&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;获取条件：不需翻墙。&lt;/p&gt;
&lt;p&gt;描述：手册是一个十分重要的学习资源，其中包含着大量的关于Blender的基本知识及基础操作，不懂操作时，多翻翻手册。我推荐各位是去看英文文档的，因为这领域不少术语都没有很好的中文翻译。并且目前手册还有不少模块并没有中文化翻译，这也属正常，因为文档的翻译总是落后于源文档的更新，但文档翻译参与者数量不多也是一大原因。本人目前参与Krita文档的中文化翻译，对此感触颇深，这领域的翻译者着实太少了，像Krita的文档翻译者，用手指头就能数过来了。目前本人暂无过多精力，可能未来会有计划参与Blender的文档中文化翻译。&lt;/p&gt;
&lt;p&gt;入口：&lt;a href=&quot;https://docs.blender.org/manual/en/dev/&quot;&gt;官方手册链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="开源软件" scheme="https://mister-kin.github.io/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="blender" scheme="https://mister-kin.github.io/tags/blender/"/>
    
    <category term="资料整理" scheme="https://mister-kin.github.io/tags/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    
    <category term="翻译" scheme="https://mister-kin.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>致首次使用RIME的你 -- 小狼毫输入法详细配置</title>
    <link href="https://mister-kin.github.io/rime-input-method/"/>
    <id>https://mister-kin.github.io/rime-input-method/</id>
    <published>2018-10-01T06:14:43.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger no-icon"><p><strong>注：本文撰写进度：5%</strong></p></div><p>TODO<br>前段时间，搜狗输入法被曝后台手脚不干净，强制推送618活动啥的。</p><h2 id="前言：我与RIME的相遇">0.1 <a href="#前言：我与RIME的相遇" class="headerlink" title="前言：我与RIME的相遇"></a>前言：我与RIME的相遇</h2><p>在受不了原版的搜狗输入法的广告弹窗和响应速度后，我开始折腾起输入法。</p><p>为了解决搜狗的弹窗问题，我使用了火绒安全软件的扩展工具 --- 弹窗拦截（强推一波<a href="https://www.huorong.cn/"><strong>火绒安全软件</strong></a>）。然后，弹窗是解决了。但由于本人最初安装搜狗输入法于机械盘，加上个人词库越来越庞大，搜狗的输入法的响应速度已经严重影响我的输入效率。</p><p>于是，我便开始搜寻精简版的搜狗输入法。所幸的是，网络上已有大神在做这个，例如<strong>大水牛去广告精简优化版</strong> --- <a href="https://pan.baidu.com/s/1RAWTp6d6eZnCtDvC6RsEmQ"><strong>百度云链接</strong></a>（提取码：ffqz）。</p><p>如此一来，响应速度的确是有所提升，可惜这种做法始终是治标不治本（其实响应速度问题也可通过安装程序于固态盘来解决）。后来在一次搜索相关开源的输入法时，我遇到了RIME。</p><span id="more"></span><p>对RIME进行简单的了解后，我便被它吸引住了。无奈的是，RIME的配置并没有图形交互界面。这对新用户来说，极为不友好。我估计这也是很多人放弃使用RIME的原因。</p><p>在遍寻各途径的资料后（官网、贴吧、博客等），我发现没有一篇文章完整并系统地介绍所有配置流程。因此，我决定收集目前网上的已存资料，并将其系统化整理。望能对新入坑的朋友有所帮助，也希望更多的朋友能够使用到基于RIME框架的输入法。</p><h2 id="软件简介">0.2 <a href="#软件简介" class="headerlink" title="软件简介"></a>软件简介</h2><h2 id="软件配置">0.3 <a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h2><h3 id="安装">0.3.1 <a href="#安装" class="headerlink" title="安装"></a>安装</h3><h3 id="繁简转换">0.3.2 <a href="#繁简转换" class="headerlink" title="繁简转换"></a>繁简转换</h3><h3 id="weasel-yaml设置">0.3.3 <a href="#weasel-yaml设置" class="headerlink" title="weasel.yaml设置"></a>weasel.yaml设置</h3><h4 id>0.3.3.1 <a href="#" class="headerlink" title></a></h4>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note danger no-icon&quot;&gt;&lt;p&gt;&lt;strong&gt;注：本文撰写进度：5%&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;TODO&lt;br&gt;前段时间，搜狗输入法被曝后台手脚不干净，强制推送618活动啥的。&lt;/p&gt;
&lt;h2 id=&quot;前言：我与RIME的相遇&quot;&gt;0.1 &lt;a href=&quot;#前言：我与RIME的相遇&quot; class=&quot;headerlink&quot; title=&quot;前言：我与RIME的相遇&quot;&gt;&lt;/a&gt;前言：我与RIME的相遇&lt;/h2&gt;&lt;p&gt;在受不了原版的搜狗输入法的广告弹窗和响应速度后，我开始折腾起输入法。&lt;/p&gt;
&lt;p&gt;为了解决搜狗的弹窗问题，我使用了火绒安全软件的扩展工具 --- 弹窗拦截（强推一波&lt;a href=&quot;https://www.huorong.cn/&quot;&gt;&lt;strong&gt;火绒安全软件&lt;/strong&gt;&lt;/a&gt;）。然后，弹窗是解决了。但由于本人最初安装搜狗输入法于机械盘，加上个人词库越来越庞大，搜狗的输入法的响应速度已经严重影响我的输入效率。&lt;/p&gt;
&lt;p&gt;于是，我便开始搜寻精简版的搜狗输入法。所幸的是，网络上已有大神在做这个，例如&lt;strong&gt;大水牛去广告精简优化版&lt;/strong&gt; --- &lt;a href=&quot;https://pan.baidu.com/s/1RAWTp6d6eZnCtDvC6RsEmQ&quot;&gt;&lt;strong&gt;百度云链接&lt;/strong&gt;&lt;/a&gt;（提取码：ffqz）。&lt;/p&gt;
&lt;p&gt;如此一来，响应速度的确是有所提升，可惜这种做法始终是治标不治本（其实响应速度问题也可通过安装程序于固态盘来解决）。后来在一次搜索相关开源的输入法时，我遇到了RIME。&lt;/p&gt;</summary>
    
    
    
    
    <category term="开源软件" scheme="https://mister-kin.github.io/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="RIME输入法" scheme="https://mister-kin.github.io/tags/RIME%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
    <category term="软件配置" scheme="https://mister-kin.github.io/tags/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>飞助远程服务店（作废）</title>
    <link href="https://mister-kin.github.io/service-shop/"/>
    <id>https://mister-kin.github.io/service-shop/</id>
    <published>2018-09-09T15:33:55.000Z</published>
    <updated>2022-02-07T10:54:42.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="店铺介绍">1 <a href="#店铺介绍" class="headerlink" title="店铺介绍"></a>店铺介绍</h1><p>本人开的一个小店，旨在通过远程操作帮助客户解决电脑系统问题。</p><img data-src="/images/service_shop/shop_logo.webp" style="width: 500px"><h2 id="为何诞生">1.1 <a href="#为何诞生" class="headerlink" title="为何诞生?"></a>为何诞生?</h2><p>许多朋友系统卡顿或者出现无法解决的毛病，想要维修或重装系统，但究于实体维修店太远或是实体店过于昂贵的收费，自己爱机的问题迟迟得不到解决。是的，50块一次的收费甚至更高，确实是贵了。因此，飞助诞生了。</p><span id="more"></span><h2 id="本店优势">1.2 <a href="#本店优势" class="headerlink" title="本店优势"></a>本店优势</h2><p>“远程”二字就已经很好说明了本店的一个特色。飞助远程，提供一个方便的平台，远程控制，无需到店。注意是<strong>远程！远程！！！</strong></p><p>无论客户身处何处，只要能提供一个良好的网络通信条件，保证机子能够访问互联网，本店就能为你服务。</p><p><strong>联系飞助远程，远程帮助系统优化&#x2F;维修&#x2F;重装，价格合理。</strong></p><h1 id="服务内容">2 <a href="#服务内容" class="headerlink" title="服务内容"></a>服务内容</h1><h2 id="系统优化-x2F-维修-x2F-重装">2.1 <a href="#系统优化-x2F-维修-x2F-重装" class="headerlink" title="系统优化&#x2F;维修&#x2F;重装"></a>系统优化&#x2F;维修&#x2F;重装</h2><p>曾经，您是否曾苦恼于系统卡顿或者出现无法解决的毛病，想要维修或重装系统，但却无从下手。</p><p>联系飞助远程，远程帮助<strong>系统优化&#x2F;维修&#x2F;重装</strong>，物美价廉。</p><div class="note danger no-icon"><p><em>注：关于系统，本店默认以最新的<strong>64</strong>位的<strong>WIN10</strong>系统镜像为源（有其他需求的请另外告知店长）。系统完全纯净，不带任何多余的第三方软件。另提供<strong>虚拟机</strong>的安装，可在其上安装<strong>Mac</strong>或<strong>Linux</strong>系统。</em></p></div><img data-src="/images/service_shop/win10.webp" style="width: 400px"><h2 id="硬盘分区">2.2 <a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h2><p>曾经，您是否因为为刚买机的时候装机人员只把您的每个硬盘做一个分区而苦恼。是的，500g或1t甚至是更大容量的机械硬盘却只能做一个分区，在管理文件上确实是十分不方便。</p><p>联系飞助远程，远程<strong>帮助硬盘分区</strong>。例如，原有分区的基础上无损调整分区，包括新增分区以及调整原有分区大小。</p><div class="flex-row"><div class="flex-column">分区前<img data-src="/images/service_shop/hard_disk_origin.webp"></div><div class="flex-column">分区后<img data-src="/images/service_shop/hard_disk_split.webp"></div></div><h2 id="软件直装">2.3 <a href="#软件直装" class="headerlink" title="软件直装"></a>软件直装</h2><p>曾经，您是否苦恼于不会装某些软件，例如办公软件套件，或者安装后但却困于激活这一步。而对于编程初学者们来说，最为头疼不过于编程环境搭建了，明明代码是正确的，却总是无法正确编译，这再痛苦不过了。</p><p>联系飞助远程，远程<strong>安装软件</strong>。需要直装<strong>office</strong>套件或者<strong>Adobe</strong>系列等其他软件的，请将软件名详细告知本店。此外，本店可提供编程初学者头疼的编程环境搭建及一些常见的环境搭建服务，例如，搭建以文本编辑软件和编译套件为基础的C和C++等语言编程环境，完成后只需几个快捷键便可在文本编辑软件上完成编译和链接。</p><div class="flex-column"><div class="flex-row"><img data-src="/images/service_shop/adobe.webp"><img data-src="/images/service_shop/office.webp"></div><img data-src="/images/service_shop/compile_c.webp"></div><h1 id="服务价格单">3 <a href="#服务价格单" class="headerlink" title="服务价格单"></a>服务价格单</h1><table><thead><tr><th align="center">服务项</th><th align="center">价格</th></tr></thead><tbody><tr><td align="center">系统维修优化</td><td align="center">￥15</td></tr><tr><td align="center">系统重装（只含驱动+VC环境）</td><td align="center">￥25</td></tr><tr><td align="center">系统重装（驱动+VC环境+MS office）</td><td align="center">￥35</td></tr><tr><td align="center">分区相关</td><td align="center">￥5</td></tr><tr><td align="center">直装软件</td><td align="center">￥15</td></tr></tbody></table><div class="note danger no-icon"><p><strong>注：价格单上的服务价格为<em>基本价格</em>，但收费是视实际操作的复杂度来决定。换句话说，最终收费是在基本价格<em>上下浮动</em>。</strong></p></div><div class="note danger no-icon"><p>特别说明：本店所有服务都是通过<strong>远程</strong>完成，某些操作可能需要远程语音指导客户自己动手操作完成，但请放心，不会涉及到复杂的操作。本店的系统维修和软件直装服务是基于<strong>Windows OS</strong>的平台，目前不接受Linux以及Mac系统的维修需求和软件直装服务。</p></div><h1 id="知识科普">4 <a href="#知识科普" class="headerlink" title="知识科普"></a>知识科普</h1><h2 id="电脑使用期限">4.1 <a href="#电脑使用期限" class="headerlink" title="电脑使用期限"></a>电脑使用期限</h2><p>事实上，一台电脑设备，无论是台式的或是笔记本，只要正常使用，其硬件没有损坏，电脑设备都可以一直运行使用。当然，运行的体验结果如果又是另外一回事了。你总不能拿十几年前的超低配置电脑来装现在最新的系统和大型软件，对吧？而且，兼不兼容都不好说呢！</p><p>电脑最好的<strong>保养方式</strong>，其实是<strong>自己的使用方式</strong>。你使用不佳，再好的设备给你也折腾不了几年。本人维修时遇到过的大多数设备卡顿多是由于个人使用方式导致的，例如机械键盘长期读写却从未整理过磁盘碎片，导致硬盘读取越来越慢，从而导致一些卡顿问题，等等诸如此类的问题。</p><p>只要养成一些好的使用习惯，设备在手中就如同一把利器，工作效率或许都能提高呢。至于有哪些好的使用习惯，这里就不展开阐述，以后有机会专门写一篇来讲讲。</p><h2 id="加速球的认识误区">4.2 <a href="#加速球的认识误区" class="headerlink" title="加速球的认识误区"></a>加速球的认识误区</h2><p>现在电脑系统上装管家、杀软之类的软件已经是很常见，甚至不少是装了全家桶。而在使用电脑时，不少朋友就喜欢时不时点一下加速球。看着它清理完程序后的提示甚是满意。</p><img data-src="/images/service_shop/accelerate_ball.webp" style="width: 200px"><p>且先不谈加速球的效果，我们来了解下它背后的原理。来看看加速球在这背后都做了什么？</p><ol><li>整理内存</li><li>关掉无用程序</li></ol><p>首先来了解下进程的概念。</p><blockquote><p>用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突。进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及I&#x2F;O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。  ---  <a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">维基百科</a></p></blockquote><p>也就是说<strong>关掉无用程序，即是关闭相关进程</strong>。</p><p>众所周知，计算机程序的运行是在内存中进行的。加速球所做的就是关闭进程，将它认为内存中不常用的数据调回到硬盘上。而实际上，当程序又被运行时，系统又会将相关数据加载进内存中。加速球的做法，其实是拖慢了该程序的运行速度。这种腾出内存的做法在某些使用场景中，对于低内存配置的电脑有所帮助，但本质上这是<strong>治标不治本</strong>。</p><p>其实系统本身是有内存管理的，将常用的数据加载到内存中，将不常用的数据释放到硬盘中。<strong>系统不需要额外的内存优化</strong>。如果时常使用加速球，强行介入系统本身的优化机制，反而会导致更多的系统卡死的新问题。（别问我怎么知道的。。。）</p><p>那内存小怎么办？别在加速球上折腾了，要么换合适的系统，要么就升级内存。</p><h1 id="联系我">5 <a href="#联系我" class="headerlink" title="联系我"></a>联系我</h1><p>有意者请咨询店长。<del>现在分享链接到朋友圈，下单还能享受免费系统优化（需截图）。</del></p><div class="note danger no-icon"><p><strong>此外，再次强调，本店视服务要求的复杂度和操作性来确定最终收费。</strong></p></div><h2 id="联系方式">5.1 <a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>店长昵称：Mr. Kin</li><li>QQ：2312463626</li></ul><div class="flex-row-left-start"><div class="flex-column" style="align: left;">QQ二维码<img data-src="/images_public/qq_qr_code2.webp" style="width: 200px"></div></div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;店铺介绍&quot;&gt;1 &lt;a href=&quot;#店铺介绍&quot; class=&quot;headerlink&quot; title=&quot;店铺介绍&quot;&gt;&lt;/a&gt;店铺介绍&lt;/h1&gt;&lt;p&gt;本人开的一个小店，旨在通过远程操作帮助客户解决电脑系统问题。&lt;/p&gt;
&lt;img data-src=&quot;/images/service_shop/shop_logo.webp&quot; style=&quot;width: 500px&quot;&gt;

&lt;h2 id=&quot;为何诞生&quot;&gt;1.1 &lt;a href=&quot;#为何诞生&quot; class=&quot;headerlink&quot; title=&quot;为何诞生?&quot;&gt;&lt;/a&gt;为何诞生?&lt;/h2&gt;&lt;p&gt;许多朋友系统卡顿或者出现无法解决的毛病，想要维修或重装系统，但究于实体维修店太远或是实体店过于昂贵的收费，自己爱机的问题迟迟得不到解决。是的，50块一次的收费甚至更高，确实是贵了。因此，飞助诞生了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="电脑维修" scheme="https://mister-kin.github.io/tags/%E7%94%B5%E8%84%91%E7%BB%B4%E4%BF%AE/"/>
    
    <category term="个人店铺" scheme="https://mister-kin.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%BA%97%E9%93%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://mister-kin.github.io/hello-world/"/>
    <id>https://mister-kin.github.io/hello-world/</id>
    <published>2018-08-12T04:00:00.000Z</published>
    <updated>2018-08-12T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">0.1 <a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post">0.1.1 <a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">0.1.2 <a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">0.1.3 <a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">0.1.4 <a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt;</summary>
        
      
    
    
    
    
  </entry>
  
</feed>
