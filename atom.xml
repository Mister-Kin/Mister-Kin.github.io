<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Kin&#39;s Blog</title>
  <icon>https://mister-kin.github.io/images_public/favicon/Logo.svg</icon>
  <subtitle>计算机知识分享/软件应用讲解</subtitle>
  <link href="https://mister-kin.github.io/atom.xml" rel="self"/>
  
  <link href="https://mister-kin.github.io/"/>
  <updated>2023-10-14T19:43:38.000Z</updated>
  <id>https://mister-kin.github.io/</id>
  
  <author>
    <name>Mr. Kin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QT6 C++开发指南：习题答案</title>
    <link href="https://mister-kin.github.io/code-training/qt6-cpp-development-guide/qt6-cpp-development-guide/"/>
    <id>https://mister-kin.github.io/code-training/qt6-cpp-development-guide/qt6-cpp-development-guide/</id>
    <published>2023-10-14T19:31:49.000Z</published>
    <updated>2023-10-14T19:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>习题代码和总结笔记主要参照视频教程<a href="https://www.bilibili.com/video/BV1km4y1k7CW/">《Qt6 C++开发指南》2023（上册，完整版）</a></em></p><p>练习代码文件的仓库链接：<a href="https://github.com/Mister-Kin/CodeTraining/blob/master/qt6_cpp_development_guide/">点击跳转</a></p><ul><li><a href="/code-training/qt6-cpp-development-guide/chap1/">第一章「认识Qt」习题答案</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;em&gt;习题代码和总结笔记主要参照视频教程&lt;a href=&quot;https://www.bilibili.com/video/BV1km4y1k7CW/&quot;&gt;《Qt6 C++开发指南》2023（上册，完整版）&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;练习代码文件的仓库链接：&lt;a</summary>
        
      
    
    
    
    <category term="code-training" scheme="https://mister-kin.github.io/categories/code-training/"/>
    
    <category term="qt6-cpp-development-guide" scheme="https://mister-kin.github.io/categories/code-training/qt6-cpp-development-guide/"/>
    
    
    <category term="总结" scheme="https://mister-kin.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="qt" scheme="https://mister-kin.github.io/tags/qt/"/>
    
    <category term="C++" scheme="https://mister-kin.github.io/tags/C/"/>
    
    <category term="qt6" scheme="https://mister-kin.github.io/tags/qt6/"/>
    
    <category term="开发" scheme="https://mister-kin.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="第一版" scheme="https://mister-kin.github.io/tags/%E7%AC%AC%E4%B8%80%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>Qt6 C++开发指南：第一章「认识Qt」习题答案</title>
    <link href="https://mister-kin.github.io/code-training/qt6-cpp-development-guide/chap1/"/>
    <id>https://mister-kin.github.io/code-training/qt6-cpp-development-guide/chap1/</id>
    <published>2023-10-14T19:21:37.000Z</published>
    <updated>2023-10-15T18:31:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：认识Qt">1 &nbsp&nbsp<a href="#第一章：认识Qt" class="headerlink" title="第一章：认识Qt"></a>第一章：认识Qt</h1><h2 id="Qt简介">1.1 &nbsp&nbsp<a href="#Qt简介" class="headerlink" title="Qt简介"></a>Qt简介</h2><ul><li>跨平台应用程序开发框架</li><li>首次发布于1995年5月</li><li>qt官网：<a href="http://www.qt.io/">www.qt.io</a></li></ul><h3 id="跨平台开发能力">1.1.1 &nbsp&nbsp<a href="#跨平台开发能力" class="headerlink" title="跨平台开发能力"></a>跨平台开发能力</h3><table><thead><tr><th align="center">目标设备</th><th align="center">目标平台</th><th align="center">主机平台</th></tr></thead><tbody><tr><td align="center"></td><td align="center">桌面Linux</td><td align="center">桌面Linux</td></tr><tr><td align="center">计算机</td><td align="center">macOS</td><td align="center">macOS</td></tr><tr><td align="center"></td><td align="center">Windows</td><td align="center">Windows</td></tr><tr><td align="center"></td><td align="center">Android</td><td align="center">桌面Linux、 macOS、Windows</td></tr><tr><td align="center">移动设备</td><td align="center">iOS</td><td align="center">macOS</td></tr><tr><td align="center"></td><td align="center">手机Windows</td><td align="center">Windows</td></tr><tr><td align="center"></td><td align="center">嵌入式Linux</td><td align="center">桌面Linux</td></tr><tr><td align="center">嵌入式设备</td><td align="center">QNX</td><td align="center">桌面Linux、 Windows</td></tr><tr><td align="center"></td><td align="center">VxWorks</td><td align="center">桌面Linux、 Windows</td></tr><tr><td align="center"></td><td align="center">嵌入式Windows</td><td align="center">Windows</td></tr><tr><td align="center">单片机</td><td align="center">FreeRTOS或无操作系统</td><td align="center">Windows、 桌面Linux</td></tr></tbody></table><p>Qt 源代码编译后生成目标平台的原生二进制代码，不像Java那样需要虚拟机，运行效率更高。</p><h3 id="Qt许可的类型">1.1.2 &nbsp&nbsp<a href="#Qt许可的类型" class="headerlink" title="Qt许可的类型"></a>Qt许可的类型</h3><p>Qt 的许可类型</p><ul><li>商业许可：按年付费。模块更多，开发者可以不公开自己的源码。</li><li>开源许可：<ul><li>GPLv2 &#x2F; GPLv3 许可：使用了 GLP 许可的 Qt 代码允许销售，但必须开源。 GPLv3还要求公开相关硬件信息。</li><li>LGPLv3 许可：与 GPL 类似，但更宽松。若只是链接或调用 GPL 许可协议的 Qt 代码，可以不开源。</li></ul></li></ul><h3 id="安装包">1.1.3 &nbsp&nbsp<a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><p>Qt 安装包：根据目标设备不同，提供了不同的安装包。</p><h3 id="Qt支持的开发语言">1.1.4 &nbsp&nbsp<a href="#Qt支持的开发语言" class="headerlink" title="Qt支持的开发语言"></a>Qt支持的开发语言</h3><ol><li>C++ 和 QML<ul><li>Qt 对标准C++语言进行了扩展，引入了信号与槽等机制。</li><li>QML （ Qt Meta Language） 是一个用来描述应用程序界面的声明式脚本语言。</li><li>C++和QML可以混合使用。</li></ul></li><li>Python<ul><li>Qt C++可以被转换Python绑定，使用 Python 调用 Qt 类库进行GUI程序开发。</li><li>常用的 Qt 类库 Python 绑定有： PyQt （GPLv3 许可）和 PySide （LGPLv3 许可）</li></ul></li></ol><h3 id="Qt6新特性">1.1.5 &nbsp&nbsp<a href="#Qt6新特性" class="headerlink" title="Qt6新特性"></a>Qt6新特性</h3><p>2020 年 12 月正式发布了 Qt6.0 ，引入的主要新特性包括：</p><ul><li>支持 C++ 17 标准。</li><li>Qt 核心库的改动：新的属性和绑定系统；全面支持Unicode 字符串；修改了 QList 的实现方式，将 QVector 类和 QList 类统一为 QList 类； QMetaType 和 QVariant 几乎被重写。</li><li>新的图形架构： Qt5 中 3D 渲染依赖 0penGL。Qt6 中引入了新的技术 RHI （rendering hardware interface），它是一个抽象层，使得 Qt 可以使用平台本地化的 3D 图形 API（Linux：Vulkan 、Windows：Direct 3D、macOS：Metal）。</li><li>CMake 构建系统： Qt6 仍然支持 qmake，但建议使用 CMake。</li><li>其他（多媒体、网络、 Qt Quick 3D 等模块的改进）。</li></ul><h2 id="Qt的安装">1.2 &nbsp&nbsp<a href="#Qt的安装" class="headerlink" title="Qt的安装"></a>Qt的安装</h2><div class="note info no-icon"><p>个人推荐：手动选择组件编译安装Qt。详见<a href="/code/qt/#Qt%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91">Qt源码编译</a>。</p></div><p>自Qt5.1.5起，Qt官方只提供在线安装包。</p><p>官方下载链接：<a href="https://download.qt.io/official_releases/online_installers/">点击跳转</a>。<br>清华镜像下载链接：<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/">点击跳转</a></p><p>本人是从源码编译安装Qt，具体的在线安装步骤不再总结。</p><h2 id="编写一个Hello-World程序">1.3 &nbsp&nbsp<a href="#编写一个Hello-World程序" class="headerlink" title="编写一个Hello World程序"></a>编写一个Hello World程序</h2><p>Qt Creator 简介：</p><ul><li>Qt Creator 为应用程序开发人员提供了一个完整的跨平台、集成开发环境 (IDE) ，以便为桌面、嵌入式和移动设备平台（如 Android 和iOS）创建应用程序。</li><li>Qt Creator 提供了在整个应用程序开发生命周期所需的工具，从创建项目到将应用程序部署到目标平台。</li></ul><p>Qt Creator新建工程的一些总结：</p><ol><li>应用类型：<ul><li>Widgets：widget界面</li><li>Console：控制台程序</li><li>Quick：QML实现的界面</li></ul></li><li>base class基础类：<ul><li>QMainWindow：主窗口类，包括菜单栏、工具栏、状态栏</li><li>QWidget ：可以创建一个空白的窗口，是所有界面组件的基类</li><li>QDialog ：对话框类（比如创建工程弹出的窗口就是对话框类型，对话式窗口，比如下一步按钮继续执行）</li></ul></li><li>翻译文件：i18国际化语言</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;第一章：认识Qt&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#第一章：认识Qt&quot; class=&quot;headerlink&quot; title=&quot;第一章：认识Qt&quot;&gt;&lt;/a&gt;第一章：认识Qt&lt;/h1&gt;&lt;h2 id=&quot;Qt简介&quot;&gt;1.1 &amp;nbsp&amp;nbsp&lt;a</summary>
        
      
    
    
    
    <category term="code-training" scheme="https://mister-kin.github.io/categories/code-training/"/>
    
    <category term="qt6-cpp-development-guide" scheme="https://mister-kin.github.io/categories/code-training/qt6-cpp-development-guide/"/>
    
    
    <category term="总结" scheme="https://mister-kin.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="qt" scheme="https://mister-kin.github.io/tags/qt/"/>
    
    <category term="第一章" scheme="https://mister-kin.github.io/tags/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    
    <category term="qt6" scheme="https://mister-kin.github.io/tags/qt6/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式总结笔记</title>
    <link href="https://mister-kin.github.io/code/regular-expressions/"/>
    <id>https://mister-kin.github.io/code/regular-expressions/</id>
    <published>2023-10-12T19:14:48.000Z</published>
    <updated>2023-10-12T19:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的正则表达式">1 &nbsp&nbsp<a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h1><h1 id="在编辑器中删除空行">2 &nbsp&nbsp<a href="#在编辑器中删除空行" class="headerlink" title="在编辑器中删除空行"></a>在编辑器中删除空行</h1><p>Ctrl+H键，输入<code>^(\s)*$\n</code>，替换为空即可。</p><h1 id="参考文献">3 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;常用的正则表达式&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#常用的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;常用的正则表达式&quot;&gt;&lt;/a&gt;常用的正则表达式&lt;/h1&gt;&lt;h1 id=&quot;在编辑器中删除空行&quot;&gt;2 &amp;nbsp&amp;nbsp&lt;a</summary>
        
      
    
    
    
    <category term="code" scheme="https://mister-kin.github.io/categories/code/"/>
    
    
    <category term="总结" scheme="https://mister-kin.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="笔记" scheme="https://mister-kin.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="正则表达式" scheme="https://mister-kin.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    <category term="正则" scheme="https://mister-kin.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>C语言总结笔记</title>
    <link href="https://mister-kin.github.io/code/c/"/>
    <id>https://mister-kin.github.io/code/c/</id>
    <published>2023-10-12T19:10:03.000Z</published>
    <updated>2023-10-12T19:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语言摘记">1 &nbsp&nbsp<a href="#语言摘记" class="headerlink" title="语言摘记"></a>语言摘记</h1><h2 id="结构体的定义和引用">1.1 &nbsp&nbsp<a href="#结构体的定义和引用" class="headerlink" title="结构体的定义和引用"></a>结构体的定义和引用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">float</span> value;</span><br><span class="line">&#125;adventure;</span><br><span class="line"><span class="comment">// 引用和访问结构体</span></span><br><span class="line">adventrue.value=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体指针的定义和访问</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">book1</span></span></span><br><span class="line"><span class="class"><span class="title">book1</span>=</span>&amp;adventure</span><br><span class="line"><span class="comment">// 引用和访问结构体指针</span></span><br><span class="line">book1-&gt;value=<span class="number">5</span>;</span><br></pre></td></tr></table></figure><h1 id="开发记录">2 &nbsp&nbsp<a href="#开发记录" class="headerlink" title="开发记录"></a>开发记录</h1><h2 id="关于字节的一些记录">2.1 &nbsp&nbsp<a href="#关于字节的一些记录" class="headerlink" title="关于字节的一些记录"></a>关于字节的一些记录</h2><p>int在机器上占一个字长，而32位机器 一个字长就是4Byte，64位机器 一个字长就是8Byte。这里指的是在64位机器上的运行64位操作系统，计算的sizeof(int)。</p><p>这个说法不太正确，gcc编译64bit的程序，sizeof(int)输出为4，即4Byte，32bit。</p><h1 id="参考文献">3 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;语言摘记&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#语言摘记&quot; class=&quot;headerlink&quot; title=&quot;语言摘记&quot;&gt;&lt;/a&gt;语言摘记&lt;/h1&gt;&lt;h2 id=&quot;结构体的定义和引用&quot;&gt;1.1 &amp;nbsp&amp;nbsp&lt;a</summary>
        
      
    
    
    
    <category term="code" scheme="https://mister-kin.github.io/categories/code/"/>
    
    
    <category term="总结" scheme="https://mister-kin.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="笔记" scheme="https://mister-kin.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="c" scheme="https://mister-kin.github.io/tags/c/"/>
    
    <category term="编程" scheme="https://mister-kin.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="语言" scheme="https://mister-kin.github.io/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>css总结笔记</title>
    <link href="https://mister-kin.github.io/code/css/"/>
    <id>https://mister-kin.github.io/code/css/</id>
    <published>2023-10-12T19:07:34.000Z</published>
    <updated>2023-10-12T19:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发记录">1 &nbsp&nbsp<a href="#开发记录" class="headerlink" title="开发记录"></a>开发记录</h1><p>类名含有空格（浏览器F12检查元素）时，一般是包含多个类名，空格字符在类型中无效，实际上呈现出来的是分隔符，不是空格。CSS类名选择器一般选择第一个即可。</p><h1 id="参考文献">2 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;开发记录&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#开发记录&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="code" scheme="https://mister-kin.github.io/categories/code/"/>
    
    
    <category term="总结" scheme="https://mister-kin.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="笔记" scheme="https://mister-kin.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="css" scheme="https://mister-kin.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>PCB设计</title>
    <link href="https://mister-kin.github.io/cad/pcb/"/>
    <id>https://mister-kin.github.io/cad/pcb/</id>
    <published>2023-10-12T15:01:55.000Z</published>
    <updated>2023-10-12T19:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式代码开发">1 &nbsp&nbsp<a href="#嵌入式代码开发" class="headerlink" title="嵌入式代码开发"></a>嵌入式代码开发</h1><h2 id="开发编译器">1.1 &nbsp&nbsp<a href="#开发编译器" class="headerlink" title="开发编译器"></a>开发编译器</h2><p>开源的sdcc编译器，一个优化的ansi-c交叉编译器。</p><h1 id="常见接口引脚定义">2 &nbsp&nbsp<a href="#常见接口引脚定义" class="headerlink" title="常见接口引脚定义"></a>常见接口引脚定义</h1><p>USB协议官网：<a href="https://www.usb.org/">https://www.usb.org/</a></p><p>USB接口种类：<a href="https://zhuanlan.zhihu.com/p/447595295">https://zhuanlan.zhihu.com/p/447595295</a></p><p>常见USB引脚定义：<a href="https://zhuanlan.zhihu.com/p/364748197">https://zhuanlan.zhihu.com/p/364748197</a></p><h2 id="Type-C接口">2.1 &nbsp&nbsp<a href="#Type-C接口" class="headerlink" title="Type-C接口"></a>Type-C接口</h2><p><a href="https://blog.csdn.net/qlexcel/article/details/117431413">https://blog.csdn.net/qlexcel/article/details/117431413</a></p><h2 id="mini-usb接口">2.2 &nbsp&nbsp<a href="#mini-usb接口" class="headerlink" title="mini usb接口"></a>mini usb接口</h2><p><a href="https://blog.csdn.net/eddy_liu/article/details/8316140">https://blog.csdn.net/eddy_liu/article/details/8316140</a></p><table><thead><tr><th>针脚</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>名称</td><td>VCC</td><td>D-</td><td>D+</td><td>id</td><td>GND</td></tr><tr><td>作用</td><td>+5V电压</td><td>数据线负极</td><td>数据线正极</td><td>OTG功能</td><td>接地</td></tr><tr><td>接线颜色</td><td>红色</td><td>白色</td><td>绿色</td><td>&#x2F;</td><td>黑色</td></tr></tbody></table><h2 id="充电DC圆孔">2.3 &nbsp&nbsp<a href="#充电DC圆孔" class="headerlink" title="充电DC圆孔"></a>充电DC圆孔</h2><p>无论是公口或者母口，一般都是内正外负，不仅是5.5大小的，4、3.5、2.5等等的。不过有些厂家是对着干的，比如当年卡西欧和雅马哈电子琴所配的电源。</p><div class="flex-column"><img data-src="/images/cad/dc_pin.webp">DC接口引脚定义</div><h1 id="华硕主板灯控开发">3 &nbsp&nbsp<a href="#华硕主板灯控开发" class="headerlink" title="华硕主板灯控开发"></a>华硕主板灯控开发</h1><ul><li><a href="https://github.com/ProgramAndPoem/AacHal">https://github.com/ProgramAndPoem/AacHal</a></li><li><a href="https://blog.csdn.net/weixin_42349978/article/details/112128924">https://blog.csdn.net/weixin_42349978/article/details/112128924</a></li></ul><h1 id="锂电池">4 &nbsp&nbsp<a href="#锂电池" class="headerlink" title="锂电池"></a>锂电池</h1><p>串并联符号：串联s，并联p。3s1p：三串一并，一并实际就是没有并联。比如1s1p就是单一电池。</p><p>串联增压，并联增容。</p><h1 id="参考文献">5 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;嵌入式代码开发&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#嵌入式代码开发&quot; class=&quot;headerlink&quot; title=&quot;嵌入式代码开发&quot;&gt;&lt;/a&gt;嵌入式代码开发&lt;/h1&gt;&lt;h2 id=&quot;开发编译器&quot;&gt;1.1 &amp;nbsp&amp;nbsp&lt;a</summary>
        
      
    
    
    
    <category term="cad" scheme="https://mister-kin.github.io/categories/cad/"/>
    
    
    <category term="PCB" scheme="https://mister-kin.github.io/tags/PCB/"/>
    
    <category term="电路" scheme="https://mister-kin.github.io/tags/%E7%94%B5%E8%B7%AF/"/>
    
    <category term="设计" scheme="https://mister-kin.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>电路仿真设计</title>
    <link href="https://mister-kin.github.io/cad/simulation/"/>
    <id>https://mister-kin.github.io/cad/simulation/</id>
    <published>2023-10-12T15:01:29.000Z</published>
    <updated>2023-10-12T19:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Proteus仿真">1 &nbsp&nbsp<a href="#Proteus仿真" class="headerlink" title="Proteus仿真"></a>Proteus仿真</h1><h2 id="仿真时时间流动过慢">1.1 &nbsp&nbsp<a href="#仿真时时间流动过慢" class="headerlink" title="仿真时时间流动过慢"></a>仿真时时间流动过慢</h2><p>可能存在的原因：</p><ul><li>计算机性能不够，导致运行proteus仿真过慢</li><li>proteus内设置的晶振频率和keil源码编译时设置的晶振频率不同</li></ul><h1 id="参考文献">2 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] proteus 8 仿真时 时间流动过慢的解决方案[EB&#x2F;OL]. <a href="https://blog.csdn.net/weixin_44176696/article/details/106875850">https://blog.csdn.net/weixin_44176696/article/details/106875850</a>.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Proteus仿真&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#Proteus仿真&quot; class=&quot;headerlink&quot; title=&quot;Proteus仿真&quot;&gt;&lt;/a&gt;Proteus仿真&lt;/h1&gt;&lt;h2 id=&quot;仿真时时间流动过慢&quot;&gt;1.1</summary>
        
      
    
    
    
    <category term="cad" scheme="https://mister-kin.github.io/categories/cad/"/>
    
    
    <category term="电路" scheme="https://mister-kin.github.io/tags/%E7%94%B5%E8%B7%AF/"/>
    
    <category term="仿真" scheme="https://mister-kin.github.io/tags/%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Perforce Helix Core版本控制</title>
    <link href="https://mister-kin.github.io/software/perforce/"/>
    <id>https://mister-kin.github.io/software/perforce/</id>
    <published>2023-10-12T14:41:58.000Z</published>
    <updated>2023-10-12T19:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介">1 &nbsp&nbsp<a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>git和svn适合管理文本类的代码文件，perforce更适合管理像游戏资产3D模型、psd图像文件等的大型文件。</p><h1 id="安装">2 &nbsp&nbsp<a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>官网下载：<a href="https://www.perforce.com/products">点击跳转</a></p><h1 id="参考文献">3 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="software" scheme="https://mister-kin.github.io/categories/software/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机总结</title>
    <link href="https://mister-kin.github.io/software/virtual-machine/"/>
    <id>https://mister-kin.github.io/software/virtual-machine/</id>
    <published>2023-09-26T06:48:05.000Z</published>
    <updated>2023-11-21T17:50:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VirtualBox">1 &nbsp&nbsp<a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h1><h2 id="VirtualBox-NAT网卡端口转发实现连接ssh">1.1 &nbsp&nbsp<a href="#VirtualBox-NAT网卡端口转发实现连接ssh" class="headerlink" title="VirtualBox NAT网卡端口转发实现连接ssh"></a>VirtualBox NAT网卡端口转发实现连接ssh</h2><p>打开vbox虚拟机的设置-&gt;网络-&gt;高级-&gt;端口转发-&gt;新建规则：名称ssh，协议TCP，主机IP127.0.0.1，主机端口9191，子系统IP留空不填，子系统端口22。</p><h2 id="VirtualBox安装ubuntu-18-04虚拟机打不开terminal终端">1.2 &nbsp&nbsp<a href="#VirtualBox安装ubuntu-18-04虚拟机打不开terminal终端" class="headerlink" title="VirtualBox安装ubuntu 18.04虚拟机打不开terminal终端"></a>VirtualBox安装ubuntu 18.04虚拟机打不开terminal终端</h2><p>故障情况：VirtualBox新安装ubuntu 18.04虚拟机无法打开Terminal，从应用列表中单击Terminal，左上角任务栏会出现Terminal，并且鼠标转圈，但是过一会左上角Terminal消失，就像闪退一样。</p><p>解决方法：CTRL + ALT + F3 进入命令行模式（需要返回桌面时CTRL + ALT + F1）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/default</span><br><span class="line">sudo nano locale</span><br><span class="line"><span class="comment"># 把文件中的 “en_US” 改成 “en_US.UTF-8”</span></span><br><span class="line">sudo locale-gen --purge</span><br><span class="line">reboot <span class="comment">#重启虚拟机</span></span><br></pre></td></tr></table></figure><h2 id="无法删除备份">1.3 &nbsp&nbsp<a href="#无法删除备份" class="headerlink" title="无法删除备份"></a>无法删除备份</h2><p>故障情况：删除备份时报错提示hard disk xxxx has more than one child hard disk 2。</p><p>解决方式：打开虚拟介质管理器，定位到虚拟硬盘页面，找到对应的硬盘，双击展开可以查看有一个子项目是不存在，失效导致删除备份失败，删除即可。</p><h1 id="VMware">2 &nbsp&nbsp<a href="#VMware" class="headerlink" title="VMware"></a>VMware</h1><h1 id="参考文献">3 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] VirtualBox_Ubuntu22.04 Terminal 无法打开[EB&#x2F;OL]. <a href="https://www.cnblogs.com/lifuqiang/articles/17167367.html">https://www.cnblogs.com/lifuqiang/articles/17167367.html</a>.<br>[2] VirtualBox下SSH通过端口转发连接Linux方法[EB&#x2F;OL]. <a href="https://blog.csdn.net/chengqiuming/article/details/83239413">https://blog.csdn.net/chengqiuming/article/details/83239413</a>.<br>[3]  [已解决] 为什么VBOX有些备份会删除失败？[EB&#x2F;OL]. <a href="https://bbs.kafan.cn/thread-939721-1-1.html">https://bbs.kafan.cn/thread-939721-1-1.html</a>.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;VirtualBox&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#VirtualBox&quot; class=&quot;headerlink&quot; title=&quot;VirtualBox&quot;&gt;&lt;/a&gt;VirtualBox&lt;/h1&gt;&lt;h2</summary>
        
      
    
    
    
    <category term="software" scheme="https://mister-kin.github.io/categories/software/"/>
    
    
  </entry>
  
  <entry>
    <title>服务器</title>
    <link href="https://mister-kin.github.io/software/server/"/>
    <id>https://mister-kin.github.io/software/server/</id>
    <published>2023-09-25T15:55:30.000Z</published>
    <updated>2023-10-02T07:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云服务器">1 &nbsp&nbsp<a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><h2 id="取回过期未释放的阿里云服务器数据">1.1 &nbsp&nbsp<a href="#取回过期未释放的阿里云服务器数据" class="headerlink" title="取回过期未释放的阿里云服务器数据"></a>取回过期未释放的阿里云服务器数据</h2><p>取回方法：</p><ul><li>继续续费使用服务器</li><li>购买新的阿里云服务器或者转移到其他阿里云服务器</li><li>保存快照制作成镜像再上传到oss下载</li></ul><p>Linux云服务器可以通过制作镜像上传到oss下载。</p><ol><li>在轻量级应用服务器的管理页面创建一个快照。</li><li>创建自定义镜像：输入自定义的镜像描述和名称后点击确定。</li><li>创建好的镜像共享到ecs</li><li>阿里云控制台里进入ecs-&gt;选择镜像-&gt;选择共享镜像即可看见刚刚共享的轻量级服务器镜像。点击操作列上的复制镜像，填入信息后点击确定。</li><li>导出镜像：复制成功后就可以在自定义镜像列表看见镜像，选择操作列上的导出镜像，填入你的oss信息。oss创建过程大概就是开通oss服务再创建bucket，需注意创建bucket时地域需要和镜像所在地域一致。</li><li>下载镜像：在控制台进入oss-&gt;进入bucket列表，选择你刚刚导出镜像的bucket-&gt;进入文件管理页面即可看见导出的镜像，点击下载即可。这里会消耗oss流量，大约会花费几块钱费用。</li><li>本地虚拟机软件运行镜像。</li></ol><p>Windows云服务器：由于不支持导出Windows和来自镜像市场的镜像。因此无法导出上传到oss再下载。处理方法步骤是也和Linux云服务器一样，但在导出镜像步骤中，因为无法导出。可以选择操作列上的「创建实例」功能）——即按量付费购买一台esc。然后选按量付费，充值100块钱。快速备份好数据，再退订释放购买esc，等待退款（过程就看使用时长，越短时间花费越少，不到半个小时大概两三毛钱）。</p><h1 id="参考文献">2 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] 取回过期未释放的阿里云服务器数据[EB&#x2F;OL]. <a href="https://www.lushihuan.com/archives/%E5%8F%96%E5%9B%9E%E8%BF%87%E6%9C%9F%E6%9C%AA%E9%87%8A%E6%94%BE%E7%9A%84%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E6%8D%AE">https://www.lushihuan.com/archives/%E5%8F%96%E5%9B%9E%E8%BF%87%E6%9C%9F%E6%9C%AA%E9%87%8A%E6%94%BE%E7%9A%84%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E6%8D%AE</a>.<br>[2] 取回阿里云过期未释放服务器数据 Windows 系统[EB&#x2F;OL]. <a href="https://www.bilibili.com/read/cv13853339/">https://www.bilibili.com/read/cv13853339/</a>.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;云服务器&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#云服务器&quot; class=&quot;headerlink&quot; title=&quot;云服务器&quot;&gt;&lt;/a&gt;云服务器&lt;/h1&gt;&lt;h2 id=&quot;取回过期未释放的阿里云服务器数据&quot;&gt;1.1 &amp;nbsp&amp;nbsp&lt;a</summary>
        
      
    
    
    
    <category term="software" scheme="https://mister-kin.github.io/categories/software/"/>
    
    
  </entry>
  
  <entry>
    <title>英伟达Jetson开发板踩坑记录总结</title>
    <link href="https://mister-kin.github.io/software/nvidia-jetson/"/>
    <id>https://mister-kin.github.io/software/nvidia-jetson/</id>
    <published>2023-09-22T20:19:03.000Z</published>
    <updated>2023-10-14T18:20:17.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note "><p>文章推荐：<a href="https://www.guyuehome.com/42097">Jetson nano 系统安装</a></p></div><div class="note danger no-icon"><p>本文绝大部分命令都是在<code>sudo -i</code>切换到root权限后操作的。</p></div><h1 id="测试项目">1 &nbsp&nbsp<a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h1><ul><li>人体骨架检测：<a href="https://github.com/facebookresearch/VideoPose3D">VideoPose3d</a></li><li>安卓版人体骨架检测，支持网络摄像头<a href="https://github.com/serviceberry3/videopose3d_android">videopose3d_android</a></li><li>人体骨架检测（多人追踪版）：<a href="https://github.com/LynnZhang9/VideoPose3D-for-multi-person-tracking">VideoPose3D-for-multi-person-tracking</a></li><li>谷歌的人体骨架检测：<a href="https://github.com/michellelychan/posenet-pytorch">posenet-pytorch</a></li><li>人脸年龄修改：<a href="https://github.com/InterDigitalInc/HRFAE">HRFAE</a></li></ul><h1 id="VideoPose3d">2 &nbsp&nbsp<a href="#VideoPose3d" class="headerlink" title="VideoPose3d"></a>VideoPose3d</h1><ul><li>Human3.6M数据集下载：<a href="https://zhuanlan.zhihu.com/p/425608868">Human3.6M全部数据集</a>和Human3.6M部分数据集</li></ul><h2 id="训练推理自定义视频">2.1 &nbsp&nbsp<a href="#训练推理自定义视频" class="headerlink" title="训练推理自定义视频"></a>训练推理自定义视频</h2><p>设置过程参见：<a href="https://github.com/facebookresearch/VideoPose3D/blob/main/INFERENCE.md">Inference in the wild</a></p><h3 id="安装ffmpeg">2.1.1 &nbsp&nbsp<a href="#安装ffmpeg" class="headerlink" title="安装ffmpeg"></a>安装ffmpeg</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ffmpeg</span><br></pre></td></tr></table></figure><h3 id="安装detectron2">2.1.2 &nbsp&nbsp<a href="#安装detectron2" class="headerlink" title="安装detectron2"></a>安装detectron2</h3><div class="note danger no-icon"><p><a href="https://detectron2.readthedocs.io/en/latest/tutorials/install.html#install-pre-built-detectron2-linux-only">官方提供的whl安装包</a>并没有arm架构，因此需手动从源码构建安装。</p><p>也不要用命令安装最新版的detectron2：<code>python -m pip install &#39;git+https://github.com/facebookresearch/detectron2.git&#39;</code>，因为新版detectron2要求python3.8版本。问题参见：<a href="https://github.com/facebookresearch/detectron2/issues/4910">Cannot import name &#39;cached_property&#39;</a></p></div><p>配置流程参照：<a href="https://detectron2.readthedocs.io/en/latest/tutorials/install.html">Installation</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方案1：直接pip安装</span></span><br><span class="line"><span class="comment"># 指定特定commit，安装适合python3.7的版本</span></span><br><span class="line">pip3.7 install <span class="string">&#x27;git+https://github.com/facebookresearch/detectron2.git@d779ea63faa54fe42b9b4c280365eaafccb280d6&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方案2：手动从源码构建安装</span></span><br><span class="line"><span class="comment"># 如果网络不佳，直接访问网页下载压缩包：https://github.com/facebookresearch/detectron2/tree/d779ea63faa54fe42b9b4c280365eaafccb280d6</span></span><br><span class="line"><span class="comment"># zip包链接：https://github.com/facebookresearch/detectron2/archive/d779ea63faa54fe42b9b4c280365eaafccb280d6.zip</span></span><br><span class="line">git <span class="built_in">clone</span> -b d779ea63faa54fe42b9b4c280365eaafccb280d6 https://github.com/facebookresearch/detectron2.git</span><br><span class="line">python3.7 -m pip install -e detectron2</span><br></pre></td></tr></table></figure><h3 id="下载预训练模型">2.1.3 &nbsp&nbsp<a href="#下载预训练模型" class="headerlink" title="下载预训练模型"></a>下载预训练模型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果VideoPose3D目录下没有checkpoint文件夹的话，先mkdir checkpoint</span></span><br><span class="line"><span class="built_in">cd</span> checkpoint</span><br><span class="line">wget https://dl.fbaipublicfiles.com/video-pose-3d/pretrained_h36m_detectron_coco.bin</span><br></pre></td></tr></table></figure><h3 id="推理2D关键点">2.1.4 &nbsp&nbsp<a href="#推理2D关键点" class="headerlink" title="推理2D关键点"></a>推理2D关键点</h3><ol><li>在 inference 文件夹中新建两个文件夹 input_directory 和 output_directory，input_directory用来存放需要处理的自定义视频，output_directory用来存放程序生成的每个视频的2D关键点数据文件，后缀名是.npz。</li><li>将需要处理自定义视频放入VideoPose3D&#x2F;inference&#x2F;input_directory&#x2F;中，切记需要先放放入视频后再执行后面的命令。若不提前放入视频，最后执行run.py是会出现报错：keyError:output.mp4。其中「推理2D关键点」步骤中不会有ffmpeg相关视频处理的日志输出，「创建自定义数据集」步骤中不会显示出处理了xxx.npz文件和处理了多少帧frame，只输出saving和done这两句简单的日志，并且这种情况在data目录中生成data_2d_custom_myvideos.npz的数据集文件只有798字节，不到1KB的大小，属于无效文件。</li><li>执行命令推理2D关键点<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> inference</span><br><span class="line">python3.7 infer_video_d2.py \</span><br><span class="line">    --cfg COCO-Keypoints/keypoint_rcnn_R_101_FPN_3x.yaml \</span><br><span class="line">    --output-dir output_directory \</span><br><span class="line">    --image-ext mp4 \</span><br><span class="line">    input_directory</span><br></pre></td></tr></table></figure></li><li>创建自定义数据集：程序根据VideoPose3D&#x2F;inference&#x2F;output_directory&#x2F;的每个视频的2D关键点数据文件.npz，在data目录下生成自定义的data_2d_custom_myvideos.npz文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> data</span><br><span class="line">python3.7 prepare_data_2d_custom.py -i /home/nvidia/VideoPose3D/inference/output_directory/ -o myvideos</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure></li><li>渲染自定义视频并导出坐标：output.mp4是在VideoPose3D根目录下，不是inference&#x2F;output_directory&#x2F;。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3.7 run.py -d custom -k myvideos -arc 3,3,3,3,3 -c checkpoint --evaluate pretrained_h36m_detectron_coco.bin --render --viz-subject test_video.mp4 --viz-action custom --viz-camera 0 --viz-video /home/nvidia/VideoPose3D/inference/input_directory/test_video.mp4 --viz-output output.mp4 --viz-size 6</span><br><span class="line"><span class="comment"># 下面输入视频路径是绝对路径</span></span><br><span class="line"><span class="comment"># python3.7 run.py -d custom -k myvideos -arc 3,3,3,3,3 -c checkpoint --evaluate pretrained_h36m_detectron_coco.bin --render --viz-subject test_video.mp4 --viz-action custom --viz-camera 0 --viz-video /home/nvidia/VideoPose3D/inference/input_directory/test_video.mp4 --viz-output output.mp4 --viz-size 6</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="训练推理h36m视频">2.2 &nbsp&nbsp<a href="#训练推理h36m视频" class="headerlink" title="训练推理h36m视频"></a>训练推理h36m视频</h2><p>数据集设置步骤参考：<a href="https://github.com/facebookresearch/VideoPose3D/blob/main/DATASETS.md#2d-detections-for-human36m">Dataset setup</a></p><ol><li>准备数据文件：在data目录下新建h36m文件夹，传入3d数据集的压缩包，目录结构图如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data/</span><br><span class="line">  └── h36m/</span><br><span class="line">    ├── Poses_D3_Positions_S1.tgz</span><br><span class="line">    ├── Poses_D3_Positions_S5.tgz</span><br><span class="line">    ├── Poses_D3_Positions_S6.tgz</span><br><span class="line">    ├── Poses_D3_Positions_S7.tgz</span><br><span class="line">    ├── Poses_D3_Positions_S8.tgz</span><br><span class="line">    ├── Poses_D3_Positions_S9.tgz</span><br><span class="line">    └── Poses_D3_Positions_S11.tgz</span><br></pre></td></tr></table></figure></li><li>数据处理<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压数据集：</span></span><br><span class="line"><span class="built_in">cd</span> /home/nvidia/data/h36m/</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *.tgz; <span class="keyword">do</span> tar -xvzf <span class="variable">$file</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/nvidia/data</span><br><span class="line">pip3.7 install cdflib</span><br><span class="line">python3.7 prepare_data_h36m.py --from-source-cdf /home/nvidia/data/h36m/</span><br><span class="line"><span class="comment"># 运行成功后，data目录下生成两个文件：data_3d_h36m.npz和data_2d_h36m_gt.npz。</span></span><br></pre></td></tr></table></figure></li><li>下载预训练模型<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> checkpoint</span><br><span class="line"><span class="built_in">cd</span> checkpoint</span><br><span class="line">wget https://dl.fbaipublicfiles.com/video-pose-3d/pretrained_h36m_cpn.bin</span><br><span class="line">wget https://dl.fbaipublicfiles.com/video-pose-3d/pretrained_humaneva15_detectron.bin</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure></li><li>测试Human3.6M模型数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python run.py -k cpn_ft_h36m_dbb -arc 3,3,3,3,3 -c checkpoint --evaluate pretrained_h36m_cpn.bin</span><br></pre></td></tr></table></figure></li></ol><h1 id="HRFAE">3 &nbsp&nbsp<a href="#HRFAE" class="headerlink" title="HRFAE"></a>HRFAE</h1><p>官方要求的依赖库（注意torch需要是cuda版本的，因为源码是使用cuda设备的方法）</p><ul><li>Python 3.7</li><li>Pytorch 1.1</li><li>Numpy</li><li>Opencv</li><li>TensorboardX</li><li>Tensorboard_logger</li></ul><p>别人测试成功的依赖库版本：参见<a href="https://blog.csdn.net/qq_52179028/article/details/127397877">成功运行HRFAE面部年龄编辑</a></p><ul><li>Python 3.7.13</li><li>Pytorch 1.10.2</li><li>Numpy 1.21.5</li><li>Opencv 4.6.0</li><li>Tensorboard 1.14.0</li><li>TensorboardX</li><li>Tensorboard-logger</li></ul><h2 id="预训练模型的配置步骤">3.1 &nbsp&nbsp<a href="#预训练模型的配置步骤" class="headerlink" title="预训练模型的配置步骤"></a>预训练模型的配置步骤</h2><ol><li>安装依赖库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3.7 install TensorboardX Tensorboard_logger</span><br></pre></td></tr></table></figure></li><li>修改test.py代码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> HRFAE</span><br><span class="line">nano test.py</span><br><span class="line"><span class="comment"># 找到下面该行代码，将load函数，改成safe_load或者full_load</span></span><br><span class="line"><span class="comment"># config = yaml.load(open(&#x27;./configs/&#x27; + opts.config + &#x27;.yaml&#x27;, &#x27;r&#x27;))</span></span><br></pre></td></tr></table></figure></li><li>下载预训练模型<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 科学网络条件好的，可以直接参考官方命令下载checkpoint</span></span><br><span class="line"><span class="built_in">cd</span> ./logs/001</span><br><span class="line">./download.sh</span><br><span class="line"><span class="comment"># 如果网络条件不行的话，直接使用链接下载后在传入logs目录，注意上传后记得修改属性权限755或者777</span></span><br><span class="line"><span class="comment"># https://partage.imt.fr/index.php/s/7DzqFHQggfJDw79/download</span></span><br></pre></td></tr></table></figure></li><li>运行命令生成结果<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> HRFAE</span><br><span class="line"><span class="comment"># 年龄区间：20-70</span></span><br><span class="line">python3.7 test.py --config 001 --target_age 40</span><br></pre></td></tr></table></figure></li></ol><h2 id="进程被Killed的故障排查">3.2 &nbsp&nbsp<a href="#进程被Killed的故障排查" class="headerlink" title="进程被Killed的故障排查"></a>进程被Killed的故障排查</h2><p>现象：终端输出一句「Killed」后，进程就闪退退出了。</p><p>原因：这是由于pytroch程序占用过多内存，引起系统OOM（Out of memory）机制。</p><p>解决方式：无。在我的尝试方法中，尝试了增加虚拟内存的大小至13GB，仍然是无法解决，依然是触发OOM了（即使我对pytorch进程禁用系统OOM killer，并观察内存占用情况，物理4GB全部吃满，虚拟内存zram占用到3.6GB后就整个系统卡死了）。推测可能还因为显存不足。</p><p>内存管理的相关命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看虚拟内存使用分配机制，vm.swappiness = 0：最大限度使用物理内存，vm.swappiness = 100：积极的使用交换空间</span></span><br><span class="line">sysctl -a| grep vm.swappiness</span><br><span class="line"><span class="comment"># vm.swappiness = 60</span></span><br><span class="line"><span class="comment"># 临时设置swappiness</span></span><br><span class="line"><span class="built_in">echo</span> 10 &gt; /proc/sys/vm/swappiness</span><br><span class="line"><span class="comment"># 查看内存使用率高的进程id</span></span><br><span class="line">top</span><br><span class="line"><span class="comment"># 对某个进程禁用系统OOM killer，$PID替换为进程ID数字即可</span></span><br><span class="line"><span class="built_in">echo</span> -17 &gt; /proc/<span class="variable">$PID</span>/oom_adj</span><br></pre></td></tr></table></figure><p>查看系统是否主动杀掉进程的日志排查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统内核日志中最后7行</span></span><br><span class="line">sudo dmesg | <span class="built_in">tail</span> -7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过以下三种命令查看系统是否主动杀死程序进程</span></span><br><span class="line"><span class="comment"># 将dmesg命令的输出通过管道传递给egrep命令进行过滤。egrep命令使用正则表达式&#x27;killed process&#x27;来匹配包含&quot;killed process&quot;的行，并且使用-i选项忽略大小写。-B100选项会在匹配到的行之前显示100行的上下文。</span></span><br><span class="line">dmesg | egrep -i -B100 <span class="string">&#x27;killed process&#x27;</span></span><br><span class="line"><span class="comment"># 在/var/log/messages文件中搜索包含&quot;killed process&quot;的行，并且使用-i选项忽略大小写</span></span><br><span class="line">egrep -i <span class="string">&#x27;killed process&#x27;</span> /var/log/messages</span><br><span class="line"><span class="comment"># 在/var/log目录及其子目录下递归地搜索包含&quot;killed process&quot;的行，并且使用-i选项忽略大小写</span></span><br><span class="line">egrep -i -r <span class="string">&#x27;killed process&#x27;</span> /var/log</span><br><span class="line"><span class="comment"># 将journalctl -xb命令的输出通过管道传递给egrep命令进行过滤。journalctl -xb命令用于查看系统启动时的日志，并且使用-i选项忽略大小写</span></span><br><span class="line">journalctl -xb | egrep -i <span class="string">&#x27;killed process&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果未发现/var/log/messages文件，编辑50-default.conf文件，取消注释一行内容</span></span><br><span class="line">nano /etc/rsyslog.d/50-default.conf</span><br><span class="line"><span class="comment">#       mail,news.none          -/var/log/messages</span></span><br></pre></td></tr></table></figure><h2 id="自训练模型的配置步骤">3.3 &nbsp&nbsp<a href="#自训练模型的配置步骤" class="headerlink" title="自训练模型的配置步骤"></a>自训练模型的配置步骤</h2><h2 id="Windows-x86版环境搭建">3.4 &nbsp&nbsp<a href="#Windows-x86版环境搭建" class="headerlink" title="Windows x86版环境搭建"></a>Windows x86版环境搭建</h2><ol><li>安装miniconda3：<a href="https://docs.conda.io/projects/miniconda/en/latest/">跳转下载</a></li><li>创建并切换新的虚拟环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n hrfae python=3.7</span><br><span class="line">conda activate hrfae</span><br></pre></td></tr></table></figure></li><li>先下载并安装torch和torchvision的cuda版whl（建议先关闭科学上网，避免浪费科学上网的流量），使用<code>pip install</code>即可：<a href="https://download.pytorch.org/whl/cu117/torch-1.13.1%2Bcu117-cp37-cp37m-win_amd64.whl">torch-1.13.1+cu117-cp37-cp37m-win_amd64.whl</a>和<a href="https://download.pytorch.org/whl/cu117/torchvision-0.14.1%2Bcu117-cp37-cp37m-win_amd64.whl">torchvision-0.14.1+cu117-cp37-cp37m-win_amd64.whl</a>。别使用<code>conda install torch</code>安装torch，否则易出现一些版本依赖的问题。例如：<code>解决python urllib3 v2.0 only supports OpenSSL 1.1.1+, currently</code>。这是因为openSSL版本太低，可以安装低版本解决：<code>pip install urllib3==1.23 -i https://pypi.tuna.tsinghua.edu.cn/simple</code>。</li><li>之后一一安装其他库，如果<code>conda install</code>找不到库，就使用<code>pip install</code>，例如<code>Tensorboard-logger</code>。</li></ol><h1 id="硬件型号">4 &nbsp&nbsp<a href="#硬件型号" class="headerlink" title="硬件型号"></a>硬件型号</h1><p>NVIDIA Jetson TX2 NX，16GB eMMC，额外挂载一个120G的固态盘。</p><h1 id="烧录系统">5 &nbsp&nbsp<a href="#烧录系统" class="headerlink" title="烧录系统"></a>烧录系统</h1><h2 id="烧录前准备">5.1 &nbsp&nbsp<a href="#烧录前准备" class="headerlink" title="烧录前准备"></a>烧录前准备</h2><ul><li>一台Ubuntu 18.00 LTS系统的PC（其他的jetson设备不能作为刷机主机，必须用ubuntu电脑。也不能用vbox或者vmware之类的虚拟机创建ubuntu刷机主机，因为虚拟机系统无法处理usb等底层的驱动，这会导致刷机时一直提示未正确进入刷机模式，但实际机器已经真正进入到刷机模式的）</li><li>一条micro-usb数据线</li><li>根据硬件型号选择<a href="https://developer.nvidia.com/embedded/jetson-linux-archive">对应版本</a>的<a href="https://developer.nvidia.com/downloads/embedded/l4t/r32_release_v7.4/t186/jetson_linux_r32.7.4_aarch64.tbz2">驱动包（BSP包）</a>和<a href="https://developer.nvidia.com/downloads/embedded/l4t/r32_release_v7.4/t186/tegra_linux_sample-root-filesystem_r32.7.4_aarch64.tbz2">示例根文件系统</a>（目前适配TX2 NX的最新版为<a href="https://developer.nvidia.com/embedded/linux-tegra-r3274">R32.7.4</a>）。</li></ul><h2 id="烧录步骤">5.2 &nbsp&nbsp<a href="#烧录步骤" class="headerlink" title="烧录步骤"></a>烧录步骤</h2><ol><li>在刷机主机ubuntu系统中启用ssh。</li><li>通过<a href="https://winscp.net/eng/download.php">WinSCP</a>将驱动包（BSP包）和示例根文件系统复制至刷机主机系统中的家目录<code>/home</code>。</li><li>刷机命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装必要库</span></span><br><span class="line">sudo apt-get install qemu-user-static</span><br><span class="line">sudo apt-get install python</span><br><span class="line"><span class="comment"># j为使用bzip2算法，x为解压，v为显示操作的详细信息，f为指定操作的文件</span></span><br><span class="line">sudo tar -jxvf Jetson_Linux_R32.7.4_aarch64.tbz2</span><br><span class="line"><span class="built_in">cd</span> Linux_for_Tegra/rootfs</span><br><span class="line"><span class="comment"># p为于保留文件的权限和属性，即保持原有文件的权限模式和时间戳信息</span></span><br><span class="line">sudo tar -jxpf ../../Tegra_Linux_Sample-Root-Filesystem_R32.7.4_aarch64.tbz2</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment"># 拷贝NVIDIA库文件到文件系统</span></span><br><span class="line">sudo ./apply_binaries.sh</span><br><span class="line"><span class="built_in">cd</span> Linux_for_Tegra/tools</span><br><span class="line"><span class="comment"># u为用户名，p为密码</span></span><br><span class="line">sudo ./l4t_create_default_user.sh -u nvidia -p nvidia</span><br><span class="line"><span class="comment"># NVIDIA Jetson是通过Micro USB接口烧录系统。Recovery模式下可以进行文件系统更新包含：内核Kernel，启动Bootloader，文件系统Rootfs等。</span></span><br><span class="line"><span class="comment"># 进入Recovery模式的步骤：</span></span><br><span class="line"><span class="comment"># 1）使用Micro USB 的数据线连接Jetson和Ubuntu Host主机(一端插在开发板的OTG口,一端插在Ubuntu Host主机的usb插口)；</span></span><br><span class="line"><span class="comment"># 2）连接开发板的电源;</span></span><br><span class="line"><span class="comment"># 3) 按住RECOVERY按键，同时按下RESET复位按键1-2秒后释放，等待3秒释放RECOVERY按键，此时开发板进入Recovery刷机模式 （可通过在Ubuntu Host主机上运行命令：lsusb查看是否有Nvidia Corporation 设备（不同Jetson模块USB VID/PID 不同）来确认是否进入正常）</span></span><br><span class="line"><span class="comment"># 执行刷机命令</span></span><br><span class="line"><span class="built_in">cd</span> Linux_for_Tegra</span><br><span class="line">sudo ./flash.sh jetson-xavier-nx-devkit-tx2-nx mmcblk0p1</span><br></pre></td></tr></table></figure></li></ol><h2 id="烧录后无法进入到桌面环境">5.3 &nbsp&nbsp<a href="#烧录后无法进入到桌面环境" class="headerlink" title="烧录后无法进入到桌面环境"></a>烧录后无法进入到桌面环境</h2><p>Jetson报错无法进到桌面环境： Failed to start nvpmode1 server. 和Failed to start load kernel modules</p><p>无桌面环境的条件下进入到终端操作的两种方式：</p><ul><li>ssh连接虚拟ip：jetson的usb有虚拟ip，可以通过ssh远程连接，用上位机通过USB数据线（有的USB线不能传数据只能充电，因为只有电源线和地线）连接jetson。打开上位机远程登陆开发板，登陆ip为：192.168.55.1：<code>ssh nvidia@192.168.55.1</code></li><li>按ctrl+alt+F1-F6等组合键切换命令窗口1-6</li></ul><p>Failed to start nvpmode1 server一般是桌面环境出问题引起的，重装桌面环境即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nvidia-l4t-x11</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>Failed to start load kernel modules一般配置方面出问题，重新运行更新配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到root模式，并保留当前终端环境</span></span><br><span class="line">sudo -i</span><br><span class="line">apt-get update</span><br><span class="line">dpkg --configure -a</span><br><span class="line">apt-get dist-upgrade</span><br><span class="line">apt-get -f install</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="为TX2-NX这种老硬件安装Ubuntu-20-04">5.4 &nbsp&nbsp<a href="#为TX2-NX这种老硬件安装Ubuntu-20-04" class="headerlink" title="为TX2 NX这种老硬件安装Ubuntu 20.04"></a>为TX2 NX这种老硬件安装Ubuntu 20.04</h2><p>为Jetson TX2 NX或者Jetson Nano这种老硬件安装Ubuntu 20.04（官方最新只支持Ubuntu 18.04）的两种方式：</p><ul><li>使用社区提供的三方系统ubuntu 20.04：<a href="https://qengineering.eu/install-pytorch-on-jetson-nano.html">Install PyTorch on Jetson Nano</a>和<a href="https://github.com/Qengineering/Jetson-Nano-Ubuntu-20-image">Jetson-Nano-Ubuntu-20-image</a>。这种方式需要烧录到SD卡，并且系统解压后高达19.1GB，建议是准备一个64GB容量的SD卡，即TF卡。</li><li>设置软件源更新（我尝试过按官方升级的方式修改源，并未成功，估计是连20.04也太老了）：<a href="https://www.guyuehome.com/36629">Jetson Nano 系统升级至Ubuntu 20.04</a></li></ul><h1 id="为开发板设置SSD固态为系统盘">6 &nbsp&nbsp<a href="#为开发板设置SSD固态为系统盘" class="headerlink" title="为开发板设置SSD固态为系统盘"></a>为开发板设置SSD固态为系统盘</h1><p>NVMe SSD固态硬盘仅作为系统盘（rootfs和用户区），系统的启动引导依然是通过SD卡或者内置EMMC的存储，比如升级设备树dtb仍然是在SD卡或者EMMC中。</p><ol><li>格式化硬盘：打开软件列表搜索disk，打开ubuntu自带的Disks工具，选择识别到的SSD，按Ctrl+F对硬盘进行快速格式化，点击Format（不覆盖已存在的数据），点击Format（只是弹窗查看确认该操作影响到的设备），输入密码提权操作。默认最大分区，直接下一步。分区名字填ssd，其他选项默认（Type：ext4），点击create创建。点击分区左下角的三角符号（▶）进行挂载（状态变化：Not Mounted -&gt; Mounted at &#x2F;media&#x2F;nvidia&#x2F;ssd）。</li><li>下载系统盘转换程序的源码：<code>git clone https://github.com/jetsonhacks/rootOnNVMe.git</code>。如果克隆仓库失败，访问网页下载压缩包，再解压通过WinSCP上传到开发板家目录（上传后记得将文件的权限设置为0755，否则运行程序时会提示无权限）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> rootOnNVMe</span><br><span class="line"><span class="comment"># 这个过程耗时较久，请耐心等待执行完毕再执行下一步</span></span><br><span class="line"><span class="comment"># 建议是刚烧录好系统之后就执行这一步转换，否则EMMC数据一旦很多的话，这步操作的转换过程十分漫长</span></span><br><span class="line">./copy-rootfs-ssd.sh</span><br><span class="line">./setup-service.sh</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li><li>运行命令<code>df -h</code>：可以看到挂载根目录的分区大小已经是SSD固态硬盘的120G的容量，不是以前EMMC的16G。</li></ol><h1 id="Jetson-TX2更换软件源">7 &nbsp&nbsp<a href="#Jetson-TX2更换软件源" class="headerlink" title="Jetson TX2更换软件源"></a>Jetson TX2更换软件源</h1><p>备份并编辑软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份/etc/lib路径下的source.list文件，</span></span><br><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"><span class="comment"># i进入编辑模式。按esc键退出模式，先按gg（到达顶部），然后dG全部删除。:wq保存编辑并退出vi。</span></span><br><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 编辑软件源后，更新拉取源表</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>清华源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main universe restricted</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main universe restricted</span><br></pre></td></tr></table></figure><p>假如默认官方源被删除的话，可以用下面的可用官方源恢复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted</span><br><span class="line">deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic main restricted</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted</span><br><span class="line">deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates main restricted</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic universe</span><br><span class="line">deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic universe</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates universe</span><br><span class="line">deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates universe</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic multiverse</span><br><span class="line">deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic multiverse</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-updates multiverse</span><br><span class="line">deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-updates multiverse</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb http://archive.canonical.com/ubuntu bionic partner</span></span><br><span class="line"><span class="comment"># deb-src http://archive.canonical.com/ubuntu bionic partner</span></span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted</span><br><span class="line">deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security main restricted</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-security universe</span><br><span class="line">deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security universe</span><br><span class="line">deb http://ports.ubuntu.com/ubuntu-ports/ bionic-security multiverse</span><br><span class="line">deb-src http://ports.ubuntu.com/ubuntu-ports/ bionic-security multiverse</span><br></pre></td></tr></table></figure><h1 id="配置python">8 &nbsp&nbsp<a href="#配置python" class="headerlink" title="配置python"></a>配置python</h1><p>查看<a href="https://github.com/pytorch/vision#installation">torchvision的README页面</a>，可知torch和torchvision对应版本信息，以及所要求的python版本。</p><table><thead><tr><th align="left">torch</th><th align="left">torchvision</th><th align="left">Python</th></tr></thead><tbody><tr><td align="left">1.10</td><td align="left">0.11</td><td align="left">&gt;&#x3D;3.6, &lt;&#x3D;3.9</td></tr></tbody></table><p>综合考虑，因为需要安装v1.10.2的pytorch，因此python选用v3.7（很多深度学习项目要求最低的python版本是v3.7），避免v3.8-v3.9可能会因此太新导致编译出错。</p><h2 id="pyton3-6">8.1 &nbsp&nbsp<a href="#pyton3-6" class="headerlink" title="pyton3.6"></a>pyton3.6</h2><p>系统自带pyton3.6.9，运行pip3报错：pip3:command not found</p><p>解决方法：<code>sudo apt install python3-pip</code></p><h2 id="pyton3-7">8.2 &nbsp&nbsp<a href="#pyton3-7" class="headerlink" title="pyton3.7"></a>pyton3.7</h2><p>pyton3.7版本需要手动编译。下载<a href="https://www.python.org/ftp/python/3.7.16/Python-3.7.16.tar.xz">python3.7.16源码压缩包</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过ssh连接到开发板系统，通过winscp上传python源码压缩包到开发板的家目录</span></span><br><span class="line">tar -xf Python-3.7.16.tar.xz</span><br><span class="line"><span class="comment"># 安装构建pyhon所需的包，使用清华源的话，安装libncurses5库可能会出现库依赖错误，这个需要用ubuntu官方源（bionic源）才能解决，其他库可以用清华源</span></span><br><span class="line">sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libbz2-dev liblzma-dev</span><br><span class="line"><span class="comment"># 或者build-dep参数让ubuntu自动搜索相关包。使用这个命令，记得apt list自行核对下其他额外包有无安装好，参照「系统缺乏库的一些报错」小节。</span></span><br><span class="line"><span class="comment"># 如果build-dep报错：Error :: You must put some &#x27;source&#x27; URIs in your sources.list，请启用/etc/apt/sources.list文件中的deb-src源，即取消注释。修改完成后重新运行sudo apt update。</span></span><br><span class="line">sudo apt build-dep python3</span><br><span class="line"><span class="comment"># prefix配置安装路径，方便卸载时直接删除prefix的路径即可</span></span><br><span class="line">./configure --prefix=/usr/local/python3.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设使用conda创建虚拟环境的话，可以用以下方式配置安装路径</span></span><br><span class="line"><span class="comment"># 安装到miniconda环境（base）</span></span><br><span class="line">./configure --prefix=/root/miniconda3/lib/python3.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># npro查看处理器核心数，lscpu查看处理器详情，-j无参为使用所有核心，后面跟数字就是并行编译数量</span></span><br><span class="line">make -j</span><br><span class="line"><span class="comment"># 安装python</span></span><br><span class="line">sudo make install</span><br><span class="line"><span class="built_in">cd</span> /usr/bin/</span><br><span class="line"><span class="comment"># 创建python3.7和pip3.7软链接</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/python3.7/bin/python3.7 python3.7</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/python3.7/bin/pip3.7 pip3.7</span><br><span class="line"><span class="comment"># 配置pip源</span></span><br><span class="line">pip3.7 config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="comment"># export bin目录到path</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/python3.7/bin</span><br></pre></td></tr></table></figure><h3 id="系统缺乏库的一些报错：">8.2.1 &nbsp&nbsp<a href="#系统缺乏库的一些报错：" class="headerlink" title="系统缺乏库的一些报错："></a>系统缺乏库的一些报错：</h3><ul><li>缺乏libssl-dev库：pip is configured with locations that require TLS&#x2F;SSL, however the ssl module in Python is not available。实际上</li><li>缺乏libffi-dev库：ModuleNotFoundError: No module named &#39;_ctypes&#39;</li><li>缺乏libbz2-dev库（Detectron2需要用到）：ModuleNotFoundError: No module named &#39;_bz2&#39;</li><li>缺乏liblzma-dev库（Detectron2需要用到）：ModuleNotFoundError: No module named &#39;_lzma&#39;</li></ul><h3 id="TLS-SSL报错的另类解决方式">8.2.2 &nbsp&nbsp<a href="#TLS-SSL报错的另类解决方式" class="headerlink" title="TLS&#x2F;SSL报错的另类解决方式"></a>TLS&#x2F;SSL报错的另类解决方式</h3><p>如果因为缺乏libssl-dev库，导致编译出来的python报错TLS&#x2F;SSL的话，实际上这个问题可以通过换pip源解决，必须是http源。</p><p>创建并编辑pip配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.pip</span><br><span class="line"><span class="built_in">cd</span> ~/.pip</span><br><span class="line"><span class="built_in">touch</span> pip.conf</span><br><span class="line">nano pip.conf</span><br></pre></td></tr></table></figure><p>pip源设置内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><h3 id="安装系统库时的依赖版本报错">8.2.3 &nbsp&nbsp<a href="#安装系统库时的依赖版本报错" class="headerlink" title="安装系统库时的依赖版本报错"></a>安装系统库时的依赖版本报错</h3><p>报错内容：libssl-dev : Depends: libssl1.0.0 (&#x3D; 1.0.2g-1ubuntu4) but 1.0.2g-1ubuntu4.15 is to be installed</p><p>报错原因：要装的库OpenSSL，它需要依赖的包是X，但需要的X是A版本，但是系统环境中已经存在另外的程序，它也需要的依赖X，并且需要的是X另外一个版本B，两个版本之间发生冲突了。所以无法安装。</p><p>解决方法：<code>sudo apt install libssl1.0.0=1.0.2g-1ubuntu4</code>，即安装推荐的折中版本（报错提示有给出）。</p><h2 id="pypi清华源">8.3 &nbsp&nbsp<a href="#pypi清华源" class="headerlink" title="pypi清华源"></a>pypi清华源</h2><ul><li>临时使用：<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</code></li><li>设置默认 (版本需&gt;&#x3D;10.0.0) ：<code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></li><li>升级pip本体<ul><li>官方源升级pip：<code>python -m pip install --upgrade pip</code></li><li>清华源升级pip：<code>python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip</code></li></ul></li></ul><h1 id="解决报错「Illegal-instruction-core-dumped-」">9 &nbsp&nbsp<a href="#解决报错「Illegal-instruction-core-dumped-」" class="headerlink" title="解决报错「Illegal instruction (core dumped)」"></a>解决报错「Illegal instruction (core dumped)」</h1><p>为了防止出现 “Illegal instruction (core dumped)” 报错，需要在 ~&#x2F;.bashrc 最后添加如下语句，保存修改后，重启系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> OPENBLAS_CORETYPE=ARMV8</span><br></pre></td></tr></table></figure><p>若是export导出环境变量之后，仍是出现相同的报错的话，则可能是安装包版本问题或者程序包问题。</p><h1 id="安装jetson-stats查看开发板情况">10 &nbsp&nbsp<a href="#安装jetson-stats查看开发板情况" class="headerlink" title="安装jetson-stats查看开发板情况"></a>安装jetson-stats查看开发板情况</h1><p>安装<a href="https://pypi.org/project/jetson-stats/">jetson-stats</a>前记得把pip源更换为清华源：<code>sudo -H pip3.7 install -U jetson-stats</code></p><p>安装好jetson-stats之后，可以安装nvidia-jetpack包，使用jetson_release查看开发板信息（注意需提前装好jetson-stats）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nvidia-jetpack</span><br><span class="line">sudo jetson_release</span><br></pre></td></tr></table></figure><h2 id="The-jetson-stats-service-is-not-active">10.1 &nbsp&nbsp<a href="#The-jetson-stats-service-is-not-active" class="headerlink" title="The jetson_stats.service is not active"></a>The jetson_stats.service is not active</h2><p>报错情况，jtop（jetson_stats.service）不能运行，systemctl查看服务状态为activating：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The jetson_stats.service is not active. Please run:</span><br><span class="line">sudo systemctl restart jetson_stats.service</span><br></pre></td></tr></table></figure><p>解决方法：把pip源更换为清华源后，重新安装jetson-stats。</p><h1 id="为开发板安装CUDA、cuDNN、TensorRT库">11 &nbsp&nbsp<a href="#为开发板安装CUDA、cuDNN、TensorRT库" class="headerlink" title="为开发板安装CUDA、cuDNN、TensorRT库"></a>为开发板安装CUDA、cuDNN、TensorRT库</h1><p>示例根文件系统并未包含cuda等库，因此烧录系统之后，需要手动安装CUDA、cuDNN、TensorRT库。</p><ol><li>打开<a href="https://developer.nvidia.com/sdk-manager">sdk-manager</a>下载网站，注册英伟达开发者帐号（注意是developer.nvidia.com域名，搜索nvidia register关键字注册的域名可能是partner.nvidia.com，即nvonline）。</li><li>下载最新的deb安装包，当前最新的是NVIDIA SDK Manager 1.9.3.deb。</li><li>安装sdk-manager：<code>sudo apt install sdkmanager_1.9.3-10904_amd64.deb</code></li><li>运行sdk-manager：终端运行命令<code>sdk-manager</code>或者在应用程序列表中找到SDKManager图标打开。</li><li>登录帐号（developer开发者帐号会打开浏览器登录，nvonline是直接在软件内页面登录），建议勾选上「Stay logged in」，避免因为安装出错后重复打开应用又要重新登录。</li><li>sdk-manager第一步：等待程序自动检测出开发板信息，若没正确识别到开发板，请手动在Target Hardware选择正确的开发板型号（比如我的是TX2 NX型号）。剩余默认即可，附加SDK（DeepStreem）不需要勾选上。</li><li>sdk-manager第二步：HOST COMPONENTS设置的是烧录主机的环境（清华镜像源可装），TARGET COMPONENTS（开发板环境，Jetson OS不要勾选，因为前面的步骤已经烧录过了。其他的SDK Components全部勾上）（清华源无法安装，会报错：SDK Manager received errors while using apt commands on your system，需换回官方源，并且是需要编辑开发板上的sources.list，编辑host主机上的sources.list源是没用的）。用micro-usb线连接开发板和烧录主机，点击下一步，提示指定路径不存在，点击create完成创建即可，这里输入烧录主机的密码用来提权。之后弹出一个窗口设置开发板帐号密码信息： 确认开发板型号，IPv4用192.168.55.1（usb连接的虚拟ip），系统账户名和系统密码，其余默认，之后点击Install确认安装库。</li><li>sdk-manager第三步：安装过程。</li><li>sdk-manager第四步：exit退出。</li><li>设置环境变量：sdk-manager安装好库之后，会自动添加export环境变量语句到用户级的.bashrc配置文件中（注意只是添加而已，仍需手动source ~&#x2F;.bashrc，确保是在普通账户的终端下执行该命令）。但是root账户目录的.bashrc配置文件需手动配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刷新bash配置，普通账户nvidia的终端下执行该命令</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 切换root权限</span></span><br><span class="line">sudo -i</span><br><span class="line"><span class="comment"># 切换root权限后，工作目录会自动转到root的家目录下</span></span><br><span class="line">nano .bashrc</span><br><span class="line"><span class="comment"># 将以下两条命令添加到.bashrc的底部</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/local/cuda-10.2/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure></li><li>查看cuda库的安装状态的命令：<code>jtop</code>和<code>nvcc -V</code>&#x2F;<code>nvcc --version</code>。</li><li>配置 cuDNN：sdk-manager虽然安装了cuDNN，但没有将对应的头文件、库文件放到cuda目录。<div class="note danger no-icon"><p>不配置这个也可以，但编译opencv with cuda时需要手动指定路径到&#x2F;usr&#x2F;include和&#x2F;usr&#x2F;lib&#x2F;aarch64-linux-gnu</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sdk-manager安装路径</span></span><br><span class="line"><span class="comment"># cuDNN 默认安装路径在 /usr/lib/aarch64-linux-gnu</span></span><br><span class="line"><span class="comment"># CUDA 默认安装路径在 /usr/local/cuda 下</span></span><br><span class="line"><span class="comment"># cuDNN的头文件在：/usr/include，库文件位于：/usr/lib/aarch64-linux-gnu</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件到cuda目录下</span></span><br><span class="line"><span class="built_in">cd</span> /usr/include &amp;&amp; sudo <span class="built_in">cp</span> cudnn* /usr/local/cuda-10.2/include</span><br><span class="line"><span class="built_in">cd</span> /usr/lib/aarch64-linux-gnu &amp;&amp; sudo <span class="built_in">cp</span> libcudnn* /usr/local/cuda-10.2/lib64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件权限，修改复制完的头文件与库文件的权限，所有用户都可读，可写，可执行：</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /usr/local/cuda-10.2/include/cudnn.h</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /usr/local/cuda-10.2/lib64/libcudnn*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 软链接移动之后就失效了，需重新软链接，这里的8.2.1和8对应安装的cudnn版本号和首数字</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/cuda-10.2/lib64</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn.so /etc/alternatives/libcudnn_so</span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn.so.8.2.1 libcudnn.so.8</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_ops_train.so /etc/alternatives/libcudnn_ops_train_so</span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_ops_train.so.8.2.1 libcudnn_ops_train.so.8</span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_ops_infer.so /etc/alternatives/libcudnn_ops_infer_so</span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_ops_infer.so.8.2.1 libcudnn_ops_infer.so.8</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_adv_train.so /etc/alternatives/libcudnn_adv_train_so</span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_adv_train.so.8.2.1 libcudnn_adv_train.so.8</span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_adv_infer.so /etc/alternatives/libcudnn_adv_infer_so</span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_adv_infer.so.8.2.1 libcudnn_adv_infer.so.8</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_cnn_train.so /etc/alternatives/libcudnn_cnn_train_so</span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_cnn_train.so.8.2.1 libcudnn_cnn_train.so.8</span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_cnn_infer.so /etc/alternatives/libcudnn_cnn_infer_so</span><br><span class="line">sudo <span class="built_in">ln</span> -sf libcudnn_cnn_infer.so.8.2.1 libcudnn_cnn_infer.so.8</span><br><span class="line"></span><br><span class="line">sudo libcudnn_static.a /etc/alternatives/libcudnn_stlib</span><br><span class="line"><span class="comment"># 更新系统动态链接库</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li><li>测试Cudnn（可选）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> -r /usr/src/cudnn_samples_v8/ ~/</span><br><span class="line"><span class="built_in">cd</span> ~/cudnn_samples_v8/mnistCUDNN</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 ~/cudnn_samples_v8</span><br><span class="line">sudo make clean &amp;&amp; sudo make</span><br><span class="line">./mnistCUDNN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置成功输出：</span></span><br><span class="line"><span class="comment"># Result of classification: 1 3 5</span></span><br><span class="line"><span class="comment"># Test passed!</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="安装pytorch和pytorch-vision">12 &nbsp&nbsp<a href="#安装pytorch和pytorch-vision" class="headerlink" title="安装pytorch和pytorch vision"></a>安装pytorch和pytorch vision</h1><h2 id="pyton3-6-1">12.1 &nbsp&nbsp<a href="#pyton3-6-1" class="headerlink" title="pyton3.6"></a>pyton3.6</h2><h3 id="为python3-6安装pytorch">12.1.1 &nbsp&nbsp<a href="#为python3-6安装pytorch" class="headerlink" title="为python3.6安装pytorch"></a>为python3.6安装pytorch</h3><p>pyton3.6直接访问<a href="https://forums.developer.nvidia.com/t/pytorch-for-jetson/72048">nvidia官网PyTorch for Jetson帖子</a>下载官方编译提供的版本：<a href="https://nvidia.box.com/shared/static/fjtbno0vpo676a25cgvuqc1wty0fkkg6.whl">点击跳转下载whl</a>，安装命令：<code>pip3.6 install torch-1.10.0-cp36-cp36m-linux_aarch64.whl</code></p><h3 id="为python3-6编译torchvision">12.1.2 &nbsp&nbsp<a href="#为python3-6编译torchvision" class="headerlink" title="为python3.6编译torchvision"></a>为python3.6编译torchvision</h3><p>同<a href="#%E4%B8%BApython3-7%E7%BC%96%E8%AF%91torchvision">为python3.7编译torchvision</a></p><h2 id="pyton3-7-1">12.2 &nbsp&nbsp<a href="#pyton3-7-1" class="headerlink" title="pyton3.7"></a>pyton3.7</h2><h3 id="为python3-7编译pytorch">12.2.1 &nbsp&nbsp<a href="#为python3-7编译pytorch" class="headerlink" title="为python3.7编译pytorch"></a>为python3.7编译pytorch</h3><div class="note danger"><p>注意：编译过程十分耗时，请耐心等待！我测试的机器型号为TX2 NX，编译耗时23个小时（大部分时间都是停留在编译caffe2仓库）。</p></div><p>由于英伟达官方只提供python3.6版本的pytorch安装包，并且<a href="https://download.pytorch.org/whl/torch_stable.html">torch库官方下载站</a>也没有arm芯片（aarch）的cu102版whl安装包，cpu版倒是有提供，因此pyton3.7的cuda版pytorch需要自行从源码编译。</p><p>编译步骤参考<a href="https://forums.developer.nvidia.com/t/pytorch-for-jetson/72048">nvidia官网PyTorch for Jetson帖子</a>的Instructions小节的Build from Source内容。</p><ol><li>设置开发板功率模式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置最大功率模式，CPU和GPU频率最大</span></span><br><span class="line"><span class="comment"># on Xavier NX, use -m 2  instead (15W 6-core mode)</span></span><br><span class="line">sudo nvpmodel -m 0</span><br><span class="line"><span class="comment"># 开启最大性能（重启开发板就会自动失效），运行命令不加任何参数就是将CPU、GPU、EMC的频率设置到最大</span></span><br><span class="line">sudo jetson_clocks</span><br><span class="line"><span class="comment"># 查询当前工作模式</span></span><br><span class="line">sudo nvpmodel -q verbose</span><br><span class="line"><span class="comment"># 查看当前硬件频率情况</span></span><br><span class="line">sudo jetson_clocks --show</span><br><span class="line"><span class="comment"># 如果是想要临时开启最大性能模式jetson_clocks</span></span><br><span class="line"><span class="comment"># 请在开启之前，运行sudo jetson_clocks --store记录普通状态的设置</span></span><br><span class="line"><span class="comment"># 之后运行sudo jetson_clocks开启最大性能</span></span><br><span class="line"><span class="comment"># 完成任务后运行sudo jetson_clocks --restore恢复普通状态的设置，就是关闭最大性能模式</span></span><br><span class="line"><span class="comment"># 如果开启最大性能模式之前没有sudo jetson_clocks --store记录状态，那么只能是重启机器，再运行设置</span></span><br></pre></td></tr></table></figure></li><li>下载PyTorch源码（v1.10.2）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/nvidia</span><br><span class="line"><span class="comment"># 其实不推荐用--recursive递归克隆git子项目，容易出现克隆失败</span></span><br><span class="line">git <span class="built_in">clone</span> --recursive --branch v1.10.2 http://github.com/pytorch/pytorch</span><br><span class="line"><span class="comment"># 假如已经执行了上述命令，如果只有子项目报错的话，可以试试直接执行git submodule update --recursive</span></span><br><span class="line"><span class="comment"># 下面是pytorch官方README给出的方法</span></span><br><span class="line"><span class="comment"># if you are updating an existing checkout</span></span><br><span class="line">git submodule <span class="built_in">sync</span></span><br><span class="line">git submodule update --init --recursive --<span class="built_in">jobs</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐方式，先克隆主项目，再克隆子项目</span></span><br><span class="line">git <span class="built_in">clone</span> --branch v1.10.2 http://github.com/pytorch/pytorch</span><br><span class="line"><span class="built_in">cd</span> pytorch</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"><span class="comment"># 如果出现失败，重复执行这条命令，直到克隆成功</span></span><br><span class="line">git submodule update --recursive</span><br><span class="line"><span class="comment"># 我的情况在克隆子项目时，无论是init还是update阶段，linux-syscall-support这个仓库总是克隆不下来，因为它是chromium.googlesource.com域名，没法裸连成功。在github上搜索到镜像仓库https://github.com/cpp-pm/linux-syscall-support（如果是其他的github上的镜像仓库，要注意查看该仓库是否及时从上游获取更新，确保包含有e1e7b0ad8ee99a875b272c8e33e308472e897660这个commit，否则递归处理会提示找不到这个commit）</span></span><br><span class="line"><span class="comment"># 在使用https://github.com/cpp-pm/linux-syscall-support镜像仓库时，我仍然出现了连接失败。奇怪的是，其他github链接可以正常连接，唯独这个库连接不上。没法子，通过ping github.com得到一个返回ip：20.205.243.166。手动指向ip的话，需要关闭ssl证书验证，不然很容易报错（尤其是http的ssl证书验证）</span></span><br><span class="line"><span class="comment"># 如果无法直接ping得到ip，访问网页：https://www.ipaddress.com/，输入对应域名，比如raw.githubusercontent.com，查看返回的真实ip。</span></span><br><span class="line"><span class="comment"># 设置git重定向仓库链接，直接指向ip地址</span></span><br><span class="line">git config --global http.sslVerify <span class="literal">false</span></span><br><span class="line">git config --global https.sslVerify <span class="literal">false</span></span><br><span class="line">git config --global url.<span class="string">&quot;https://20.205.243.166/cpp-pm/linux-syscall-support&quot;</span>.insteadOf <span class="string">&quot;https://chromium.googlesource.com/linux-syscall-support&quot;</span></span><br><span class="line"><span class="comment"># 或者编辑git配置文件，在.gitconfig文件中添加如下参数</span></span><br><span class="line"><span class="comment"># 如果仍然不起作用的话，可以在http类目下添加允许重定向：followRedirects = true。命令操作：git config --global http.followRedirects true</span></span><br><span class="line">nano ~/.gitconfig</span><br><span class="line">[http]</span><br><span class="line">        sslverify = <span class="literal">false</span></span><br><span class="line">[https]</span><br><span class="line">        sslverify = <span class="literal">false</span></span><br><span class="line">[url <span class="string">&quot;https://20.205.243.166/cpp-pm/linux-syscall-support&quot;</span>]</span><br><span class="line">        insteadOf = https://chromium.googlesource.com/linux-syscall-support</span><br><span class="line"></span><br><span class="line"><span class="comment"># chromium.googlesource.com还可以尝试Agora.io提供的镜像网站，具体参考内容https://webrtc.agora.io/mirror/</span></span><br><span class="line"><span class="comment"># 但我的情况设置了，依旧也是连接超时</span></span><br><span class="line"><span class="comment"># git config --global url.http://120.92.49.206:3232/chromiumsrc/linux-syscall-support.git.insteadOf https://chromium.googlesource.com/linux-syscall-support.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设在克隆或者构建子项目出错时，想全部清除所有子项目的话，通过下面的命令完成（下面的目录是我对.gitmodules文件通过正则表达式处理得到的）</span></span><br><span class="line"><span class="comment"># cd pytorch</span></span><br><span class="line"><span class="comment"># rm third_party/pybind11 third_party/cub third_party/eigen third_party/googletest third_party/benchmark third_party/protobuf third_party/ios-cmake third_party/NNPACK third_party/gloo third_party/pthreadpool third_party/FXdiv third_party/FP16 third_party/psimd third_party/zstd third_party/cpuinfo third_party/python-enum third_party/python-peachpy third_party/python-six third_party/onnx third_party/onnx-tensorrt third_party/sleef third_party/ideep third_party/nccl/nccl third_party/gemmlowp/gemmlowp third_party/QNNPACK third_party/neon2sse third_party/fbgemm third_party/foxi third_party/tbb android/libs/fbjni third_party/XNNPACK third_party/fmt third_party/tensorpipe third_party/cudnn_frontend third_party/kineto third_party/pocketfft third_party/breakpad</span></span><br></pre></td></tr></table></figure></li><li>根据<a href="https://gist.github.com/dusty-nv/ce51796085178e1f38e3c6a1663a93a1#file-pytorch-1-10-jetpack-4-5-1-patch">patch内容</a>手动为patch新修复的代码：就是根据patch文件内容查找对应文件的对应行数，同步改动的代码。如果懒得改动的话，直接下载我修改好的文件，上传替换就行。patch代码主要解决编译报错的问题（详见编译步骤参考帖子）</li></ol><ul><li><a href="/post-assets/nvidia-jetson/vec256_float_neon.h">vec256_float_neon.h</a></li><li><a href="/post-assets/nvidia-jetson/CUDAContext.cpp">CUDAContext.cpp</a></li><li><a href="/post-assets/nvidia-jetson/KernelUtils.h">KernelUtils.h</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> pytorch</span><br><span class="line"><span class="comment"># 因为WinSCP使用普通账户连接的rscp，权限不够，因此建议先直接用vscode编辑文件，之后再上传到家目录，用root权限替换掉对应文件。</span></span><br><span class="line"><span class="built_in">mv</span> aten/src/ATen/cpu/vec/vec256/vec256_float_neon.h aten/src/ATen/cpu/vec/vec256/vec256_float_neon.h.bak</span><br><span class="line"><span class="built_in">mv</span> ../vec256_float_neon.h aten/src/ATen/cpu/vec/vec256/vec256_float_neon.h</span><br><span class="line"><span class="built_in">mv</span> aten/src/ATen/cuda/CUDAContext.cpp aten/src/ATen/cuda/CUDAContext.cpp.bak</span><br><span class="line"><span class="built_in">mv</span> ../CUDAContext.cpp aten/src/ATen/cuda/CUDAContext.cpp</span><br><span class="line"><span class="built_in">mv</span> aten/src/ATen/cuda/detail/KernelUtils.h aten/src/ATen/cuda/detail/KernelUtils.h.bak</span><br><span class="line"><span class="built_in">mv</span> ../KernelUtils.h aten/src/ATen/cuda/detail/KernelUtils.h</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>设置构建参数的环境变量（如果有改变终端，记得重新export这些环境变量）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> USE_NCCL=0</span><br><span class="line"><span class="comment"># skip setting this if you want to enable OpenMPI backend</span></span><br><span class="line"><span class="built_in">export</span> USE_DISTRIBUTED=0</span><br><span class="line"><span class="built_in">export</span> USE_QNNPACK=0</span><br><span class="line"><span class="built_in">export</span> USE_PYTORCH_QNNPACK=0</span><br><span class="line"><span class="comment"># or &quot;7.2;8.7&quot; for JetPack 5 wheels for Xavier/Orin</span></span><br><span class="line"><span class="built_in">export</span> TORCH_CUDA_ARCH_LIST=<span class="string">&quot;5.3;6.2;7.2&quot;</span></span><br><span class="line"><span class="comment"># without the leading &#x27;v&#x27;, e.g. 1.3.0 for PyTorch v1.3.0</span></span><br><span class="line"><span class="built_in">export</span> PYTORCH_BUILD_VERSION=1.10.2</span><br><span class="line"><span class="built_in">export</span> PYTORCH_BUILD_NUMBER=1</span><br></pre></td></tr></table></figure></li><li>安装构建必要的系统库：<code>sudo apt install cmake libopenblas-dev libopenmpi-dev</code>，这里我使用的ubuntu官方源。</li><li>编译源码构建程序（在构建之前建议先备份pytorch文件夹，毕竟克隆不容易：<code>cp -r pytorch pytorch.bak</code>）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> pytorch</span><br><span class="line"><span class="comment"># 安装构建必要的pip3.7库</span></span><br><span class="line">pip3.7 install -r requirements.txt</span><br><span class="line">pip3.7 install scikit-build</span><br><span class="line">pip3.7 install ninja</span><br><span class="line"><span class="comment"># 开始编译源码构建程序，生成的安装包输出在dist文件夹：torch-1.10.2-cp37-cp37m-linux_aarch64.whl</span></span><br><span class="line">python3.7 setup.py bdist_wheel</span><br><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line">pip3.7 install torch-1.10.2-cp37-cp37m-linux_aarch64.whl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在编译过程中，反复出现一个报错：c++: internal compiler error: 已杀死 (program cc1plus)</span></span><br><span class="line"><span class="comment"># 原因：swap交换空间不足，使用jtop命令查看当前开发板只有系统分配的1.9G的zram交换空间，需手动增加swap空间</span></span><br><span class="line"><span class="comment"># 弃用以下传统的swapfile方法，修改zram的大小就好</span></span><br><span class="line"><span class="comment"># 查看所有zram相关文件</span></span><br><span class="line">find / -name <span class="string">&quot;*zram*&quot;</span> 2&gt;/dev/null</span><br><span class="line"><span class="comment"># 编辑zram配置文件</span></span><br><span class="line">nano /etc/systemd/nvzramconfig.sh</span><br><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">mem=$(((totalmem / <span class="number">2</span> / <span class="variable">$&#123;NRDEVICES&#125;</span>) * <span class="number">1024</span>))</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 修改后zram总大小为物理内存大小的三倍</span></span><br><span class="line">mem=$(((totalmem * <span class="number">3</span> / <span class="variable">$&#123;NRDEVICES&#125;</span>) * <span class="number">1024</span>))</span><br><span class="line"><span class="comment"># 查看zram情况</span></span><br><span class="line">zramctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增swapfile文件大小自定义</span></span><br><span class="line">sudo fallocate -l 8G /var/swapfile</span><br><span class="line"><span class="comment"># 配置该文件的权限</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 600 /var/swapfile</span><br><span class="line"><span class="comment"># 建立交换分区</span></span><br><span class="line">sudo mkswap /var/swapfile</span><br><span class="line"><span class="comment"># 启用交换分区，再次运行jtop，可看到swap空间已经变成了10G</span></span><br><span class="line">sudo swapon /var/swapfile</span><br><span class="line"><span class="comment"># 设置为自动启用swapfile</span></span><br><span class="line">sudo bash -c <span class="string">&#x27;echo &quot;/var/swapfile swap swap defaults 0 0&quot; &gt;&gt; /etc/fstab&#x27;</span></span><br><span class="line"><span class="comment"># 关闭交换分区</span></span><br><span class="line">sudo swapoff /var/swapfile</span><br><span class="line"><span class="comment"># 在现有的/var//swapfile后面追加30GB（增加容量后，请手动mkswap及swapon）</span></span><br><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/var/swapfile bs=1M count=30720 oflag=append conv=notrunc</span><br><span class="line"><span class="comment"># 删除交换分区文件</span></span><br><span class="line">sudo <span class="built_in">rm</span> /var/swapfile</span><br><span class="line"><span class="comment"># 删除fstab相关设置</span></span><br><span class="line">nano /etc/fstab</span><br></pre></td></tr></table></figure></li><li>检测pytorch安装是否成功<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python3.7</span><br><span class="line">import torch</span><br><span class="line"><span class="comment"># 输出True安装成功</span></span><br><span class="line">torch.cuda.is_available()</span><br><span class="line">torch.backends.cudnn.is_available()</span><br><span class="line"><span class="comment"># 查看cuda版本</span></span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda)</span><br><span class="line"><span class="comment"># 查看cudnn版本</span></span><br><span class="line"><span class="built_in">print</span>(torch.backends.cudnn.version())</span><br></pre></td></tr></table></figure></li></ol><h3 id="为python3-7编译torchvision">12.2.2 &nbsp&nbsp<a href="#为python3-7编译torchvision" class="headerlink" title="为python3.7编译torchvision"></a>为python3.7编译torchvision</h3><p>查看<a href="https://github.com/pytorch/vision#installation">torchvision的README页面</a>，可知torch和torchvision对应版本信息，以及所要求的python版本。</p><table><thead><tr><th align="left">torch</th><th align="left">torchvision</th><th align="left">Python</th></tr></thead><tbody><tr><td align="left">1.10</td><td align="left">0.11</td><td align="left">&gt;&#x3D;3.6, &lt;&#x3D;3.9</td></tr></tbody></table><p>编译步骤参阅：<a href="https://github.com/pytorch/vision/blob/v0.11.3/CONTRIBUTING.md#development-installation">Development installation</a></p><p>下载及编译torchvision源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的网络环境没法直连github域名，手动指向cdn的ip（ping github.com得到ip），确保git的全局设置http的ssl证书验证关闭</span></span><br><span class="line"><span class="comment"># git clone -b v0.11.3 https://github.com/pytorch/vision.git torchvision</span></span><br><span class="line">git <span class="built_in">clone</span> -b v0.11.3 https://20.205.243.166/pytorch/vision.git torchvision</span><br><span class="line"><span class="built_in">cd</span> torchvision</span><br><span class="line">sudo apt install libpng-dev libjpeg-turbo8-dev</span><br><span class="line"><span class="comment"># 设置编译的版本，避免生成的whl文件名不显示正确的版本名称（若不设置这个环境变量，生成的whl只有主版本号正确即v0.11，子版本号显示乱码，而不是显示3）</span></span><br><span class="line"><span class="built_in">export</span> BUILD_VERSION=0.11.3</span><br><span class="line"><span class="comment"># 开始编译源码构建程序，生成的安装包输出在dist文件夹：torchvision-0.11.3-cp37-cp37m-linux_aarch64.whl</span></span><br><span class="line">python setup.py bdist_wheel</span><br><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line">pip3.7 install torchvision-0.11.3-cp37-cp37m-linux_aarch64.whl</span><br></pre></td></tr></table></figure><p>测试安装是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import torchvision</span><br><span class="line"><span class="built_in">print</span>(torchvision.__version__)</span><br></pre></td></tr></table></figure><h1 id="配置opencv-with-cuda">13 &nbsp&nbsp<a href="#配置opencv-with-cuda" class="headerlink" title="配置opencv with cuda"></a>配置opencv with cuda</h1><h2 id="python3-6环境">13.1 &nbsp&nbsp<a href="#python3-6环境" class="headerlink" title="python3.6环境"></a>python3.6环境</h2><p>使用python3.6环境，可以直接使用这个帖子给出的预编译的opencv包——<a href="https://zhuanlan.zhihu.com/p/392495001">官方隐藏资源：Jetson伪超频与CUDA版OpenCV</a>。</p><p>预构建好的deb文件：<a href="https://nvidia.box.com/shared/static/5v89u6g5rb62fpz4lh0rz531ajo2t5ef.gz">OpenCV-4.5.0-aarch64.tar.gz</a></p><p>可以先卸载系统自带的CPU版的opencv4.1.1，再执行安装deb包。</p><p>如果想自行从源码构建opencv with cuda，编译步骤可参考<a href="https://qengineering.eu/install-opencv-on-jetson-nano.html">Install OpenCV on Jetson Nano</a>。</p><h2 id="python3-7环境">13.2 &nbsp&nbsp<a href="#python3-7环境" class="headerlink" title="python3.7环境"></a>python3.7环境</h2><ol><li><p>卸载默认不带cuda的opencv</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt purge libopencv*</span><br><span class="line">sudo apt autoremove</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保/usr/lib/中没有其他版本的openCV影响</span></span><br><span class="line">find / -name <span class="string">&quot;*opencv*&quot;</span> 2&gt;/dev/null</span><br></pre></td></tr></table></figure></li><li><p>下载opencv和opencv_contrib源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问网页离线下载</span></span><br><span class="line"><span class="comment"># https://github.com/opencv/opencv/releases/tag/4.1.1</span></span><br><span class="line"><span class="comment"># https://github.com/opencv/opencv_contrib/releases/tag/4.1.1</span></span><br><span class="line">curl -s -L -O https://github.com/opencv/opencv/archive/refs/tags/4.1.1.zip</span><br><span class="line">curl -s -L -O https://github.com/opencv/opencv_contrib/archive/refs/tags/4.1.1.zip</span><br><span class="line">sudo apt install unzip</span><br><span class="line">upzip opencv-4.1.1.zip</span><br><span class="line">unzip opencv_contrib-4.1.1.zip</span><br><span class="line"><span class="comment"># 两个压缩包都放在同一个目录下</span></span><br><span class="line"><span class="built_in">cd</span> opencv-4.1.1</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure></li><li><p>安装依赖库（参见<a href="https://qengineering.eu/install-opencv-on-jetson-nano.html">Install OpenCV on Jetson Nano</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reveal the CUDA location</span></span><br><span class="line">sudo sh -c <span class="string">&quot;echo &#x27;/usr/local/cuda-10.2/lib64&#x27; &gt;&gt; /etc/ld.so.conf.d/nvidia-tegra.conf&quot;</span></span><br><span class="line"><span class="comment"># 更新动态链接库</span></span><br><span class="line">sudo ldconfig</span><br><span class="line"><span class="comment"># third-party libraries</span></span><br><span class="line">sudo apt install build-essential cmake git unzip pkg-config zlib1g-dev</span><br><span class="line">sudo apt install libjpeg-dev libjpeg8-dev libjpeg-turbo8-dev</span><br><span class="line">sudo apt install libpng-dev libtiff-dev libglew-dev</span><br><span class="line">sudo apt install libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">sudo apt install libgtk2.0-dev libgtk-3-dev libcanberra-gtk*</span><br><span class="line">sudo apt install python-dev python-numpy python-pip</span><br><span class="line">sudo apt install python3-dev python3-numpy python3-pip</span><br><span class="line">sudo apt install libxvidcore-dev libx264-dev libgtk-3-dev</span><br><span class="line">sudo apt install libtbb2 libtbb-dev libdc1394-22-dev libxine2-dev</span><br><span class="line">sudo apt install gstreamer1.0-tools libgstreamer-plugins-base1.0-dev</span><br><span class="line">sudo apt install libgstreamer-plugins-good1.0-dev</span><br><span class="line">sudo apt install libv4l-dev v4l-utils v4l2ucp qv4l2</span><br><span class="line">sudo apt install libtesseract-dev libxine2-dev libpostproc-dev</span><br><span class="line">sudo apt install libavresample-dev libvorbis-dev</span><br><span class="line">sudo apt install libfaac-dev libmp3lame-dev libtheora-dev</span><br><span class="line">sudo apt install libopencore-amrnb-dev libopencore-amrwb-dev</span><br><span class="line">sudo apt install libopenblas-dev libatlas-base-dev libblas-dev</span><br><span class="line">sudo apt install liblapack-dev liblapacke-dev libeigen3-dev gfortran</span><br><span class="line">sudo apt install libhdf5-dev libprotobuf-dev protobuf-compiler</span><br><span class="line">sudo apt install libgoogle-glog-dev libgflags-dev</span><br></pre></td></tr></table></figure></li><li><p>配置cmake</p><div class="note danger no-icon"><p>配置cmake一定要加上这项参数<code>-D CUDNN_VERSION=&quot;8.0&quot;</code>，否则会报错：Could NOT find CUDNN: Found unsuitable version &quot;..&quot;, but required is at least &quot;6&quot; (found &#x2F;usr&#x2F;lib&#x2F;aarch64-linux-gnu&#x2F;libcudnn.so.8.2.1)，即使是手动指定了库文件的绝对路径，仍然是会报这个错误。cudnn版本参见<a href="#%E4%B8%BA%E5%BC%80%E5%8F%91%E6%9D%BF%E5%AE%89%E8%A3%85CUDA%E3%80%81cuDNN%E3%80%81TensorRT%E5%BA%93">「为开发板安装CUDA、cuDNN、TensorRT库」</a>小节</p></div><div class="note info no-icon"><p>下载的源码压缩包不包含所有modules组件的源码，并且raw.githubusercontent.com是无法直连的，直接ping也无法得到ip，通过网页<a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a>，得到ip：185.199.110.133。如果不修改hosts进行域名解析映射IP，大概率会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=======================================================================</span><br><span class="line">  Couldn<span class="string">&#x27;t download files from the Internet.</span></span><br><span class="line"><span class="string">  Please check the Internet access on this host.</span></span><br><span class="line"><span class="string">=======================================================================</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/hosts</span><br><span class="line">185.199.110.133 raw.githubusercontent.com</span><br><span class="line">20.205.243.166 github.com</span><br></pre></td></tr></table></figure><p>倘若修改了hosts文件进行域名解析映射IP之后，仍然是报错提示无法连接网络下载文件的话，先移除opencv_contrib-4.1.1目录。</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">cmake \</span><br><span class="line">-D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">-D CMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">-D CMAKE_C_COMPILER=/usr/bin/gcc-7 \</span><br><span class="line">-D INSTALL_PYTHON_EXAMPLES=OFF \</span><br><span class="line">-D INSTALL_C_EXAMPLES=OFF \</span><br><span class="line">-D OPENCV_ENABLE_NONFREE=ON \</span><br><span class="line">-D BUILD_opencv_python3=ON \</span><br><span class="line">-D WITH_CUDA=ON \</span><br><span class="line">-D WITH_CUDNN=ON \</span><br><span class="line">-D CUDNN_VERSION=<span class="string">&quot;8.0&quot;</span> \</span><br><span class="line">-D WITH_TBB=ON \</span><br><span class="line">-D OPENCV_DNN_CUDA=ON \</span><br><span class="line">-D ENABLE_FAST_MATH=on \</span><br><span class="line">-D CUDA_FAST_MATH=on \</span><br><span class="line">-D CUDA_ARCH_BIN=6.2 \</span><br><span class="line">-D CUDA_ARCH_PTX=<span class="string">&quot;&quot;</span> \</span><br><span class="line">-D WITH_CUBLAS=on \</span><br><span class="line">-D OPENCV_GENERATE_PKGCONFIG=ON \</span><br><span class="line">-D OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib-4.1.1/modules \</span><br><span class="line">-D PYTHON3_EXECUTABLE=/usr/local/python3.7/bin/python3.7m \</span><br><span class="line">-D PYTHON3_INCLUDE_DIR=/usr/local/python3.7/include/python3.7m \</span><br><span class="line">-D PYTHON3_LIBRARY=/usr/local/python3.7/lib/libpython3.7m.so \</span><br><span class="line">-D PYTHON3_NUMPY_INCLUDE_DIRS=/usr/local/python3.7/lib/python3.7/site-packages/numpy/core/include \</span><br><span class="line">-D PYTHON3_PACKAGES_PATH=/usr/local/python3.7/lib/python3.7/site-packages \</span><br><span class="line">-D PYTHON_DEFAULT_EXECUTABLE=/usr/local/python3.7/bin/python3.7m \</span><br><span class="line">-D CUDNN_LIBRARY=/usr/local/cuda-10.2/lib64/libcudnn.so.8.2.1 \</span><br><span class="line">-D CUDNN_INCLUDE_DIR=/usr/local/cuda-10.2/include  \</span><br><span class="line">-D CUDA_CUDA_LIBRARY=/usr/local/cuda-10.2/targets/aarch64-linux/lib/stubs/libcuda.so \</span><br><span class="line">-D CUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda-10.2/ \</span><br><span class="line">-D OPENCV_PYTHON3_INSTALL_PATH=/usr/local/python3.7/lib/python3.7/site-packages \</span><br><span class="line">-D WITH_WEBP=OFF \</span><br><span class="line">-D WITH_OPENCL=OFF \</span><br><span class="line">-D ETHASHLCL=OFF \</span><br><span class="line">-D ENABLE_CXX11=ON \</span><br><span class="line">-D BUILD_EXAMPLES=OFF \</span><br><span class="line">-D WITH_OPENGL=ON \</span><br><span class="line">-D WITH_GSTREAMER=ON \</span><br><span class="line">-D WITH_V4L=ON \</span><br><span class="line">-D WITH_LIBV4L=ON \</span><br><span class="line">-D WITH_QT=OFF \</span><br><span class="line">-D BUILD_opencv_python3=ON \</span><br><span class="line">-D BUILD_opencv_python2=OFF \</span><br><span class="line">-D WITH_FFMPEG=on \</span><br><span class="line">-D HAVE_opencv_python3=ON \</span><br><span class="line">-D EIGEN_INCLUDE_PATH=/usr/include/eigen3 \</span><br><span class="line">-D WITH_EIGEN=ON \</span><br><span class="line">-D ENABLE_NEON=ON \</span><br><span class="line">-D WITH_OPENMP=ON \</span><br><span class="line">-D BUILD_TIFF=ON \</span><br><span class="line">-D WITH_TBB=ON \</span><br><span class="line">-D BUILD_TBB=ON \</span><br><span class="line">-D BUILD_TESTS=OFF \</span><br><span class="line">-D WITH_PROTOBUF=ON \</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>如果cmake提示找不到OpenBLAS头文件和库文件的话，可以尝试方法修复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -- Could not find OpenBLAS include. Turning OpenBLAS_FOUND off</span></span><br><span class="line"><span class="comment"># -- Could not find OpenBLAS lib. Turning OpenBLAS_FOUND off</span></span><br><span class="line"><span class="comment"># -- Could NOT find Atlas (missing: Atlas_CBLAS_LIBRARY Atlas_BLAS_LIBRARY)</span></span><br><span class="line">sudo apt install libopenblas-dev libopenblas-base</span><br><span class="line">sudo apt install liblapacke-dev</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/include/lapacke.h /usr/include/x86_64-linux-gnu <span class="comment"># corrected path for the library</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Open_BLAS_INCLUDE_SEARCH_PATHS path:  /usr/include/x86_64-linux-gnu</span></span><br><span class="line"><span class="comment"># Open_BLAS_LIB_SEARCH_PATHS path: /usr/lib/x86_64-linux-gnu</span></span><br><span class="line"><span class="comment"># 将以上路径分别添加到opencv/cmake/OpenCVFindOpenBLAS.cmake文件中的SET(Open_BLAS_INCLUDE_SEARCH_PATHS和SET(Open_BLAS_LIB_SEARCH_PATHS中。</span></span><br></pre></td></tr></table></figure></li><li><p>编译及安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-j参数多线程编译时会报错（makefile文件引起的），可能是由于我修改了opencv/cmake/OpenCVFindOpenBLAS.cmake文件引起的</span></span><br><span class="line">make -j1</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新动态链接库</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li><li><p>测试opencv安装情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设编译安装好系统opencv with cuda后，python没有找到cv2，则安装opencv-python包启用。</span></span><br><span class="line"><span class="comment"># pip install opencv-python</span></span><br><span class="line"></span><br><span class="line">python3.7</span><br><span class="line">import cv2</span><br><span class="line"><span class="comment"># 返回cuda设备，即cuda显卡的数量</span></span><br><span class="line"><span class="built_in">print</span>(cv2.cuda.getCudaEnabledDeviceCount())</span><br></pre></td></tr></table></figure></li></ol><h1 id="配置conda（可选，但不推荐）">14 &nbsp&nbsp<a href="#配置conda（可选，但不推荐）" class="headerlink" title="配置conda（可选，但不推荐）"></a>配置conda（可选，但不推荐）</h1><p>不推荐配置，jetson tx2 nx型号能够安装成功的版本较老，并且创建虚拟环境后，默认的base环境一旦conda install任意包之后，再次运行conda的任何命令都会报错：<code>illegal instruction (core dump)</code>，pip可以正常工作。如果是新建其他名称的虚拟环境，则是pip会报错：<code>illegal instruction (core dump)</code>，而conda install可以正常工作。</p><p>anaconda下载：<br>miniconda下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">点击跳转</a><br>Archiconda下载：<a href="https://github.com/Archiconda/build-tools/releases">点击跳转</a></p><p>tx2 nx硬件只有这个版本能成功安装：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py37_4.9.2-Linux-aarch64.sh">Miniconda3-py37_4.9.2-Linux-aarch64.sh</a>，而之后的新版本都会报错：<code>illegal instruction (core dump)</code>。</p><h2 id="conda基本操作">14.1 &nbsp&nbsp<a href="#conda基本操作" class="headerlink" title="conda基本操作"></a>conda基本操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建了名为xxx的虚拟环境，指定虚拟环境的 Python 版本为3.7</span></span><br><span class="line">conda create -n xxx python=3.7</span><br><span class="line"><span class="comment"># 激活名为xxx的虚拟环境</span></span><br><span class="line">conda activate xxx</span><br><span class="line"><span class="comment"># 退出当前虚拟环境</span></span><br><span class="line">conda deactivate</span><br><span class="line"><span class="comment"># 删除名为xxx的虚拟环境</span></span><br><span class="line">conda remove -n xxx --all</span><br><span class="line"><span class="comment"># 查看本地已有哪些虚拟环境</span></span><br><span class="line">conda info --<span class="built_in">env</span></span><br></pre></td></tr></table></figure><h2 id="修改conda源">14.2 &nbsp&nbsp<a href="#修改conda源" class="headerlink" title="修改conda源"></a>修改conda源</h2><p>参见<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">Anaconda 镜像使用帮助</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.condarc</span><br><span class="line"><span class="comment"># windows用户可以用下面的命令创建这个文件</span></span><br><span class="line"><span class="comment"># conda config --set show_channel_urls yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为.condarc文件添加如下内容</span></span><br><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: <span class="literal">true</span></span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除索引缓存</span></span><br><span class="line">conda clean -i</span><br></pre></td></tr></table></figure><h2 id="使用yml配置文件创建虚拟环境报错（这个我实测没生效）">14.3 &nbsp&nbsp<a href="#使用yml配置文件创建虚拟环境报错（这个我实测没生效）" class="headerlink" title="使用yml配置文件创建虚拟环境报错（这个我实测没生效）"></a>使用yml配置文件创建虚拟环境报错（这个我实测没生效）</h2><p>现象：使用yml文件创建conda环境时出现Solving environment: failed 和 ResolvePackageNotFound 的错误</p><p>原因：因为部分包的版本详细是根据机器配置而定，导出来的版本不一定适用当前的机器</p><p>解决方法：剔除环境配置文件environment.yml中的版本信息，只需删除第二个等号之后的内容即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pytorch=1.1.0=py3.7_cuda10.0.130_cudnn7.5.1_0</span><br><span class="line"><span class="comment"># 例如上面这行的修改如下</span></span><br><span class="line">pytorch=1.1.0</span><br></pre></td></tr></table></figure><h1 id="参考文献">15 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Nvidia xavier NX 通过 flash.sh 烧录 linux 系统[EB&#x2F;OL]. <a href="https://blog.csdn.net/Yan_uuu/article/details/126947983">https://blog.csdn.net/Yan_uuu/article/details/126947983</a>.<br>[2] Jetson Xavier NX 镜像制作、烧录及克隆[EB&#x2F;OL]. <a href="https://blog.csdn.net/qhdd123/article/details/123815911">https://blog.csdn.net/qhdd123/article/details/123815911</a>.<br>[3] 解决 Jetson：Failed to start nvpmode1 server. 和 Failed to start load kernel modules[EB&#x2F;OL]. <a href="https://blog.csdn.net/alianfibakic/article/details/123807606">https://blog.csdn.net/alianfibakic/article/details/123807606</a>.<br>[4] Jetson TX2 更换软件源[EB&#x2F;OL]. <a href="https://blog.csdn.net/qlulibin/article/details/80271096">https://blog.csdn.net/qlulibin/article/details/80271096</a>.<br>[5] Ubuntu18.04 默认源恢复默认源恢复备份源[EB&#x2F;OL]. <a href="https://blog.csdn.net/ZeyiRTangent/article/details/114885286">https://blog.csdn.net/ZeyiRTangent/article/details/114885286</a>.<br>[6] PyPI 镜像使用帮助[EB&#x2F;OL]. <a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a>.<br>[7] Ubuntu 编译安装 python3.7.10, 解决‘_ctypes‘和 ssl 问题, 建立软链接 python3.7 和 pip3.7[EB&#x2F;OL]. <a href="https://blog.csdn.net/tmaccs/article/details/117029067">https://blog.csdn.net/tmaccs/article/details/117029067</a>.<br>[8] ubuntu18.04 下源码编译安装最新版本 Python3[EB&#x2F;OL]. <a href="https://zhuanlan.zhihu.com/p/62930419">https://zhuanlan.zhihu.com/p/62930419</a>.<br>[9] ubuntu pip is configured with locations that require TLS&#x2F;SSL[EB&#x2F;OL]. <a href="https://blog.csdn.net/a1007720052/article/details/107342695">https://blog.csdn.net/a1007720052/article/details/107342695</a>.<br>[10] libssl‑dev : Depends: libssl1.0.0 (&#x3D; 1.0.2g‑1ubuntu4) but 1.0.2g‑1ubuntu4.15 is to be installed[EB&#x2F;OL]. <a href="https://blog.csdn.net/weixin_38890593/article/details/102783551">https://blog.csdn.net/weixin_38890593/article/details/102783551</a>.<br>[11] TX2开启最大功耗模式[EB&#x2F;OL]. <a href="https://www.cnblogs.com/gezhuangzhuang/p/11674062.html">https://www.cnblogs.com/gezhuangzhuang/p/11674062.html</a>.<br>[12] 使用git --recursive进行循环克隆，由于网络原因，出现克隆失败的情况。[EB&#x2F;OL]. <a href="https://blog.csdn.net/qq_43212651/article/details/116376103">https://blog.csdn.net/qq_43212651/article/details/116376103</a>.<br>[13] 解决c++: internal compiler error: 已杀死 (program cc1plus)[EB&#x2F;OL]. <a href="https://blog.csdn.net/chenmeng0508/article/details/122283442">https://blog.csdn.net/chenmeng0508/article/details/122283442</a>.<br>[14] Jetson nano增加Swap分区大小操作指南[EB&#x2F;OL]. <a href="https://blog.csdn.net/qq_33475105/article/details/108372878">https://blog.csdn.net/qq_33475105/article/details/108372878</a>.<br>[15] 玩转NVIDIA Jetson （25）--- jetson 安装pytorch和torchvision[EB&#x2F;OL]. <a href="https://blog.csdn.net/huiyuanliyan/article/details/126686036">https://blog.csdn.net/huiyuanliyan/article/details/126686036</a>.<br>[16] Ubuntu 安装PHP找不着BZip2[EB&#x2F;OL]. <a href="https://blog.csdn.net/handsome_926/article/details/77933926">https://blog.csdn.net/handsome_926/article/details/77933926</a>.<br>[17] ModuleNotFoundError: No module named &#39;_lzma&#39;[EB&#x2F;OL]. <a href="https://zhuanlan.zhihu.com/p/404162713">https://zhuanlan.zhihu.com/p/404162713</a>.<br>[18] Error :: You must put some &#39;source&#39; URIs in your sources.list[EB&#x2F;OL]. <a href="https://askubuntu.com/questions/496549/error-you-must-put-some-source-uris-in-your-sources-list">https://askubuntu.com/questions/496549/error-you-must-put-some-source-uris-in-your-sources-list</a>.<br>[19] 3d-pose-baseline[EB&#x2F;OL]. <a href="https://github.com/una-dinosauria/3d-pose-baseline">https://github.com/una-dinosauria/3d-pose-baseline</a>.<br>[20] How to stop jetson_clocks?[EB&#x2F;OL]. <a href="https://forums.developer.nvidia.com/t/how-to-stop-jetson-clocks/144713">https://forums.developer.nvidia.com/t/how-to-stop-jetson-clocks/144713</a>.<br>[21] VideoPose3d:环境搭建+制作自己的视频[EB&#x2F;OL]. <a href="https://blog.csdn.net/willbetter01/article/details/120906567">https://blog.csdn.net/willbetter01/article/details/120906567</a>.<br>[22] 【VideoPose3D】可视化自定义视频[EB&#x2F;OL]. <a href="https://blog.csdn.net/qq_44942539/article/details/121983187">https://blog.csdn.net/qq_44942539/article/details/121983187</a>.<br>[23] Windows下VideoPose3D成功运行记录2：运行自定义视频[EB&#x2F;OL]. <a href="https://www.bilibili.com/read/cv19291005/">https://www.bilibili.com/read/cv19291005/</a>.<br>[24] How to Use OpenCV with CUDA Support in Python[EB&#x2F;OL]. <a href="https://saturncloud.io/blog/how-to-use-opencv-with-cuda-support-in-python/">https://saturncloud.io/blog/how-to-use-opencv-with-cuda-support-in-python/</a>.<br>[25] Jetson Xavier NX OpenCV 安装[EB&#x2F;OL]. <a href="https://zhuanlan.zhihu.com/p/411901208">https://zhuanlan.zhihu.com/p/411901208</a>.<br>[26] Nvidia Jetson TX2 配置Cuda 加速的Opencv[EB&#x2F;OL]. <a href="https://blog.csdn.net/weixin_62651190/article/details/129348245">https://blog.csdn.net/weixin_62651190/article/details/129348245</a>.<br>[27] Guide to build OpenCV from source with GPU support (CUDA and cuDNN)[EB&#x2F;OL]. <a href="https://gist.github.com/minhhieutruong0705/8f0ec70c400420e0007c15c98510f133">https://gist.github.com/minhhieutruong0705/8f0ec70c400420e0007c15c98510f133</a>.<br>[28] How to install OpenCV 4.2.0 with CUDA 10.0 in Ubuntu distro 18.04[EB&#x2F;OL]. <a href="https://gist.github.com/changx03/b4aa9bb2827217c3a6a7e08365441417">https://gist.github.com/changx03/b4aa9bb2827217c3a6a7e08365441417</a>.<br>[29] Jetson带CUDA编译的opencv4.5安装教程与踩坑指南，cmake配置很重要！[EB&#x2F;OL]. <a href="https://blog.csdn.net/weixin_39298885/article/details/110851373">https://blog.csdn.net/weixin_39298885/article/details/110851373</a>.<br>[30] ubuntu 编译安装支持CUDA的OpenCV[EB&#x2F;OL]. <a href="https://blog.csdn.net/qq_44523137/article/details/124098406">https://blog.csdn.net/qq_44523137/article/details/124098406</a>.<br>[31] Install OpenCV on Jetson Nano[EB&#x2F;OL]. <a href="https://qengineering.eu/install-opencv-on-jetson-nano.html">https://qengineering.eu/install-opencv-on-jetson-nano.html</a>.<br>[32] 「解析」Jetson Orin NX 安装 CUDA&#x2F;cuDNN[EB&#x2F;OL]. <a href="https://blog.csdn.net/ViatorSun/article/details/129909317">https://blog.csdn.net/ViatorSun/article/details/129909317</a>.<br>[33] OpenCV 4.2.0 and CuDNN for Jetson Nano?[EB&#x2F;OL]. <a href="https://forums.developer.nvidia.com/t/opencv-4-2-0-and-cudnn-for-jetson-nano/112281?page=2">https://forums.developer.nvidia.com/t/opencv-4-2-0-and-cudnn-for-jetson-nano/112281?page=2</a>.<br>[34] Correction in OpenCV&#39;s default CMAKE search Path for OpenBLAS Library on Ubuntu-64bit Machines [Solution] [EB&#x2F;OL]. <a href="https://github.com/opencv/opencv/issues/12957">https://github.com/opencv/opencv/issues/12957</a>.<br>[35] jetson tx2 安装miniconda失败原因（illegal instruction (core dump）原因解析与简易安装miniconda[EB&#x2F;OL]. <a href="https://blog.csdn.net/buxiangyaomingzi/article/details/123297295">https://blog.csdn.net/buxiangyaomingzi/article/details/123297295</a>.<br>[36] TypeError: load() missing 1 required positional argument: &#39;Loader&#39; in Google Colab[EB&#x2F;OL]. <a href="https://stackoverflow.com/questions/69564817/typeerror-load-missing-1-required-positional-argument-loader-in-google-col">https://stackoverflow.com/questions/69564817/typeerror-load-missing-1-required-positional-argument-loader-in-google-col</a>.<br>[37] 解决创建conda环境时Solving environment: failed 和 ResolvePackageNotFound 的错误[EB&#x2F;OL]. <a href="https://blog.csdn.net/hshudoudou/article/details/126407029">https://blog.csdn.net/hshudoudou/article/details/126407029</a>.<br>[38] 关于Ubuntu下ZRAM的配置和使用[EB&#x2F;OL]. <a href="https://blog.xzr.moe/archives/88/">https://blog.xzr.moe/archives/88/</a>.<br>[39] 解决python urllib3 v2.0 only supports OpenSSL 1.1.1+, currently[EB&#x2F;OL]. <a href="https://blog.csdn.net/weixin_43205308/article/details/130830307">https://blog.csdn.net/weixin_43205308/article/details/130830307</a>.<br>[40] 从TensorFlow被kill到增加Swap分区[EB&#x2F;OL]. <a href="https://www.zhihu.com/column/p/30562899">https://www.zhihu.com/column/p/30562899</a>.<br>[41] Linux运行程序时，程序进程莫名退出（被杀死）[EB&#x2F;OL]. <a href="https://blog.csdn.net/ispringmw/article/details/112719262">https://blog.csdn.net/ispringmw/article/details/112719262</a>.<br>[42] linux 环境下进程被 killed掉原因分析和解决方法[EB&#x2F;OL]. <a href="https://blog.csdn.net/ktigerhero3/article/details/80004315">https://blog.csdn.net/ktigerhero3/article/details/80004315</a>.<br>[43] Linux OOM Killer机制 以及防止被OOM Killer杀死的方法[EB&#x2F;OL]. <a href="https://blog.csdn.net/top_explore/article/details/107733974">https://blog.csdn.net/top_explore/article/details/107733974</a>.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div class=&quot;note &quot;&gt;&lt;p&gt;文章推荐：&lt;a href=&quot;https://www.guyuehome.com/42097&quot;&gt;Jetson nano 系统安装&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;note danger</summary>
        
      
    
    
    
    <category term="software" scheme="https://mister-kin.github.io/categories/software/"/>
    
    
    <category term="总结" scheme="https://mister-kin.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="英伟达" scheme="https://mister-kin.github.io/tags/%E8%8B%B1%E4%BC%9F%E8%BE%BE/"/>
    
    <category term="nvidia" scheme="https://mister-kin.github.io/tags/nvidia/"/>
    
    <category term="jetson" scheme="https://mister-kin.github.io/tags/jetson/"/>
    
    <category term="开发板" scheme="https://mister-kin.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="踩坑" scheme="https://mister-kin.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>安装Arch Linux的踩坑记录总结</title>
    <link href="https://mister-kin.github.io/software/arch-linux/"/>
    <id>https://mister-kin.github.io/software/arch-linux/</id>
    <published>2023-09-22T20:11:36.000Z</published>
    <updated>2023-09-24T07:40:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装arch系统镜像">1 &nbsp&nbsp<a href="#安装arch系统镜像" class="headerlink" title="安装arch系统镜像"></a>安装arch系统镜像</h1><ol><li>下载镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/">点击跳转</a>，使用PE U盘或者虚拟机加载CD方式加载系统镜像。</li><li>选择<code>Arch Linux install medium (x86_64, UEFI)</code>。</li><li>验证启动模式：<code>ls /sys/firmware/efi/efivars</code>。若正确输出目录且无错误，则证明是UEFI模式。</li><li>连接网络（由路由器DHCP自动下发分配IP），ping测试联网状态（<code>ip addr</code>查看IP），可用ssh连接完成后面的工作，方便复制粘贴命令（<code>systemctl status sshd</code>查看ssh保护进程运行状态），passwd修改当前环境root账户的密码。</li><li>重新设置镜像源mirrorlist，使用reflector获取速度最快的6个镜像，并保存至指定路径<code>/etc/pacman.d/mirrorlist</code>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reflector -c China -a 6 --<span class="built_in">sort</span> rate --save /etc/pacman.d/mirrorlist</span><br><span class="line">reflector -c China -a 6 --<span class="built_in">sort</span> rate --save /mnt/etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>手动设置镜像源：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/pacman.d/mirrorlist</span><br><span class="line"><span class="comment"># 顶部添加如下镜像源</span></span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">Server = https://repo.archlinuxcn.org/<span class="variable">$arch</span></span><br></pre></td></tr></table></figure></li><li>打开自动同步时间：<code>timedatectl set-ntp true</code>。检测命令生效情况：<code>timedatectl status</code>。</li><li><code>lsblk</code>或者<code>fdisk -l</code>查看硬盘情况（rom、loop、airoot的设备可忽略掉）。使用fdisk分区：<code>fdisk /dev/sda</code>，按<code>g</code>并回车将磁盘分区表设置为GPT格式，按<code>n</code>并回车新增一个分区，分区号默参直接回车，起始扇区默参直接回车，结束位置输入<code>+300M</code>并回车表示分区大小为300M。重复<code>n</code>命令三次，完成剩余的三个分区的工作。按<code>t</code>并回车更改分区类型，输入分区编号1并回车，输入分区类型1并回车（1代表EFI system partition）。重复<code>t</code>命令，将2、3、4号分区分别改为类型19（SWAP），类型23（Linux root (x86-64)），类型42（Linux home）。最后按<code>w</code>并回车保存分区表。<code>df -h</code>查看分区情况。</li><li>磁盘格式化<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkfs.fat -F 32 /dev/sda1</span><br><span class="line">mkswap /dev/sda2</span><br><span class="line">mkfs.ext4 /dev/sda3</span><br><span class="line">mkfs.ext4 /dev/sda4</span><br></pre></td></tr></table></figure></li><li>挂载文件系统<br>挂载boot<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda3 /mnt</span><br><span class="line"><span class="built_in">mkdir</span> -p /mnt/home <span class="comment">#创建/mnt/home目录供挂载</span></span><br><span class="line">mount /dev/sda4 /mnt/home</span><br><span class="line"><span class="built_in">mkdir</span> -p /mnt/boot <span class="comment">#创建/mnt/boot目录供挂载</span></span><br><span class="line">mount /dev/sda1 /mnt/boot</span><br></pre></td></tr></table></figure>挂载swap：<code>swapon /dev/sda2</code></li><li>安装系统：<code>pacstrap /mnt base linux linux-firmware nano</code></li><li>生成fstab文件：<code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code>。检查fstab文件内容：<code>cat /mnt/etc/fstab</code>。</li><li>更换当前的根目录到安装到硬盘上的系统：<code>arch-chroot /mnt</code></li><li>将时区设置为亚洲&#x2F;上海：<code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code>。</li><li>同步硬件时钟：<code>hwclock --systohc</code>。</li><li>配置本地化设置：<code>nano /etc/locale.gen</code>，<code>ctrl+w</code>搜索，分别找到<code>#en_US</code>,<code>#zh_CN</code>带有UTF-8的两行，去掉前面的#号。<code>ctrl+o</code>并回车保存文件，<code>ctrl+x</code>并回车退出nano。生成配置：<code>locale-gen</code>。</li><li>创建并修改&#x2F;etc&#x2F;locale.conf文件，填入<code>LANG=en_US.UTF-8</code>并保存。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /etc/locale.conf</span><br><span class="line">nano /etc/locale.conf</span><br></pre></td></tr></table></figure></li><li>配置网络主机名：<code>echo &quot;archlinux&quot; &gt;&gt; /etc/hostname</code>，</li><li>设置root密码：<code>passwd</code>。</li><li>设置引导程序<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S dosfstools grub efibootmgr  <span class="comment"># 安装引导程序</span></span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --recheck  <span class="comment"># 将grub安装至EFI分区</span></span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg  <span class="comment"># 生成grub配置</span></span><br></pre></td></tr></table></figure></li><li>安装新系统必要的包：<code>pacman -S networkmanager network-manager-applet dhcpcd dialog os-prober mtools ntfs-3g base-devel linux-headers reflector git</code>。更新软件包缓存：<code>sudo pacman -Syy</code>。更新系统：<code>sudo pacman -Syu</code>。</li><li>开启dhcpcd<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start dhcpcd  <span class="comment"># 启动dhcpcd</span></span><br><span class="line">systemctl <span class="built_in">enable</span> dhcpcd  <span class="comment"># 使dhcpcd自启</span></span><br></pre></td></tr></table></figure></li><li>启用sshd服务并远程控制<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start sshd</span><br><span class="line">systemctl <span class="built_in">enable</span> sshd</span><br><span class="line">nano /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># 将其中PermitRootLogin前面#号去掉并且将值设置为yes</span></span><br><span class="line"><span class="comment"># 将其中PasswordAuthentication前面#号去掉并且将值设置为yes</span></span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></li><li>添加普通用户<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useradd -m kin <span class="comment"># 添加用户名为kin的用户</span></span><br><span class="line">passwd kin <span class="comment"># 为用户kin设置密码</span></span><br><span class="line"><span class="comment"># 添加用户的更多选项</span></span><br><span class="line"><span class="comment"># useradd -m -G additional_groups -s login_shell username</span></span><br><span class="line">pacman -S sudo</span><br><span class="line">nao /etc/sudoers</span><br><span class="line"><span class="comment"># 打开/etc/sudoers文件后，在root ALL=(ALL:ALL) ALL一行下，添加kin ALL=(ALL:ALL) ALL。</span></span><br></pre></td></tr></table></figure></li><li>退出chroot环境，卸载掉挂载的硬盘并重启<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>  <span class="comment"># 返回至arch-chroot之前的环境</span></span><br><span class="line">umount /mnt/home</span><br><span class="line">umount /mnt/boot</span><br><span class="line">umount /mnt</span><br><span class="line">reboot  <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>分区方案（列表顺序就是实际的分区顺序）</strong></p><ul><li><code>/boot/efi</code> 300M</li><li><code>swap</code>（内存大小×1.5）</li><li><code>/</code> 40G</li><li><code>/home</code> 剩余全部空间</li></ul><p><strong>Swap分区的大小分配推荐方案</strong></p><table><thead><tr><th>Amount of RAM in the system</th><th>Recommended swap space</th><th>Recommended swap space if allowing for hibernation</th></tr></thead><tbody><tr><td>⩽ 2GB</td><td>2 times the amount of RAM</td><td>3 times the amount of RAM</td></tr><tr><td>&gt; 2GB – 8GB</td><td>Equal to the amount of RAM</td><td>2 times the amount of RAM</td></tr><tr><td>&gt; 8GB – 64GB</td><td>At least 4 GB</td><td>1.5 times the amount of RAM</td></tr><tr><td>&gt; 64GB</td><td>At least 4 GB</td><td>Hibernation not recommended</td></tr></tbody></table><h1 id="安装KDE桌面环境">2 &nbsp&nbsp<a href="#安装KDE桌面环境" class="headerlink" title="安装KDE桌面环境"></a>安装KDE桌面环境</h1><ol><li>安装显示Xorg服务器：<code>sudo pacman -S xorg</code>。</li><li>安装KDE Plasma桌面环境和其他KDE软件包：<code>sudo pacman -S plasma kde-applications</code>。</li><li>安装显示管理器（开机图形界面登录）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S sddm</span><br><span class="line">systemctl <span class="built_in">enable</span> sddm.service <span class="comment"># 开机自启动sddm服务</span></span><br></pre></td></tr></table></figure></li><li>进入桌面环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动进入桌面环境</span></span><br><span class="line">startx</span><br><span class="line"><span class="comment"># 修改当前帐户bash配置，让账户登录后自动进入桌面环境</span></span><br><span class="line">nano ~/.bash_profile</span><br><span class="line"><span class="comment"># 或者修改Shell的全局启动配置文件</span></span><br><span class="line">nano /etc/profile</span><br><span class="line"><span class="comment"># 文件末尾处添加如下内容</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;DISPLAY&#125;</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$&#123;XDG_VTNR&#125;</span>&quot;</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> startx</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="参考文献">3 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] 在ProxmoxVE(PVE)7.0中安装ArchLinux[EB&#x2F;OL]. <a href="https://www.raobee.com/archives/343/">https://www.raobee.com/archives/343/</a>.<br>[2]  Arch Linux + KDE 的安装和配置[EB&#x2F;OL]. <a href="https://peoxin.github.io/blog/2022/05/01/Arch%20Linux%20+%20KDE%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">https://peoxin.github.io/blog/2022/05/01/Arch%20Linux%20+%20KDE%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</a>.<br>[3] Installation guide[EB&#x2F;OL]. <a href="https://wiki.archlinux.org/title/Installation_guide">https://wiki.archlinux.org/title/Installation_guide</a>.<br>[4] How to Install Deepin Desktop in Arch Linux [Complete Guide][EB&#x2F;OL]. <a href="https://www.debugpoint.com/2021/01/deepin-arch-linux-install-20/">https://www.debugpoint.com/2021/01/deepin-arch-linux-install-20/</a>.<br>[5] Easy Step - Arch Linux ( EFI ) With Clover ( EFI )[EB&#x2F;OL]. <a href="https://www.insanelymac.com/forum/topic/294443-easy-step-arch-linux-efi-with-clover-efi/">https://www.insanelymac.com/forum/topic/294443-easy-step-arch-linux-efi-with-clover-efi/</a>.<br>[6] 10 Commands to Check Disk Partitions and Disk Space on Linux[EB&#x2F;OL]. <a href="https://www.binarytides.com/linux-command-check-disk-partitions/">https://www.binarytides.com/linux-command-check-disk-partitions/</a>.<br>[7] Can&#39;t establish an internet connection in Arch Linux[EB&#x2F;OL]. <a href="https://superuser.com/questions/751961/cant-establish-an-internet-connection-in-arch-linux">https://superuser.com/questions/751961/cant-establish-an-internet-connection-in-arch-linux</a>.<br>[8] Deepin Desktop Environment (简体中文)[EB&#x2F;OL]. <a href="https://wiki.archlinux.org/title/Deepin_Desktop_Environment_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/title/Deepin_Desktop_Environment_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a>.<br>[9] Localization (简体中文)&#x2F;Simplified Chinese (简体中文)[EB&#x2F;OL]. <a href="https://wiki.archlinux.org/title/Localization_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/Simplified_Chinese_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/title/Localization_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/Simplified_Chinese_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a>.<br>[10] VirtualBox&#x2F;Install Arch Linux as a guest[EB&#x2F;OL]. <a href="https://wiki.archlinux.org/title/VirtualBox/Install_Arch_Linux_as_a_guest">https://wiki.archlinux.org/title/VirtualBox/Install_Arch_Linux_as_a_guest</a>.<br>[11] How to enable a Virtualbox shared folder for Linux guest systems[EB&#x2F;OL]. <a href="https://averagelinuxuser.com/virtualbox-shared-folder/">https://averagelinuxuser.com/virtualbox-shared-folder/</a>.<br>[12] Recommended Partitioning Scheme[EB&#x2F;OL]. <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-x86">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-x86</a>.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;安装arch系统镜像&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#安装arch系统镜像&quot; class=&quot;headerlink&quot; title=&quot;安装arch系统镜像&quot;&gt;&lt;/a&gt;安装arch系统镜像&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;下载镜像：&lt;a</summary>
        
      
    
    
    
    <category term="software" scheme="https://mister-kin.github.io/categories/software/"/>
    
    
    <category term="系统" scheme="https://mister-kin.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="linux" scheme="https://mister-kin.github.io/tags/linux/"/>
    
    <category term="arch" scheme="https://mister-kin.github.io/tags/arch/"/>
    
    <category term="virtualbox" scheme="https://mister-kin.github.io/tags/virtualbox/"/>
    
    <category term="pve" scheme="https://mister-kin.github.io/tags/pve/"/>
    
  </entry>
  
  <entry>
    <title>PVE+iKuai+OpenWrt虚拟机折腾记录</title>
    <link href="https://mister-kin.github.io/software/pve/"/>
    <id>https://mister-kin.github.io/software/pve/</id>
    <published>2023-09-10T20:19:30.000Z</published>
    <updated>2023-09-10T20:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info no-icon"><p>推荐教程：张大妈网站的大佬-纵笔浮生的「<a href="https://search.smzdm.com/?c=home&s=%E3%80%8E%E8%BD%AF%E8%B7%AF%E7%94%B1%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97%E3%80%8F+&v=b">软路由踩坑指南</a>」系列文章。</p></div><h1 id="背景">1 &nbsp&nbsp<a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因联通赠送的光猫性能不支持双lan口长时间同时上网，故从海鲜市场（小黄鱼）上淘了一块n3530小工控机，计划用来安装pve虚拟机用以作软路由处理宽带拨号和网关ip分配，光猫仅作为一个光电信号转换器。</p><h2 id="机器配置">1.1 &nbsp&nbsp<a href="#机器配置" class="headerlink" title="机器配置"></a>机器配置</h2><ul><li>CPU：Intel(R) Pentium(R) CPU N3530</li><li>内存：海力士DDR3L-8GB单根</li><li>硬盘：海力士SH920 msata 256GB</li><li>网卡：双网卡intel I211+Realtek mini-pcie RTL8211E&#x2F;F（螃蟹卡，后期自己购买加装至mini pcie无线网卡口位置）</li></ul><h1 id="安装pve">2 &nbsp&nbsp<a href="#安装pve" class="headerlink" title="安装pve"></a>安装pve</h1><h2 id="BIOS的优化设置">2.1 &nbsp&nbsp<a href="#BIOS的优化设置" class="headerlink" title="BIOS的优化设置"></a>BIOS的优化设置</h2><ul><li>设置来电自启</li><li>开启快速启动</li></ul><h2 id="安装步骤">2.2 &nbsp&nbsp<a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>下载pve系统镜像：<a href="https://www.proxmox.com/en/downloads/proxmox-virtual-environment/iso">点击跳转</a>（我的情况就是需要下载pve 7.4的iso镜像文件）</li><li>制作U盘启动项：ventoy。拷贝镜像iso文件到U盘，启动选择pve镜像进入，选择图形安装界面。</li><li>同意协议。</li><li>点击option按钮，选择硬盘和ext4格式（我的情况只有一个硬盘，不用设置option，直接下一步）</li><li>国家选择china，时区会自动修改为上海，键盘布局不改。</li><li>设置密码，邮箱随意。</li><li>管理网口，默认第一个做管理（enp1s0，pve系统里面识别的第一个网口，靠近hdmi接口的rj45），第二个做wan口（方便后续维护）。域名hostname设置为pve.lan（这项随便填写都行，有能用的域名可填写上去，可解析到机器用域名管理pve虚拟机）；ip：192.168.1.2；掩码：255.255.255.0；网关：192.168.1.1（留给ikuai的地址），DNS：223.5.5.5。</li><li>查看确认已设置的内容（弹窗），确认安装。</li><li>访问管理地址并登录：<a href="https://192.168.1.2:8006。">https://192.168.1.2:8006。</a></li><li>设置网卡并确保pve能联网。</li></ol><h2 id="升级步骤（7-4-8-0）">2.3 &nbsp&nbsp<a href="#升级步骤（7-4-8-0）" class="headerlink" title="升级步骤（7.4-&gt;8.0）"></a>升级步骤（7.4-&gt;8.0）</h2><ol><li>替换软件源和企业软件源（国内镜像）<div class="tabs" id="74sources"><ul class="nav-tabs"><li class="tab active"><a href="#74sources-1">7.4软件源</a></li><li class="tab"><a href="#74sources-2">7.4企业软件源</a></li></ul><div class="tab-content"><div class="tab-pane active" id="74sources-1"><p>&#x2F;etc&#x2F;apt&#x2F;sources.list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#deb http://ftp.debian.org/debian bullseye main contrib</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free</span><br><span class="line"></span><br><span class="line">#deb http://ftp.debian.org/debian bullseye-updates main contrib</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free</span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free</span><br><span class="line"># security updates</span><br><span class="line">#deb http://security.debian.org bullseye-security main contrib</span><br><span class="line">deb [trusted=yes] https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-security main contrib non-free</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="74sources-2"><p>&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;pve-enterprise.list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#deb https://enterprise.proxmox.com/debian/pve bullseye pve-enterprise</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/proxmox/debian bullseye pve-no-subscription</span><br></pre></td></tr></table></figure></div></div></div></li><li>升级到7.4最新的版本<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt update -y &amp;&amp; apt dist-upgrade -y</span><br><span class="line"></span><br><span class="line">sed -i_orig &quot;s/data.status === &#x27;Active&#x27;/true/g&quot; /usr/share/pve-manager/js/pvemanagerlib.js</span><br><span class="line">sed -i_orig &quot;s/<span class="keyword">if</span> (res === null || res === undefined || \!res || res/<span class="keyword">if</span>(/g&quot; /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js</span><br><span class="line">sed -i_orig &quot;s/.data.status.toLowerCase() !== &#x27;active&#x27;/false/g&quot; /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js</span><br><span class="line">systemctl restart pveproxy</span><br><span class="line"></span><br><span class="line">pveversion</span><br></pre></td></tr></table></figure></li><li>检查兼容性：<code>pve7to8</code></li><li>替换8.0软件源和企业软件源（国内镜像）<div class="tabs" id="80sources"><ul class="nav-tabs"><li class="tab active"><a href="#80sources-1">8.0软件源</a></li><li class="tab"><a href="#80sources-2">8.0企业软件源</a></li></ul><div class="tab-content"><div class="tab-pane active" id="80sources-1"><p>&#x2F;etc&#x2F;apt&#x2F;sources.list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># deb http://ftp.debian.org/debian bookworm main contrib</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free</span><br><span class="line"></span><br><span class="line"># deb http://ftp.debian.org/debian bookworm-updates main contrib</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free</span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free</span><br><span class="line"># security updates</span><br><span class="line"># deb http://security.debian.org bookworm-security main contrib</span><br><span class="line">deb [trusted=yes] https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-security main contrib non-free</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="80sources-2"><p>&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;pve-enterprise.list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># deb https://enterprise.proxmox.com/debian/pve bookworm pve-enterprise</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/proxmox/debian bookworm pve-no-subscription</span><br></pre></td></tr></table></figure></div></div></div></li><li>开始正式升级<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt dist-upgrade</span><br></pre></td></tr></table></figure>升级中会出现一些交互界面，下面是官网的建议（不清楚的选项，可以选择推荐参数）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/etc/issue -&gt; Proxmox VE will auto-generate this file on boot, and it has only cosmetic effects on the login console.</span><br><span class="line">Using the default &quot;No&quot; (keep your currently-installed version) is safe here.</span><br><span class="line"></span><br><span class="line">/etc/lvm/lvm.conf -&gt; Changes relevant for Proxmox VE will be updated, and a newer config version might be useful.</span><br><span class="line">If you did not make extra changes yourself and are unsure it&#x27;s suggested to choose &quot;Yes&quot; (install the package maintainer&#x27;s version) here.</span><br><span class="line"></span><br><span class="line">/etc/ssh/sshd_config -&gt; If you have not changed this file manually, the only differences should be a replacement of ChallengeResponseAuthentication no with KbdInteractiveAuthentication no and some irrelevant changes in comments (lines starting with #).</span><br><span class="line">If this is the case, both options are safe, though we would recommend installing the package maintainer&#x27;s version in order to move away from the deprecated ChallengeResponseAuthentication option. If there are other changes, we suggest to inspect them closely and decide accordingly.</span><br><span class="line"></span><br><span class="line">/etc/default/grub -&gt; Here you may want to take special care, as this is normally only asked for if you changed it manually, e.g., for adding some kernel command line option.</span><br><span class="line">It&#x27;s recommended to check the difference for any relevant change, note that changes in comments (lines starting with #) are not relevant.</span><br><span class="line">If unsure, we suggested to selected &quot;No&quot; (keep your currently-installed version)</span><br></pre></td></tr></table></figure></li><li>去除未订阅提示<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -i_orig &quot;s/data.status === &#x27;Active&#x27;/true/g&quot; /usr/share/pve-manager/js/pvemanagerlib.js</span><br><span class="line">sed -i_orig &quot;s/<span class="keyword">if</span> (res === null || res === undefined || \!res || res/<span class="keyword">if</span>(/g&quot; /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js</span><br><span class="line">sed -i_orig &quot;s/.data.status.toLowerCase() !== &#x27;active&#x27;/false/g&quot; /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js</span><br><span class="line">systemctl restart pveproxy</span><br></pre></td></tr></table></figure></li></ol><div class="note info no-icon"><p>升级若遇到提示<code>Upgrade wants to remove package &#39;proxmox-ve&#39;</code>的话，在升级前尝试执行<code>apt remove linux-image-amd64</code>。</p></div><h2 id="安装遇到的坑">2.4 &nbsp&nbsp<a href="#安装遇到的坑" class="headerlink" title="安装遇到的坑"></a>安装遇到的坑</h2><h3 id="安装到99-时出现unable-to-install-the-EFI-boot-loader-on-dev-sda">2.4.1 &nbsp&nbsp<a href="#安装到99-时出现unable-to-install-the-EFI-boot-loader-on-dev-sda" class="headerlink" title="安装到99%时出现unable to install the EFI boot loader on &#39;&#x2F;dev&#x2F;sda&#39;"></a>安装到99%时出现unable to install the EFI boot loader on &#39;&#x2F;dev&#x2F;sda&#39;</h3><p>报错信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootloader setup errors:</span><br><span class="line">- failed to prepare EFI boot using Grub on &#x27;/dev/sda2&#x27;: unable to install the EFI boot loader on &#x27;/dev/sda&#x27;</span><br></pre></td></tr></table></figure><p>原因：pve 8.0版本镜像īso不兼容此台机器，估计是bug。参考其他帖子说的只保留usb的uefi设备，依旧也会报错。并且因为机器的bios设置也比较繁琐，我反复尝试将其设置为csm模式，机器始终无法以csm模式启动，估计该主板的bios也是魔改过有bug的。因此导致也无法以csm模式安装pve。</p><p>解决方法：安装pve 7.4版本，再升级到pve 8.x。</p><h3 id="usb键盘一直插着时会无法响应的，无法进入并操控BIOS，只有ctrl-alt-delete可以响应">2.4.2 &nbsp&nbsp<a href="#usb键盘一直插着时会无法响应的，无法进入并操控BIOS，只有ctrl-alt-delete可以响应" class="headerlink" title="usb键盘一直插着时会无法响应的，无法进入并操控BIOS，只有ctrl+alt+delete可以响应"></a>usb键盘一直插着时会无法响应的，无法进入并操控BIOS，只有ctrl+alt+delete可以响应</h3><p>原因：估计是BIOS的驱动bug。</p><p>解决方法：先不插键盘启动机器，看屏幕等待主板自检代码走到99阶段，快速插上键盘，摁DEL键。</p><h3 id="hdmi屏幕不显bios">2.4.3 &nbsp&nbsp<a href="#hdmi屏幕不显bios" class="headerlink" title="hdmi屏幕不显bios"></a>hdmi屏幕不显bios</h3><p>主板BIOS驱动不支持普通hdmi小屏幕，自检阶段和BIOS界面显示白屏或者花屏，接大屏驱动板兼容性好点。</p><h3 id="后面加装的RTL8211网卡不识别">2.4.4 &nbsp&nbsp<a href="#后面加装的RTL8211网卡不识别" class="headerlink" title="后面加装的RTL8211网卡不识别"></a>后面加装的RTL8211网卡不识别</h3><p>原因：因为安装pve系统之前未加装好螃蟹卡RTL8211，因此后续加装之后，pve系统并未识别到。</p><p>解决方法：重装pve系统。（驱动源码编译方案，也有编译报错，不好解决，推荐是重装pve，让pve自动打驱动）</p><h3 id="pve重启bug，看门狗导致重启很长时间">2.4.5 &nbsp&nbsp<a href="#pve重启bug，看门狗导致重启很长时间" class="headerlink" title="pve重启bug，看门狗导致重启很长时间"></a>pve重启bug，看门狗导致重启很长时间</h3><p>原因：未查明，只要一重启，就会长时间卡在看门狗的错误提示。</p><p>错误提示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watchgod: watchdog0: watchdog did<span class="number">&#x27;</span>t did <span class="keyword">not</span> stop!</span><br><span class="line"></span><br><span class="line">systemd-shutdown: Failed to finalzie DM services, ignorening.</span><br></pre></td></tr></table></figure><p>解决方法：无法解决，只能长时间等待完成重启或者强制关机重开。</p><h1 id="硬件直通">3 &nbsp&nbsp<a href="#硬件直通" class="headerlink" title="硬件直通"></a>硬件直通</h1><p>IOMMU允许系统设备在虚拟内存中进行寻址，也就是将虚拟内存地址映射为物理内存地址，让实体设备可以在虚拟的内存环境中工作，这样可以帮助系统扩充内存容量，提升性能。</p><p>换而言之，IOMMU可以使VM虚拟机能够接入一些物理设备，比如PCIe中的网卡、声卡、显卡，VM虚拟机可以直接或间接使用这些设备。</p><h2 id="检查硬件是否支持直通（BIOS内查看Advanced高级选项）">3.1 &nbsp&nbsp<a href="#检查硬件是否支持直通（BIOS内查看Advanced高级选项）" class="headerlink" title="检查硬件是否支持直通（BIOS内查看Advanced高级选项）"></a>检查硬件是否支持直通（BIOS内查看Advanced高级选项）</h2><ol><li>开启CPU虚拟化：Intel: VT-X(Intel Virtual Technology)。AMD: AMD-V(SVM, Secure Virtual Machine)。</li><li>为CPU开启硬件虚拟功能：Intel: Intel VT-d。AMD: IOMMU。</li><li>部分主板会有和Intel VT-d&#x2F;IOMMU相关联的<code>Memory Remap Feature</code>设置。</li></ol><div class="note danger no-icon"><p>如果没有VT-d或者IOMMU功能选项，则主板不支持虚拟机直通硬件。</p></div><h2 id="pve提示No-IOMMU-detected">3.2 &nbsp&nbsp<a href="#pve提示No-IOMMU-detected" class="headerlink" title="pve提示No IOMMU detected"></a>pve提示<code>No IOMMU detected</code></h2><p>当pve未启用IOMMU或者硬件不支持直通（已启用IOMMU）时，在ProxmoxVE(PVE)的VM&#x2F;VPS中添加PCI设备时候提示：<code>No IOMMU detected, please activate it.See Documentation for further information</code>.</p><h2 id="pve启用IOMMU">3.3 &nbsp&nbsp<a href="#pve启用IOMMU" class="headerlink" title="pve启用IOMMU"></a>pve启用IOMMU</h2><div class="note info no-icon"><p>内核版本为5.15或之前的，在ProxmoxVE(PVE)系统内核中，需要手动启用IOMMU。5.15版本以后的ProxmoxVE(PVE)系统内核自带默认开启了IOMMU支持。</p><p>但我的硬件本身不支持VT-d，因此并未自动启用IOMMU，也可能是因为从7.4升级到8.0的缘故。</p></div><div class="tabs" id="引导类型"><ul class="nav-tabs"><li class="tab active"><a href="#引导类型-1">GRUD引导类型（PVE默认引导方式）</a></li><li class="tab"><a href="#引导类型-2">systemd-boot引导类型（非PVE现行版本常见引导方式）</a></li></ul><div class="tab-content"><div class="tab-pane active" id="引导类型-1"><ol><li>编辑grub文件：<code>nano /etc/default/grub</code></li><li>找到GRUB_CMDLINE_LINUX_DEFAULT这一行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GRUB_DEFAULT=0</span><br><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=`lsb_release -i -s &lt;strong&gt;2&lt;/strong&gt;&gt; /dev/null || echo Debian`</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li>根据CPU类型修改<div class="tabs" id="grub-cpu类型"><ul class="nav-tabs"><li class="tab active"><a href="#grub-cpu类型-1">Intel CPU</a></li><li class="tab"><a href="#grub-cpu类型-2">AMD CPU</a></li></ul><div class="tab-content"><div class="tab-pane active" id="grub-cpu类型-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet intel_iommu=on&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="grub-cpu类型-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet amd_iommu=on&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div></div></div></li><li>更新grub：<code>update-grub</code></li><li>重启PVE</li></ol></div><div class="tab-pane" id="引导类型-2"><ol><li>编辑cmdline：<code>nano /etc/kernel/cmdline</code>。（若不存在，则新建该文件）</li><li>根据CPU类型在第一行末尾添加：<div class="tabs" id="systemd-boot-cpu类型"><ul class="nav-tabs"><li class="tab active"><a href="#systemd-boot-cpu类型-1">Intel CPU</a></li><li class="tab"><a href="#systemd-boot-cpu类型-2">AMD CPU</a></li></ul><div class="tab-content"><div class="tab-pane active" id="systemd-boot-cpu类型-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quiet intel_iommu=on</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="systemd-boot-cpu类型-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quiet amd_iommu=on</span><br></pre></td></tr></table></figure></div></div></div></li></ol></div></div></div><p>验证IOMMU是否启用：<code>dmesg | grep -e DMAR -e IOMMU</code>。输出显示<code>DMAR: IOMMU enabled</code>证明已启用，虚拟机分配PCI设备时可见。若无输出，需排查故障。</p><h2 id="pve启用PT模式">3.4 &nbsp&nbsp<a href="#pve启用PT模式" class="headerlink" title="pve启用PT模式"></a>pve启用PT模式</h2><div class="note info no-icon"><p>PT模式：会在IOMMU需要使用时候才启动，适配器不需要使用 DMA 转换到内存，因此可以提高其他没有分配过设备的性能。</p></div><ol><li>编辑grub文件：<code>nano /etc/default/grub</code></li><li>找到GRUB_CMDLINE_LINUX_DEFAULT这一行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GRUB_DEFAULT=0</span><br><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=`lsb_release -i -s &lt;strong&gt;2&lt;/strong&gt;&gt; /dev/null || echo Debian`</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li>附加参数iommu&#x3D;pt，Intel和AMD芯片均可使用这个参数。</li><li>添加模块设置（5.4内核需自行添加，现行版本自带有添加）：<code>nano /etc/modules</code>。没有如下内容需添加。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vfio</span><br><span class="line">vfio_iommu_type1</span><br><span class="line">vfio_pci</span><br><span class="line">vfio_virqfd</span><br></pre></td></tr></table></figure></li><li>刷新 initramfs：<code>update-initramfs -u -k all</code></li><li>更新 grub：<code>update-grub</code></li></ol><h1 id="创建虚拟机">4 &nbsp&nbsp<a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h1><h2 id="PVE基础设置">4.1 &nbsp&nbsp<a href="#PVE基础设置" class="headerlink" title="PVE基础设置"></a>PVE基础设置</h2><ol><li>访问管理地址并登录：<a href="https://192.168.1.2:8006，帐号：root。">https://192.168.1.2:8006，帐号：root。</a></li><li>根据硬件网卡情况，添加并设置好虚拟网桥Linux Bridge：创建&gt;Linux Bridge&gt;桥接接口填写物理网口地址名称。以我的机器为例，机器三个物理网口，PVE新建5个网桥，前三个网桥和物理网口绑定，第四个网桥用作iKuai和OpenWrt之间的传输，第五个网桥用作其他虚拟机系统的传输。</li></ol><h2 id="安装iKuai">4.2 &nbsp&nbsp<a href="#安装iKuai" class="headerlink" title="安装iKuai"></a>安装iKuai</h2><ol><li>下载iKuai镜像：<a href="https://www.ikuai8.com/component/download">点击跳转</a></li><li>local-内容-上传：iKuai的安装镜像。</li><li>创建虚拟机，命名虚拟机名称ikuai，VM编号100。</li><li>CD&#x2F;DVD光盘镜像文件选择刚上传的ISO镜像。</li><li>硬盘分配2G，添加EFI磁盘（不勾选添加密钥），CPU给2核（KVM64），内存分配4G（64位iKuai要求4G内存），网卡模型选择VirtIO（半虚拟化）。</li><li>完成新建后，在硬件标签页中继续完成添加所有网桥，网桥的防火墙全部关掉（使用iKuai的），模型都选择半虚拟化。</li><li>在选项标签页中把「开机自启动」开启，启动顺序设置为1，引导顺序只开disk‘xxxx’磁盘，把网络启动关掉，CD启动上移到第一位。</li><li>点击启动虚拟机，完成安装即可。</li><li>iKuai内识别的第一个网卡设置为lan1。</li><li>输入字母o回车进入其「其他选项」，开启外网访问web。</li><li>访问管理地址并登录：<a href="https://192.168.1.1:80。默认用户：admin。默认密码：admin。">https://192.168.1.1:80。默认用户：admin。默认密码：admin。</a></li></ol><h2 id="安装OpenWrt">4.3 &nbsp&nbsp<a href="#安装OpenWrt" class="headerlink" title="安装OpenWrt"></a>安装OpenWrt</h2><h3 id="OpenWrt镜像的选择">4.3.1 &nbsp&nbsp<a href="#OpenWrt镜像的选择" class="headerlink" title="OpenWrt镜像的选择"></a>OpenWrt镜像的选择</h3><ul><li><a href="https://openwrt.mpdn.fun:8443/?dir=lede/x86_64">Bleach OpenWrt</a>：推荐。内置SmartDNS，软件包空间设置为1G，剩余五百多兆。</li><li><a href="https://drive.google.com/drive/folders/1PsS3c0P7a4A4KY8plQg4Fla8ZI-PGBb1">eSir GDQ 高大全</a>：eSir的高大全固件。不推荐。没有内置SmartDNS拓展（我测试时安装SmartDNS并未出现有服务项，无效）。并且相较于Blench版本，较为繁琐。软件包空间只剩余几兆，需自己手动扩盘。</li></ul><h3 id="安装步骤-1">4.3.2 &nbsp&nbsp<a href="#安装步骤-1" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li>创建虚拟机，命名虚拟机名称openwrt，VM编号101。</li><li>CD&#x2F;DVD光盘镜像文件设置为无介质。</li><li>硬盘随便分配（后续会删除），添加EFI磁盘（不勾选添加密钥），CPU给4核（KVM64），内存分配4G，网卡模型选择VirtIO（半虚拟化）。</li><li>网桥只选择第四个网桥（用作iKuai和OpenWrt之间的传输），网卡的防火墙全部关掉（使用iKuai的），模型选择半虚拟化。</li><li>下载OpenWrt镜像：<a href="#OpenWrt%E9%95%9C%E5%83%8F%E7%9A%84%E9%80%89%E6%8B%A9">见上一小节</a></li><li>local-内容-上传：OpenWrt的镜像。</li><li>向虚拟机导入OpenWrt镜像：<code>qm importdisk 101 /var/lib/vz/template/iso/bleach-plus-20230826-openwrt-x86-64-generic-squashfs-combined-efi.img local-lvm</code>。（直接写盘即可，无需安装）。</li><li>在pve管理页面中，加载刚才导入镜像生成的磁盘。</li><li>在选项标签页中把「开机自启动」开启，启动顺序设置为2，引导顺序只开disk‘xxxx’磁盘，把网络启动关掉。</li><li>点击启动虚拟机。</li><li>pve中用shell：<code>vi /etc/config/network</code>，将lan口ip改为<code>192.168.1.3</code>，<code>reboot</code>重启。vim编辑：按i进入修改模式，按esc退出编辑模式，输入 :wq回车保存修改。</li><li>访问管理地址并登录：<a href="https://192.168.1.3。默认用户：root。默认密码：password。">https://192.168.1.3。默认用户：root。默认密码：password。</a></li></ol><h2 id="创建虚拟机遇到的坑">4.4 &nbsp&nbsp<a href="#创建虚拟机遇到的坑" class="headerlink" title="创建虚拟机遇到的坑"></a>创建虚拟机遇到的坑</h2><h3 id="添加EFI磁盘后，启动无法引导磁盘，出现shell界面。">4.4.1 &nbsp&nbsp<a href="#添加EFI磁盘后，启动无法引导磁盘，出现shell界面。" class="headerlink" title="添加EFI磁盘后，启动无法引导磁盘，出现shell界面。"></a>添加EFI磁盘后，启动无法引导磁盘，出现shell界面。</h3><p>原因：创建EFI磁盘时，勾选了添加密钥。</p><p>解决方法：创建EFI磁盘时，取消勾选添加密钥。</p><h3 id="安装windows镜像，无法识别找到磁盘">4.4.2 &nbsp&nbsp<a href="#安装windows镜像，无法识别找到磁盘" class="headerlink" title="安装windows镜像，无法识别找到磁盘"></a>安装windows镜像，无法识别找到磁盘</h3><p>原因：scsi不适合windows镜像，windows安装解决识别不到硬盘。</p><p>解决方法：创建硬盘时，总线&#x2F;设备选择：sata硬盘或者IDE。</p><h3 id="安装windows镜像，无法识别找到磁盘-1">4.4.3 &nbsp&nbsp<a href="#安装windows镜像，无法识别找到磁盘-1" class="headerlink" title="安装windows镜像，无法识别找到磁盘"></a>安装windows镜像，无法识别找到磁盘</h3><p>现象：当网卡设置为virtio模型时，安装并进入到windows系统后，网卡无驱动。</p><p>原因：windows系统自带的驱动无此虚拟硬件的驱动。</p><p>解决方式：加载virtio镜像，并运行x64程序安装驱动即可。</p><p>VirtIO镜像下载地址：<a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/">点击跳转</a></p><h1 id="iKuai-OpenWRT-做旁路由网络拓扑">5 &nbsp&nbsp<a href="#iKuai-OpenWRT-做旁路由网络拓扑" class="headerlink" title="iKuai +OpenWRT 做旁路由网络拓扑"></a>iKuai +OpenWRT 做旁路由网络拓扑</h1><p>iKuai作为主路由，负责拨号及DHCP，OpenWRT做旁路由。SmartDNS+AdGuardHome设置分流与去广告。SmartDNS作为DNS管理并提供DNS缓存，实现国内国外DNS分流，彻底解决DNS污染问题、实现秒开网页。同时搭配AdGuardHome实现整个局域网去广告。</p><p>DNS转发流程：设置最核心的部分就是DNS转发端口的衔接，就是把DNSMASQ、Adguardhome、SmartDNS三个插件里的DNS服务器功能分成三个层级，实现层层转发。依次是第一级DNSMASQ，第二级Adguardhome，第三级SmartDNS。</p><h2 id="iKuai的设置">5.1 &nbsp&nbsp<a href="#iKuai的设置" class="headerlink" title="iKuai的设置"></a>iKuai的设置</h2><ul><li>系统设置&gt;重启关机&gt;添加一个重启计划：每天05:00时重启。</li><li>网络设置&gt;内外网设置<ul><li>外网接口（选择iKuai识别到的第二个网口）：填入宽带拨号信息。</li><li>内网接口（iKuai识别到的第一个网口，IP地址192.168.1.1）：链路桥接（选择剩余的其他全部接口）</li></ul></li><li>DHCP设置&gt;DHCP服务端<ul><li>单iKuai版：<ul><li>客户端地址：192.168.1.10-192.168.1.254（1-9留给专用设备的管理地址）</li><li>子网掩码：255.255.255.0</li><li>网关：192.168.1.1</li><li>首选DNS：223.5.5.5</li><li>备选DNS：114.114.114.114</li></ul></li><li>iKuai+OpenWrt版本：<ul><li>客户端地址：192.168.1.10-192.168.1.254（1-9留给专用设备的管理地址）</li><li>子网掩码：255.255.255.0</li><li>网关：192.168.1.3</li><li>首选DNS：192.168.1.3</li><li>备选DNS：192.168.1.3</li></ul></li></ul></li><li>DNS设置&gt;DNS设置<ul><li>单iKuai版：<ul><li>首选DNS：223.5.5.5</li><li>备选DNS：114.114.114.114</li></ul></li><li>iKuai+OpenWrt版本：<ul><li>首选DNS：192.168.1.3</li><li>备选DNS：192.168.1.3</li></ul></li></ul></li><li>UPnP设置&gt;UPnP设置<ul><li>UPnP即插即用服务：开启</li><li>允许内网IP映射：0.0.0.0-255.255.255.255</li><li>默认线路设置：任意</li><li>掉线检测：开启</li><li>检测周期：2</li><li>定时重启：开启</li><li>重启周期：全选</li><li>重启时间：05:00。</li></ul></li></ul><h2 id="OpenWrt设置">5.2 &nbsp&nbsp<a href="#OpenWrt设置" class="headerlink" title="OpenWrt设置"></a>OpenWrt设置</h2><h3 id="定时重启">5.2.1 &nbsp&nbsp<a href="#定时重启" class="headerlink" title="定时重启"></a>定时重启</h3><p>系统&gt;定时重启：启用，设置每天05:00。</p><h3 id="网络">5.2.2 &nbsp&nbsp<a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="接口-LAN">5.2.2.1 &nbsp&nbsp<a href="#接口-LAN" class="headerlink" title="接口&gt;LAN"></a>接口&gt;LAN</h4><ul><li>IPv4地址：192.168.1.3。管理OpenWrt的地址。</li><li>和ikuai一致保证同一个网段。</li><li>IPv4网关：指向iKuai的网关。保证OpenWrt的上网数据传输到iKuai再传输到外网。</li><li>使用自定义的DNS服务器：223.5.5.5（初始先设置阿里云DNS保证设置过程的上网）。后面等设置好SmartDNS之后改由OpenWrt代理，即输入192.168.1.3。</li><li>关闭DHCP服务，统一由iKuai分配。</li><li>禁用掉IPv6服务。</li><li>物理设置：桥接接口。（因为选用的也是）</li><li>lan高级设置：不勾选IPv6，勾选【开启开机自动运行】和【强制链路】。</li></ul><h4 id="Turbo-ACC-加速">5.2.2.2 &nbsp&nbsp<a href="#Turbo-ACC-加速" class="headerlink" title="Turbo ACC 加速"></a>Turbo ACC 加速</h4><p>只开启前三个即可，DNS缓存后面由SmartDNS来管理。</p><h4 id="防火墙设置">5.2.2.3 &nbsp&nbsp<a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h4><ul><li>SYN-flood 防御：关闭（此项开启关闭都行）</li><li>丢弃无效数据包：启用（此项开启关闭都行）</li><li>启用FullCone-NAT：高性能模式</li><li>入站数据、出站数据、转发都设置为接受。</li><li>lan口开启：IP 动态伪装（只保留lan口的规格，其他接口全部删除）</li><li>防火墙自定义规则（一般默认就有前四条规则，没有需加上）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p udp —dport 53 -j REDIRECT —to-ports 53</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp —dport 53 -j REDIRECT —to-ports 53</span><br><span class="line">[ -n “$(command -v ip6tables)” ] &amp;&amp; ip6tables -t nat -A PREROUTING -p udp —dport 53 -j REDIRECT —to-ports 53</span><br><span class="line">[ -n “$(command -v ip6tables)” ] &amp;&amp; ip6tables -t nat -A PREROUTING -p tcp —dport 53 -j REDIRECT —to-ports 53</span><br><span class="line">iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure></li></ul><h3 id="SmartDNS">5.2.3 &nbsp&nbsp<a href="#SmartDNS" class="headerlink" title="SmartDNS"></a>SmartDNS</h3><div class="note info no-icon"><p>Bleach OpenWrt固件自带SmartDNS，eSir GDQ高大全固件需自行手动安装。</p></div><ul><li>基本设置<ul><li>启用</li><li>本地端口6053</li></ul></li><li>高级设置<ul><li>开启TCP服务器</li><li>勾选域名预加载</li><li>勾选缓存过期服务</li><li>缓存大小设为：1000000</li><li>域名TTL最大值设为：3600</li></ul></li><li>第二DNS服务器<ul><li>启用</li><li>本地端口5335</li><li>TCP服务器</li><li>服务器组：oversea</li><li>跳过测速</li><li>跳过address规则</li><li>跳过address SOA(#)规则</li><li>跳过双栈优选</li><li>跳过cache</li><li>停用IPV6地址解析</li></ul></li><li>上游服务器（添加DNS的设置里面可以设置服务器组）<ul><li>服务器组名称：china（10条左右，包含iKuai路由宽带拨号返回的两个宽带供应商提供的DNS）</li><li>服务器组名称：oversea（10条左右）</li></ul></li><li>域名规则<ul><li>服务器组：china</li><li>域名分流设置：跳过测试</li></ul></li><li>自定义设置（只设置两条，其他全部注释掉）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind:6053 -group china</span><br><span class="line">bind:5335 -group oversea</span><br></pre></td></tr></table></figure></li><li>保存&amp;应用</li></ul><h3 id="AdGuard-Home">5.2.4 &nbsp&nbsp<a href="#AdGuard-Home" class="headerlink" title="AdGuard Home"></a>AdGuard Home</h3><h4 id="手动更新内核">5.2.4.1 &nbsp&nbsp<a href="#手动更新内核" class="headerlink" title="手动更新内核"></a>手动更新内核</h4><ol><li>下载最新的AdGuardHome内核（AdGuardHome_linux_amd64.tar.gz）：<a href="https://github.com/AdguardTeam/AdGuardHome/releases">点击跳转</a></li><li>解压获取「AdGuardHome」文件。</li><li>使用WinSCP登录openwrt虚拟机，进入到路径<code>/usr/bin/AdGuardHome/</code>，上传「AdGuardHome」文件。右击属性，分配权限0755（rwxr-xr-x）。</li></ol><div class="note info no-icon"><p>能科学上网时，点击检查更新，直接更新核心即可。</p></div><h4 id="设置AdGuard-Home">5.2.4.2 &nbsp&nbsp<a href="#设置AdGuard-Home" class="headerlink" title="设置AdGuard Home"></a>设置AdGuard Home</h4><ul><li>启用</li><li>AdGuardHome重定向模式：作为dnsmasq的上游服务器</li><li>详细日志</li><li>开机后网络准备好时重启</li><li>在关机时备份工作目录文件（所有的选项）</li><li>打开192.168.1.3:3000地址并配置</li><li>网页管理界面&gt;监听接口&gt;所有接口，端口号设置为默认的3000</li><li>DNS 服务器&gt;监听接口&gt;所有接口，端口号设置为5351</li><li>网页管理界面登录密码</li><li>设置&gt;常规设置&gt;使用过滤器和Hosts文件以拦截指定域名（其他选项全部关闭）</li><li>设置&gt;DNS设置<ul><li>上游 DNS 服务器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6053</span><br><span class="line">127.0.0.1:5335</span><br></pre></td></tr></table></figure><ul><li>并行请求</li><li>Bootstrap DNS：<code>127.0.0.1:6053</code></li><li>应用</li></ul></li><li>DNS服务配置<ul><li>速度限制：0</li><li>DNS 缓存配置：都空着（采用上游DNS服务器，让SmartDNS来管理）</li></ul></li></ul></li><li>设置&gt;过滤器&gt;DNS黑名单设置（将阻止匹配 DNS 拦截清单的域名）：综合性的规则列表启用几个即可。</li></ul><h3 id="DNSMASQ设置">5.2.5 &nbsp&nbsp<a href="#DNSMASQ设置" class="headerlink" title="DNSMASQ设置"></a>DNSMASQ设置</h3><p>打开网络&gt;DHCP&#x2F;DNS。主要是解除DNSMASQ的DNS功能，只保留转发功能，让DNSMASQ作为AdGuard Home的下级服务生效。</p><ul><li>DNS转发：<code>127.0.0.1#5351</code>。如果未自动设置成这个，手动强制改成这个。</li><li>HOSTS 和解析文件：忽略掉解析文件，不用DNSMASQ的解析。</li><li>高级设置<ul><li>DNS服务器端口：53</li><li>DNS查询缓存的大小：0</li><li>最大并发查询数：1500</li></ul></li><li>保存&amp;应用</li></ul><h3 id="OpenClash">5.2.6 &nbsp&nbsp<a href="#OpenClash" class="headerlink" title="OpenClash"></a>OpenClash</h3><h4 id="更新客户端">5.2.6.1 &nbsp&nbsp<a href="#更新客户端" class="headerlink" title="更新客户端"></a>更新客户端</h4><ol><li>下载客户端安装包：<a href="https://github.com/vernesong/OpenClash/releases">点击跳转</a></li><li>使用WinSCP登录openwrt虚拟机，进入到路径家目录home，上传安装包，运行安装<code>opkg install ./luci-app-openclash_0.45.141-beta_all.ipk</code>。如果报错，尝试<code>opkg update</code>。</li></ol><h4 id="手动更新内核-1">5.2.6.2 &nbsp&nbsp<a href="#手动更新内核-1" class="headerlink" title="手动更新内核"></a>手动更新内核</h4><p>内核下载地址：</p><ul><li>老的Release页面<ul><li><a href="https://github.com/vernesong/OpenClash/releases/tag/Clash">Dev 内核</a></li><li><a href="https://github.com/vernesong/OpenClash/releases/tag/TUN-Premium">Tun 内核</a></li><li><a href="https://github.com/vernesong/OpenClash/releases/tag/TUN">Tun 游戏内核</a></li></ul></li><li>当前发布的最新内核<ul><li><a href="https://github.com/vernesong/OpenClash/tree/core/master/dev">Dev 内核</a></li><li><a href="https://github.com/vernesong/OpenClash/tree/core/master/premium">Tun 内核</a></li><li><a href="https://github.com/vernesong/OpenClash/tree/core/master/meta">Meta 内核</a></li></ul></li></ul><div class="note danger no-icon"><p>新的内核只支持fake-ip，需要上传Meta内核。</p></div><div class="note info no-icon"><p>能科学上网时，点击检查并更新，直接更新核心即可。</p></div><p>更新步骤：</p><ol><li>下载内核。</li><li>使用WinSCP登录openwrt虚拟机，进入到路径<code>/etc/openclash/core</code>，上传内核文件。右击属性，分配权限0755（rwxr-xr-x）。</li></ol><p>内核对应的名称（压缩包解压出来的名称不一定对应，需手动修改）：</p><ul><li>Dev 内核: clash</li><li>Tun 内核: clash_tun</li><li>Meta 内核: clash_meta</li></ul><h4 id="OpenClash设置">5.2.6.3 &nbsp&nbsp<a href="#OpenClash设置" class="headerlink" title="OpenClash设置"></a>OpenClash设置</h4><ul><li>运行状态：启动OPENCLASH</li><li>插件设置<ul><li>模式设置&gt;运行模式：Fake-IP（TUN-混合）模式【UDP-TUN，TCP-转发】</li><li>DNS设置&gt;本地DNS劫持：停用</li><li>GEO数据库订阅：设置自动更新</li><li>大陆白名单订阅：设置自动更新</li></ul></li><li>配置订阅：设置自动更新，更新间隔60分钟</li></ul><h3 id="扩容Overlay软件安装空间">5.2.7 &nbsp&nbsp<a href="#扩容Overlay软件安装空间" class="headerlink" title="扩容Overlay软件安装空间"></a>扩容Overlay软件安装空间</h3><ol><li>关闭openwrt虚拟机。</li><li>硬件&gt;硬盘&gt;更多，调整磁盘大小（只能增加大小，按需增加所需硬盘的空间大小）。</li><li>打开openwrt虚拟机。</li><li>系统&gt;磁盘管理L：将新增磁盘大小新建一个分区并格式化为ext4，保存并应用</li><li>挂载刚才新增的分区，举例sda3：<code>mount /dev/sda3 /mnt/sda3</code>，保存并应用。</li><li>拷贝源overlay目录的文件到新分区内：<code>cp -r /overlay/* /mnt/sda3</code>。</li><li>系统&gt;挂载点：添加sda3挂载点为「作为外部overlay使用（&#x2F;overlay）」，保存并应用。</li><li>重启openwrt虚拟机，检查扩容情况。</li><li>根据情况可能需手动移除之前挂载的<code>/mnt/sda3</code>状态。</li></ol><h1 id="后记">6 &nbsp&nbsp<a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><del>这光猫还是有断流情况，估计是过热导致掉线，后续考虑下加装小风扇。</del></p><p>断流降速故障已查明：虚拟网卡模型设置为Intel E1000导致的故障，重设为virtio半虚拟化即可解决。</p><h1 id="参考文献">7 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Installation Failing: &quot;Failed to prepare EFI boot using Grub&quot;[EB&#x2F;OL]. <a href="https://forum.proxmox.com/threads/installation-failing-failed-to-prepare-efi-boot-using-grub.122002/">https://forum.proxmox.com/threads/installation-failing-failed-to-prepare-efi-boot-using-grub.122002/</a>.<br>[2] 软路由科普系列 篇二：PVE安装iKuai OpenWrt 旁路由 基础设置 保姆级全教程[EB&#x2F;OL]. <a href="https://post.smzdm.com/p/awrx4lxm/">https://post.smzdm.com/p/awrx4lxm/</a>.<br>[3] ProxmoxVE 7.4 升级到 8.0，详细步骤[EB&#x2F;OL]. <a href="https://blog.margrop.net/post/pve-7-upgrade-to-8/">https://blog.margrop.net/post/pve-7-upgrade-to-8/</a>.<br>[4] PVE 联网及更换国内源[EB&#x2F;OL]. <a href="https://www.cnblogs.com/pdblogs/p/16218543.html">https://www.cnblogs.com/pdblogs/p/16218543.html</a>.<br>[5] Force update from unsigned repository[EB&#x2F;OL]. <a href="https://askubuntu.com/questions/732985/force-update-from-unsigned-repository">https://askubuntu.com/questions/732985/force-update-from-unsigned-repository</a>.<br>[6] ProxmoxVE(PVE) 启用 IOMMU[EB&#x2F;OL]. <a href="https://www.insilen.com/post/501.html">https://www.insilen.com/post/501.html</a>.<br>[7] Enable IOMMU or VT-d in your motherboard BIOS[EB&#x2F;OL]. <a href="https://us.informatiweb.net/tutorials/it/bios/enable-iommu-or-vt-d-in-your-bios.html">https://us.informatiweb.net/tutorials/it/bios/enable-iommu-or-vt-d-in-your-bios.html</a>.<br>[8] ProxmoxVE(PVE) 使用 IMG 镜像文件，img 转 qcow2[EB&#x2F;OL]. <a href="https://www.lxtx.tech/index.php/archives/65/">https://www.lxtx.tech/index.php/archives/65/</a>.<br>[9]『软路由踩坑指南』篇三：ESXi 8.0 虚拟机安装 iKuai 主路由及保姆级配置[EB&#x2F;OL]. <a href="https://post.smzdm.com/p/a5op28x7/">https://post.smzdm.com/p/a5op28x7/</a>.<br>[10]『软路由踩坑指南』篇四：ESXi 8.0 虚拟机安装 openWrt 路由系统终极指南[EB&#x2F;OL]. <a href="https://post.smzdm.com/p/a7ngxeel/">https://post.smzdm.com/p/a7ngxeel/</a>.<br>[11]『软路由踩坑指南』篇五：OpenWrt 旁路由进阶篇 SmartDNS+AdGuardHome 设置 DNS 分流、秒开网页、去广告[EB&#x2F;OL]. <a href="https://post.smzdm.com/p/axz6z7w9/">https://post.smzdm.com/p/axz6z7w9/</a>.<br>[12] [openwrt(x86)] OPenWRT 旁路由 +MosDNS+OpenClash+AdGuard Home 傻瓜配置图文教程[EB&#x2F;OL]. <a href="https://www.right.com.cn/forum/thread-8284982-1-1.html">https://www.right.com.cn/forum/thread-8284982-1-1.html</a>.<br>[13] OpenWrt 扩容 Overlay 和 Docker 软件安装空间教程（内置硬盘版）附：Samba 网络共享设置[EB&#x2F;OL]. <a href="https://www.right.com.cn/forum/thread-7470757-1-1.html">https://www.right.com.cn/forum/thread-7470757-1-1.html</a>.<br>[14] [OpenWrt] 使用 OpenClash 科学上网[EB&#x2F;OL]. <a href="http://suyu0925.github.io/blog/2022/07/25/openwrt-openclash/">http://suyu0925.github.io/blog/2022/07/25/openwrt-openclash/</a>.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;div class=&quot;note info no-icon&quot;&gt;&lt;p&gt;推荐教程：张大妈网站的大佬-纵笔浮生的「&lt;a</summary>
        
      
    
    
    
    <category term="software" scheme="https://mister-kin.github.io/categories/software/"/>
    
    
    <category term="系统" scheme="https://mister-kin.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="linux" scheme="https://mister-kin.github.io/tags/linux/"/>
    
    <category term="pve系统" scheme="https://mister-kin.github.io/tags/pve%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="软路由" scheme="https://mister-kin.github.io/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/"/>
    
    <category term="科学上网" scheme="https://mister-kin.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    <category term="ikuai" scheme="https://mister-kin.github.io/tags/ikuai/"/>
    
    <category term="openwrt" scheme="https://mister-kin.github.io/tags/openwrt/"/>
    
    <category term="虚拟机" scheme="https://mister-kin.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Python总结笔记</title>
    <link href="https://mister-kin.github.io/code/python/"/>
    <id>https://mister-kin.github.io/code/python/</id>
    <published>2023-09-08T20:26:25.000Z</published>
    <updated>2023-10-12T19:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-语法摘记">1 &nbsp&nbsp<a href="#Python-语法摘记" class="headerlink" title="Python 语法摘记"></a>Python 语法摘记</h1><p>python在相对路径import导入时，报名前面的小数点.是必要的，python3之后都是严格模式。</p><h1 id="安装python的踩坑记录">2 &nbsp&nbsp<a href="#安装python的踩坑记录" class="headerlink" title="安装python的踩坑记录"></a>安装python的踩坑记录</h1><h2 id="vscode-无法设置python解释器">2.1 &nbsp&nbsp<a href="#vscode-无法设置python解释器" class="headerlink" title="vscode 无法设置python解释器"></a>vscode 无法设置python解释器</h2><p>原因：安装路径在<code>C:\Program Files</code>，vscode权限不够时会导致无法设置python解释器。</p><p>解决方法：安装路径直接按默认路径，不装program路径。</p><h2 id="pip安装某些包异常">2.2 &nbsp&nbsp<a href="#pip安装某些包异常" class="headerlink" title="pip安装某些包异常"></a>pip安装某些包异常</h2><p>情况：如果pip安装某些包一直有异常，反复安装卸载包都无法解决的话，并且确认不是包的问题的话。</p><p>原因：python环境异常。</p><p>解决方法：重装python。</p><ol><li>直接删除python主安装路径的文件</li><li>运行安装程序repair</li><li>点击卸载，再点击安装（必须要卸载再安装，否则site-packages路径下没有任何包，repair操作不会恢复这个路径的文件）</li></ol><h1 id="卸载python">3 &nbsp&nbsp<a href="#卸载python" class="headerlink" title="卸载python"></a>卸载python</h1><h2 id="卸载清除已安装的pip包的bat批处理脚本">3.1 &nbsp&nbsp<a href="#卸载清除已安装的pip包的bat批处理脚本" class="headerlink" title="卸载清除已安装的pip包的bat批处理脚本"></a>卸载清除已安装的pip包的bat批处理脚本</h2><div class="tabs" id="purge_pip_packages"><ul class="nav-tabs"><li class="tab active"><a href="#purge_pip_packages-1">python 3.11</a></li><li class="tab"><a href="#purge_pip_packages-2">python 3.10</a></li><li class="tab"><a href="#purge_pip_packages-3">python 3.9</a></li></ul><div class="tab-content"><div class="tab-pane active" id="purge_pip_packages-1"><p>purge_py311_packages.bat</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">py -<span class="number">3</span>.<span class="number">11</span> -m pip freeze &gt; py311_requirements.txt</span><br><span class="line">py -<span class="number">3</span>.<span class="number">11</span> -m pip uninstall -r py311_requirements.txt -y</span><br><span class="line"><span class="built_in">del</span> py311_requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">pause</span></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="purge_pip_packages-2"><p>purge_py310_packages.bat</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">py -<span class="number">3</span>.<span class="number">10</span> -m pip freeze &gt; py310_requirements.txt</span><br><span class="line">py -<span class="number">3</span>.<span class="number">10</span> -m pip uninstall -r py310_requirements.txt -y</span><br><span class="line"><span class="built_in">del</span> py310_requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">pause</span></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="purge_pip_packages-3"><p>purge_py39_packages.bat</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">py -<span class="number">3</span>.<span class="number">9</span> -m pip freeze &gt; py39_requirements.txt</span><br><span class="line">py -<span class="number">3</span>.<span class="number">9</span> -m pip uninstall -r py39_requirements.txt -y</span><br><span class="line"><span class="built_in">del</span> py39_requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">pause</span></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></div></div></div><h2 id="清除pip缓存">3.2 &nbsp&nbsp<a href="#清除pip缓存" class="headerlink" title="清除pip缓存"></a>清除pip缓存</h2><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">pip cache purge</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h1 id="python的包管理">4 &nbsp&nbsp<a href="#python的包管理" class="headerlink" title="python的包管理"></a>python的包管理</h1><p>Python包管理是指创建、发布和安装Python包的过程。Python包是一种封装和分发Python代码的方式，以便于其他开发者使用和共享。Python包管理涉及的三个关键组件：PyPI、setuptools和wheel。</p><h2 id="PyPI">4.1 &nbsp&nbsp<a href="#PyPI" class="headerlink" title="PyPI"></a>PyPI</h2><p>Python软件包索引（PyPI）是一个在线存储库，用于发布和查找Python包。PyPI允许开发者上传他们的包，并提供一个中心化的搜索引擎，让其他开发者能够找到并安装这些包。PyPI通过pip（Python包安装器）来安装和管理包。</p><p>基本的使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 升级pip</span></span><br><span class="line">python -m pip install --upgrade pip</span><br><span class="line">pip install pip -U</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip设定清华源（升级 pip 到最新的版本 (&gt;=10.0.0) 后进再进行配置）</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="comment"># win平台pip缓存路径：\%LocalAppData\%&gt;pip&gt;Cache</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时一次性使用镜像源安装包</span></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">pip install &lt;package_name&gt;</span><br><span class="line"><span class="comment"># 升级包</span></span><br><span class="line">pip install --upgrade &lt;package_name&gt;</span><br><span class="line"><span class="comment"># 卸载包</span></span><br><span class="line">pip uninstall &lt;package_name&gt;</span><br><span class="line"><span class="comment"># 显示包文件信息</span></span><br><span class="line">pip show --files &lt;package_name&gt;</span><br><span class="line"><span class="comment"># 列出已过时的包</span></span><br><span class="line">pip list --outdated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载全部包</span></span><br><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line">pip uninstall -r requirements.txt -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装全部包</span></span><br><span class="line">pip install -r requirements.txt --upgrade</span><br></pre></td></tr></table></figure><h2 id="setuptools和wheel">4.2 &nbsp&nbsp<a href="#setuptools和wheel" class="headerlink" title="setuptools和wheel"></a>setuptools和wheel</h2><p>setuptools是一个Python包管理工具，用于创建、构建和发布Python包。setuptools通过提供易于使用的命令行接口和配置文件（如setup.py）来简化包管理过程。通过使用setuptools，开发者可以方便地将他们的代码打包成可分发的格式，如源代码分发（sdist）和wheel分发（bdist_wheel）。</p><p>wheel是一种Python分发格式，用于提高安装速度和兼容性。与源代码分发（sdist）相比，wheel分发是预编译的，这意味着它们不需要在安装过程中进行编译。这使得wheel分发在安装速度和跨平台兼容性方面具有优势。</p><p>基本使用：</p><ul><li>安装setuptools和wheel：<code>pip install setuptools wheel</code></li><li>创建setup.py文件：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&quot;my_package&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;0.1&quot;</span>,</span><br><span class="line">    packages=find_packages(),</span><br><span class="line">    install_requires=[</span><br><span class="line">        <span class="string">&quot;requests&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>构建源代码分发和wheel分发：<code>python setup.py sdist bdist_wheel</code></li><li>安装twine并发布包到PyPI：<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install twine</span><br><span class="line">twine upload dist/*</span><br></pre></td></tr></table></figure></li><li>安装wheel分发的包：<code>pip install dist/my_package-0.1-py3-none-any.whl</code></li></ul><h1 id="其他">5 &nbsp&nbsp<a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>官方3.9版本最后提供二进制文件下载的是3.9.13版本，之后都是补丁形式。</li></ul><h1 id="参考文献">6 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]【Python 基础】Python 包管理：PyPI、setuptools 与 wheel[EB&#x2F;OL]. <a href="https://blog.csdn.net/qq_33578950/article/details/130297451">https://blog.csdn.net/qq_33578950/article/details/130297451</a>.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Python-语法摘记&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#Python-语法摘记&quot; class=&quot;headerlink&quot; title=&quot;Python 语法摘记&quot;&gt;&lt;/a&gt;Python</summary>
        
      
    
    
    
    <category term="code" scheme="https://mister-kin.github.io/categories/code/"/>
    
    
    <category term="总结" scheme="https://mister-kin.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="笔记" scheme="https://mister-kin.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程" scheme="https://mister-kin.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="python" scheme="https://mister-kin.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Blender练习总结：《CG Boost-Blender 2.8 Beginner Series》</title>
    <link href="https://mister-kin.github.io/software/blender/tranining/cg-boost-blender28-beginner-series/"/>
    <id>https://mister-kin.github.io/software/blender/tranining/cg-boost-blender28-beginner-series/</id>
    <published>2023-08-12T09:28:05.000Z</published>
    <updated>2023-08-12T09:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="练习成果展示">1 &nbsp&nbsp<a href="#练习成果展示" class="headerlink" title="练习成果展示"></a>练习成果展示</h1><h1 id="前期工作">2 &nbsp&nbsp<a href="#前期工作" class="headerlink" title="前期工作"></a>前期工作</h1><p>设计草图，善于利用参考资料（搜索引擎&gt;图片，现实中的实物&gt;拍照等）。三维创作需要时间，很难一蹴而就，慢慢迭代制作即可。</p><h1 id="建模">3 &nbsp&nbsp<a href="#建模" class="headerlink" title="建模"></a>建模</h1><p>开始建模之前，要注意建模物体的尺寸。注意观察物体外形，思考用哪些基础网格mesh创建模型会更容易点。</p><p>查看当前物体的尺寸：右边侧边栏（快捷键N）&gt;item条目&gt;尺寸</p><p>设置当前场景的单位：属性编辑器&gt;场景属性&gt;单位。</p><p><img data-src="/1.1.png"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;练习成果展示&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#练习成果展示&quot; class=&quot;headerlink&quot; title=&quot;练习成果展示&quot;&gt;&lt;/a&gt;练习成果展示&lt;/h1&gt;&lt;h1 id=&quot;前期工作&quot;&gt;2 &amp;nbsp&amp;nbsp&lt;a href=&quot;#前期工作&quot;</summary>
        
      
    
    
    
    <category term="software" scheme="https://mister-kin.github.io/categories/software/"/>
    
    <category term="blender" scheme="https://mister-kin.github.io/categories/software/blender/"/>
    
    <category term="tranining" scheme="https://mister-kin.github.io/categories/software/blender/tranining/"/>
    
    
    <category term="总结" scheme="https://mister-kin.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="blender" scheme="https://mister-kin.github.io/tags/blender/"/>
    
    <category term="教程" scheme="https://mister-kin.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="练习" scheme="https://mister-kin.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="苹果" scheme="https://mister-kin.github.io/tags/%E8%8B%B9%E6%9E%9C/"/>
    
    <category term="小刀" scheme="https://mister-kin.github.io/tags/%E5%B0%8F%E5%88%80/"/>
    
    <category term="布料" scheme="https://mister-kin.github.io/tags/%E5%B8%83%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 第五版：第五章「语句」习题答案</title>
    <link href="https://mister-kin.github.io/code-training/cpp-primer-v5/chap5/"/>
    <id>https://mister-kin.github.io/code-training/cpp-primer-v5/chap5/</id>
    <published>2023-08-07T15:24:10.000Z</published>
    <updated>2023-08-12T09:21:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章：语句"><a href="#第五章：语句" class="headerlink" title="第五章：语句"></a>第五章：语句</h1><h2 id="练习5-1"><a href="#练习5-1" class="headerlink" title="练习5.1"></a>练习5.1</h2><blockquote><p>什么是空语句？什么时候会用到空语句？</p></blockquote><p>只含有一个单独的分号的语句是空语句。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure><p>如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。（建议做好注释说明空语句作用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复读入数据直至到达文件末尾或某次输入的值等于sought</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><h2 id="练习5-2"><a href="#练习5-2" class="headerlink" title="练习5.2"></a>练习5.2</h2><blockquote><p>什么是块？什么时候会用到块？</p></blockquote><p>用花括号括起来的语句和声明的序列就是块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在程序的某个地方，逻辑上需要多条语句，而语法上只能容纳一条语句，此时应该使用块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (val &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">    ++val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习5-3"><a href="#练习5-3" class="headerlink" title="练习5.3"></a>练习5.3</h2><blockquote><p>使用逗号运算符重写（参见4.10节，第140页）1.4.1节的 while 循环，使它不再需要块，观察改写之后的代码可读性提高了还是降低了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (val &lt;= <span class="number">10</span>)</span><br><span class="line">    sum += val, ++val;</span><br></pre></td></tr></table></figure><p>代码的可读性降低了。</p><h2 id="练习5-4"><a href="#练习5-4" class="headerlink" title="练习5.4"></a>练习5.4</h2><blockquote><p>说明下列例子的含义，如果存在问题，试着修改它。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="keyword">while</span> (string::iterator iter != s.<span class="built_in">end</span>()) &#123; <span class="comment">/* . . . */</span> &#125;</span><br><span class="line">(b) <span class="keyword">while</span> (<span class="type">bool</span> status = <span class="built_in">find</span>(word)) &#123; <span class="comment">/* . . . */</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> (!status) &#123; <span class="comment">/* . . . */</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>(a) 这个循环试图用迭代器遍历string，但是变量的定义应该放在循环的外面，目前每次循环都会重新定义一个变量，明显是错误的。</li><li>(b) 这个循环的 while 和 if 是两个独立的语句，if 语句中无法访问 status 变量，正确的做法是应该将 if 语句包含在 while 里面，</li></ul><h2 id="练习5-5"><a href="#练习5-5" class="headerlink" title="练习5.5"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_5.cpp">练习5.5</a></h2><blockquote><p>写一段自己的程序，使用if else 语句实现把数字转换为字母成绩的要求。</p></blockquote><h2 id="练习5-6"><a href="#练习5-6" class="headerlink" title="练习5.6"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_6.cpp">练习5.6</a></h2><blockquote><p>改写上一题的程序，使用条件运算符（参见4.7节，第134页）代替if else语句。</p></blockquote><span id="more"></span><h2 id="练习5-7"><a href="#练习5-7" class="headerlink" title="练习5.7"></a>练习5.7</h2><blockquote><p>改写下列代码段中的错误。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="keyword">if</span> (ival1 != ival2)</span><br><span class="line">        ival1 = ival2</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ival1 = ival2 = <span class="number">0</span>;</span><br><span class="line">(b) <span class="keyword">if</span> (ival &lt; minval)</span><br><span class="line">        minval = ival;</span><br><span class="line">        occurs = <span class="number">1</span>;</span><br><span class="line">(c) <span class="keyword">if</span> (<span class="type">int</span> ival = <span class="built_in">get_value</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ival = &quot;</span> &lt;&lt; ival &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!ival)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ival = 0\n&quot;</span>;</span><br><span class="line">(d) <span class="keyword">if</span> (ival = <span class="number">0</span>)</span><br><span class="line">        ival = <span class="built_in">get_value</span>();</span><br></pre></td></tr></table></figure><ul><li>(a) <code>ival1 = ival2</code> 后面少了分号。</li><li>(b) 应该用花括号括起来。</li><li>(c) <code>if (!ival)</code> 应该改为 <code>else</code>。</li><li>(d) <code>if (ival = 0)</code> 应该改为 <code>if (ival == 0)</code>。</li></ul><h2 id="练习5-8"><a href="#练习5-8" class="headerlink" title="练习5.8"></a>练习5.8</h2><blockquote><p>什么是“悬垂else”？C++语言是如何处理else子句的？</p></blockquote><p>C++语言规定else与它最近的尚未匹配的if匹配。</p><h2 id="练习5-9"><a href="#练习5-9" class="headerlink" title="练习5.9"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_9.cpp">练习5.9</a></h2><blockquote><p>编写一段程序，使用一系列if语句统计从cin读入的文本中有多少元音字母。</p></blockquote><h2 id="练习5-10"><a href="#练习5-10" class="headerlink" title="练习5.10"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_10.cpp">练习5.10</a></h2><blockquote><p>我们之前实现的统计元音字母的程序存在一个问题：如果元音字母以大写形式出现，不会被统计在内。编写一段程序，既统计元音字母的小写形式，也统计大写形式，也就是说，新程序遇到&#39;a&#39;和&#39;A&#39;都应该递增 aCnt 的值，以此类推。</p></blockquote><h2 id="练习5-11"><a href="#练习5-11" class="headerlink" title="练习5.11"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_11.cpp">练习5.11</a></h2><blockquote><p>修改统计元音字母的程序，使其也能统计空格、制表符、和换行符的数量。</p></blockquote><h2 id="练习5-12"><a href="#练习5-12" class="headerlink" title="练习5.12"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_12.cpp">练习5.12</a></h2><blockquote><p>修改统计元音字母的程序，使其能统计以下含有两个字符的字符序列的数量：ff、fl和fi。</p></blockquote><h2 id="练习5-13"><a href="#练习5-13" class="headerlink" title="练习5.13"></a>练习5.13</h2><blockquote><p>下面显示的每个程序都含有一个常见的编程错误，指出错误在哪里，然后修改它们。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="type">unsigned</span> aCnt = <span class="number">0</span>, eCnt = <span class="number">0</span>, iouCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">next_text</span>();</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: aCnt++;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: eCnt++;</span><br><span class="line">        <span class="keyword">default</span>: iouCnt++;</span><br><span class="line">    &#125;</span><br><span class="line">(b) <span class="type">unsigned</span> index = <span class="built_in">some_value</span>();</span><br><span class="line">    <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="type">int</span> ix = <span class="built_in">get_value</span>();</span><br><span class="line">            ivec[ ix ] = index;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ix = ivec.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            ivec[ ix ] = index;</span><br><span class="line">    &#125;</span><br><span class="line">(c) <span class="type">unsigned</span> evenCnt = <span class="number">0</span>, oddCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> digit = <span class="built_in">get_num</span>() % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">switch</span> (digit) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">            oddcnt++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>:</span><br><span class="line">            evencnt++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">(d) <span class="type">unsigned</span> ival=<span class="number">512</span>, jval=<span class="number">1024</span>, kval=<span class="number">4096</span>;</span><br><span class="line">    <span class="type">unsigned</span> bufsize;</span><br><span class="line">    <span class="type">unsigned</span> swt = <span class="built_in">get_bufCnt</span>();</span><br><span class="line">    <span class="keyword">switch</span>(swt) &#123;</span><br><span class="line">        <span class="keyword">case</span> ival:</span><br><span class="line">            bufsize = ival * <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> jval:</span><br><span class="line">            bufsize = jval * <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kval:</span><br><span class="line">            bufsize = kval * <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>(a) 少了 break语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> aCnt = <span class="number">0</span>, eCnt = <span class="number">0</span>, iouCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">next_text</span>();</span><br><span class="line"><span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: aCnt++; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: eCnt++; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: iouCnt++; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch内部的控制流：如果某个case标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显式地中断了这一过程，比如添加break语句，否则直到switch的结尾处才会停下来。</p></li><li><p>(b) 在 default 分支当中，ix 未定义。应该在外部定义ix。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> index = <span class="built_in">some_value</span>();</span><br><span class="line"><span class="type">int</span> ix;</span><br><span class="line"><span class="keyword">switch</span> (index) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ix = <span class="built_in">get_value</span>();</span><br><span class="line">        ivec[ ix ] = index;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ix = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(ivec.<span class="built_in">size</span>())<span class="number">-1</span>;</span><br><span class="line">        ivec[ ix ] = index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>(c) case 后面应该用冒号而不是逗号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> evenCnt = <span class="number">0</span>, oddCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> digit = <span class="built_in">get_num</span>() % <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (digit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        oddcnt++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">case</span> <span class="number">8</span>: <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        evencnt++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>(d) case 标签必须是整型常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> ival=<span class="number">512</span>, jval=<span class="number">1024</span>, kval=<span class="number">4096</span>;</span><br><span class="line"><span class="type">unsigned</span> bufsize;</span><br><span class="line"><span class="type">unsigned</span> swt = <span class="built_in">get_bufCnt</span>();</span><br><span class="line"><span class="keyword">switch</span>(swt) &#123;</span><br><span class="line">    <span class="keyword">case</span> ival:</span><br><span class="line">        bufsize = ival * <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> jval:</span><br><span class="line">        bufsize = jval * <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kval:</span><br><span class="line">        bufsize = kval * <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="练习5-14"><a href="#练习5-14" class="headerlink" title="练习5.14"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_14.cpp">练习5.14</a></h2><blockquote><p>编写一段程序，从标准输入中读取若干string对象并查找连续重复出现的单词，所谓连续重复出现的意思是：一个单词后面紧跟着这个单词本身。要求记录连续重复出现的最大次数以及对应的单词。如果这样的单词存在，输出重复出现的最大次数；如果不存在，输出一条信息说明任何单词都没有连续出现过。例如：如果输入是：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">how now now now brown cow cow</span><br></pre></td></tr></table></figure><blockquote><p>那么输出应该表明单词now连续出现了3次。</p></blockquote><p>本题编程中使用了<code>std::pair</code>，<code>std::pair</code>是类模板，提供在一个单元存储两个相异类型对象的途径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T1</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&gt; <span class="keyword">struct</span> <span class="title class_">pair</span>;</span><br></pre></td></tr></table></figure><p>总共有两个成员对象：first和second。</p><p>示例：<code>std::pair&lt;std::string, float&gt;(&quot;aa&quot;, 1.1);</code></p><h2 id="练习5-15"><a href="#练习5-15" class="headerlink" title="练习5.15"></a>练习5.15</h2><blockquote><p>说明下列循环的含义并改正其中的错误。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="keyword">for</span> (<span class="type">int</span> ix = <span class="number">0</span>; ix != sz; ++ix) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> (ix != sz)</span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">(b) <span class="type">int</span> ix;</span><br><span class="line">    <span class="keyword">for</span> (ix != sz; ++ix) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">(c) <span class="keyword">for</span> (<span class="type">int</span> ix = <span class="number">0</span>; ix != sz; ++ix, ++sz) &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure><p>修正如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="type">int</span> ix;</span><br><span class="line">    <span class="keyword">for</span> (ix = <span class="number">0</span>; ix != sz; ++ix)  &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> (ix != sz)</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">(b) <span class="type">int</span> ix;</span><br><span class="line">    <span class="keyword">for</span> (; ix != sz; ++ix) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">(c) <span class="keyword">for</span> (<span class="type">int</span> ix = <span class="number">0</span>; ix != sz; ++ix) &#123; <span class="comment">/*...*/</span> &#125; <span class="comment">//如果首次判断ix不等于sz，执行++sz将导致死循环。</span></span><br></pre></td></tr></table></figure><h2 id="练习5-16"><a href="#练习5-16" class="headerlink" title="练习5.16"></a>练习5.16</h2><blockquote><p>while 循环特别适用于那种条件不变、反复执行操作的情况，例如，当未达到文件末尾时不断读取下一个值。for 循环则更像是在按步骤迭代，它的索引值在某个范围内依次变化。根据每种循环的习惯各自编写一段程序，然后分别用另一种循环改写。如果只能使用一种循环，你倾向于使用哪种呢？为什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while循环读取输入</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> ( cin &gt;&gt; i )</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环读取输入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; cin &gt;&gt; i;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != size; ++i)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// while循环遍历</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i != size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只能用一种循环，我会更倾向使用while循环，因为while的代码可读性更强。</p><h2 id="练习5-17"><a href="#练习5-17" class="headerlink" title="练习5.17"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_17.cpp">练习5.17</a></h2><blockquote><p>假设有两个包含整数的vector对象，编写一段程序，检验其中一个vector对象是否是另一个的前缀。为了实现这一目标，对于两个不等长的vector对象，只需挑出长度较短的那个，把它的所有元素和另一个vector对象比较即可。例如，如果两个vector对象的元素分别是0、1、1、2 和 0、1、1、2、3、5、8，则程序的返回结果为真。</p></blockquote><h2 id="练习5-18"><a href="#练习5-18" class="headerlink" title="练习5.18"></a>练习5.18</h2><blockquote><p>说明下列循环的含义并改正其中的错误。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="keyword">do</span></span><br><span class="line">        <span class="type">int</span> v1, v2;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please enter two numbers to sum:&quot;</span> ;</span><br><span class="line">        <span class="keyword">if</span> (cin &gt;&gt; v1 &gt;&gt; v2)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Sum is: &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (cin);</span><br><span class="line">(b) <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (ival = <span class="built_in">get_response</span>()); <span class="comment">// 应该将ival 定义在循环外</span></span><br><span class="line">(c) <span class="keyword">do</span> &#123;</span><br><span class="line">        ival = <span class="built_in">get_response</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (ival); <span class="comment">// 应该将ival 定义在循环外</span></span><br></pre></td></tr></table></figure><p>修正如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="keyword">do</span> &#123; <span class="comment">// 应该添加花括号</span></span><br><span class="line">        <span class="type">int</span> v1, v2;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please enter two numbers to sum:&quot;</span> ;</span><br><span class="line">        <span class="keyword">if</span> (cin &gt;&gt; v1 &gt;&gt; v2)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Sum is: &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">while</span> (cin);</span><br><span class="line">(b) <span class="type">int</span> ival;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (ival = <span class="built_in">get_response</span>()); <span class="comment">// 应该将ival 定义在循环外</span></span><br><span class="line">(c) <span class="type">int</span> ival;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ival = <span class="built_in">get_response</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (ival); <span class="comment">// 应该将ival 定义在循环外</span></span><br></pre></td></tr></table></figure><h2 id="练习5-19"><a href="#练习5-19" class="headerlink" title="练习5.19"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_19.cpp">练习5.19</a></h2><blockquote><p>编写一段程序，使用do while 循环重复地执行下述任务：首先提示用户输入两个string对象，然后挑出较短的那个并输出它。</p></blockquote><h2 id="练习5-20"><a href="#练习5-20" class="headerlink" title="练习5.20"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_20.cpp">练习5.20</a></h2><blockquote><p>编写一段程序，从标准输入中读取string对象的序列直到连续出现两个相同的单词或者所有的单词都读完为止。使用while循环一次读取一个单词，当一个单词连续出现两次时使用break语句终止循环。输出连续重复出现的单词，或者输出一个消息说明没有任何单词是连续重复出现的。</p></blockquote><h2 id="练习5-21"><a href="#练习5-21" class="headerlink" title="练习5.21"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_21.cpp">练习5.21</a></h2><blockquote><p>修改5.5.1节（第171页）练习题的程序，使其找到的重复单词必须以大写字母开头。</p></blockquote><h2 id="练习5-22"><a href="#练习5-22" class="headerlink" title="练习5.22"></a>练习5.22</h2><blockquote><p>本节的最后一个例子跳回到 begin，其实使用循环能更好的完成该任务，重写这段代码，注意不再使用goto语句。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向后跳过一个带初始化的变量定义是合法的</span></span><br><span class="line">begin:</span><br><span class="line">    <span class="type">int</span> sz = <span class="built_in">get_size</span>();</span><br><span class="line">    <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> begin;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用 <code>for</code> 循环修改效果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> sz = <span class="built_in">get_size</span>(); sz &lt;=<span class="number">0</span>; sz = <span class="built_in">get_size</span>())</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><h2 id="练习5-23"><a href="#练习5-23" class="headerlink" title="练习5.23"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_23.cpp">练习5.23</a></h2><blockquote><p>编写一段程序，从标准输入读取两个整数，输出第一个数除以第二个数的结果。</p></blockquote><h2 id="练习5-24"><a href="#练习5-24" class="headerlink" title="练习5.24"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_24.cpp">练习5.24</a></h2><blockquote><p>修改你的程序，使得当第二个数是0时抛出异常。先不要设定catch子句，运行程序并真的为除数输入0，看看会发生什么？</p></blockquote><h2 id="练习5-25"><a href="#练习5-25" class="headerlink" title="练习5.25"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_25.cpp">练习5.25</a></h2><blockquote><p>修改上一题的程序，使用try语句块去捕获异常。catch子句应该为用户输出一条提示信息，询问其是否输入新数并重新执行try语句块的内容。</p></blockquote><p>异常处理（try-throw-catch）：</p><ul><li>将错误处理代码和正常代码分离开：传统的错误处理代码中都会使用一系列的 if-else 条件判断来处理错误。这些条件判断代码和错误处理代码会混在正常的程序流中，降低代码的可读性和可维护性。使用 try&#x2F;catch 块则能够将错误处理与正常流程分开。</li><li>个人理解：更像是一个高级goto语法。</li></ul><p>大致的使用形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 被保护的代码</span></span><br><span class="line">    <span class="keyword">throw</span>  <span class="comment">// 抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第五章：语句&quot;&gt;&lt;a href=&quot;#第五章：语句&quot; class=&quot;headerlink&quot; title=&quot;第五章：语句&quot;&gt;&lt;/a&gt;第五章：语句&lt;/h1&gt;&lt;h2 id=&quot;练习5-1&quot;&gt;&lt;a href=&quot;#练习5-1&quot; class=&quot;headerlink&quot; title=&quot;练习5.1&quot;&gt;&lt;/a&gt;练习5.1&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;什么是空语句？什么时候会用到空语句？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只含有一个单独的分号的语句是空语句。如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。（建议做好注释说明空语句作用）&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//重复读入数据直至到达文件末尾或某次输入的值等于sought&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (cin &amp;gt;&amp;gt; s &amp;amp;&amp;amp; s != sought)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;练习5-2&quot;&gt;&lt;a href=&quot;#练习5-2&quot; class=&quot;headerlink&quot; title=&quot;练习5.2&quot;&gt;&lt;/a&gt;练习5.2&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;什么是块？什么时候会用到块？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用花括号括起来的语句和声明的序列就是块。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果在程序的某个地方，逻辑上需要多条语句，而语法上只能容纳一条语句，此时应该使用块。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (val &amp;lt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sum += val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ++val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;练习5-3&quot;&gt;&lt;a href=&quot;#练习5-3&quot; class=&quot;headerlink&quot; title=&quot;练习5.3&quot;&gt;&lt;/a&gt;练习5.3&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用逗号运算符重写（参见4.10节，第140页）1.4.1节的 while 循环，使它不再需要块，观察改写之后的代码可读性提高了还是降低了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (val &amp;lt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sum += val, ++val;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码的可读性降低了。&lt;/p&gt;
&lt;h2 id=&quot;练习5-4&quot;&gt;&lt;a href=&quot;#练习5-4&quot; class=&quot;headerlink&quot; title=&quot;练习5.4&quot;&gt;&lt;/a&gt;练习5.4&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;说明下列例子的含义，如果存在问题，试着修改它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(a) &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (string::iterator iter != s.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;()) &amp;#123; &lt;span class=&quot;comment&quot;&gt;/* . . . */&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(b) &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;bool&lt;/span&gt; status = &lt;span class=&quot;built_in&quot;&gt;find&lt;/span&gt;(word)) &amp;#123; &lt;span class=&quot;comment&quot;&gt;/* . . . */&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!status) &amp;#123; &lt;span class=&quot;comment&quot;&gt;/* . . . */&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;(a) 这个循环试图用迭代器遍历string，但是变量的定义应该放在循环的外面，目前每次循环都会重新定义一个变量，明显是错误的。&lt;/li&gt;
&lt;li&gt;(b) 这个循环的 while 和 if 是两个独立的语句，if 语句中无法访问 status 变量，正确的做法是应该将 if 语句包含在 while 里面，&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;练习5-5&quot;&gt;&lt;a href=&quot;#练习5-5&quot; class=&quot;headerlink&quot; title=&quot;练习5.5&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_5.cpp&quot;&gt;练习5.5&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;写一段自己的程序，使用if else 语句实现把数字转换为字母成绩的要求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;练习5-6&quot;&gt;&lt;a href=&quot;#练习5-6&quot; class=&quot;headerlink&quot; title=&quot;练习5.6&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap5/5_6.cpp&quot;&gt;练习5.6&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;改写上一题的程序，使用条件运算符（参见4.7节，第134页）代替if else语句。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="code-training" scheme="https://mister-kin.github.io/categories/code-training/"/>
    
    <category term="cpp-primer-v5" scheme="https://mister-kin.github.io/categories/code-training/cpp-primer-v5/"/>
    
    
    <category term="C++" scheme="https://mister-kin.github.io/tags/C/"/>
    
    <category term="C++ Primer" scheme="https://mister-kin.github.io/tags/C-Primer/"/>
    
    <category term="习题答案" scheme="https://mister-kin.github.io/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
    <category term="练习总结" scheme="https://mister-kin.github.io/tags/%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="第五章" scheme="https://mister-kin.github.io/tags/%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    
    <category term="语句" scheme="https://mister-kin.github.io/tags/%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 第五版：第四章「表达式」习题答案</title>
    <link href="https://mister-kin.github.io/code-training/cpp-primer-v5/chap4/"/>
    <id>https://mister-kin.github.io/code-training/cpp-primer-v5/chap4/</id>
    <published>2023-08-04T17:23:08.000Z</published>
    <updated>2023-08-12T09:21:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章：表达式"><a href="#第四章：表达式" class="headerlink" title="第四章：表达式"></a>第四章：表达式</h1><h2 id="练习4-1"><a href="#练习4-1" class="headerlink" title="练习4.1"></a>练习4.1</h2><blockquote><p>表达式 5 + 10 * 20 &#x2F; 2 的求值结果是多少？</p></blockquote><p>105</p><h2 id="练习4-2"><a href="#练习4-2" class="headerlink" title="练习4.2"></a>练习4.2</h2><blockquote><p>根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。</p></blockquote><ul><li>(a) *vec.begin()</li><li>(b) *vec.begin() + 1</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(vec.begin())</span><br><span class="line">(*(vec.begin())) + 1</span><br></pre></td></tr></table></figure><h2 id="练习4-3"><a href="#练习4-3" class="headerlink" title="练习4.3"></a>练习4.3</h2><blockquote><p>C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。</p></blockquote><p>可以接受。C++的设计思想是尽可能地“相信”程序员，将效率最大化。然而这种思想却有着潜在的危害，就是无法控制程序员自身引发的错误。因此 Java 的诞生也是必然，Java的思想就是尽可能地“不相信”程序员。</p><h2 id="练习4-4"><a href="#练习4-4" class="headerlink" title="练习4.4"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap4/4_4.cpp">练习4.4</a></h2><blockquote><p>在下面的表达式中添加括号，说明其求值过程及最终结果。编写程序编译该（不加括号的）表达式并输出结果验证之前的推断。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> / <span class="number">3</span> * <span class="number">4</span> + <span class="number">5</span> * <span class="number">15</span> + <span class="number">24</span> % <span class="number">4</span> / <span class="number">2</span></span><br></pre></td></tr></table></figure><p>((12&#x2F;3)*4) + (5*15) + ((24%4)&#x2F;2)</p><p>实际输出结果：91。</p><h2 id="练习4-5"><a href="#练习4-5" class="headerlink" title="练习4.5"></a>练习4.5</h2><blockquote><p>写出下列表达式的求值结果。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-30</span> * <span class="number">3</span> + <span class="number">21</span> / <span class="number">5</span>  <span class="comment">// -90+4 = -86</span></span><br><span class="line"><span class="number">-30</span> + <span class="number">3</span> * <span class="number">21</span> / <span class="number">5</span>  <span class="comment">// -30+63/5 = -30+12 = -18</span></span><br><span class="line"><span class="number">30</span> / <span class="number">3</span> * <span class="number">21</span> % <span class="number">5</span>   <span class="comment">// 10*21%5 = 210%5 = 0</span></span><br><span class="line"><span class="number">-30</span> / <span class="number">3</span> * <span class="number">21</span> % <span class="number">4</span>  <span class="comment">// -10*21%4 = -210%4 = -2</span></span><br></pre></td></tr></table></figure><h2 id="练习4-6"><a href="#练习4-6" class="headerlink" title="练习4.6"></a>练习4.6</h2><blockquote><p>写出一条表达式用于确定一个整数是奇数还是偶数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure><h2 id="练习4-7"><a href="#练习4-7" class="headerlink" title="练习4.7"></a>练习4.7</h2><blockquote><p>溢出是何含义？写出三条将导致溢出的表达式。</p></blockquote><p>溢出含义：当计算的结果超出该类型所能表示的范围时就会产生溢出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> svalue = <span class="number">32767</span>; ++svalue; <span class="comment">// -32768</span></span><br><span class="line"><span class="type">unsigned</span> uivalue = <span class="number">0</span>; --uivalue;  <span class="comment">// 4294967295</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> usvalue = <span class="number">65535</span>; ++usvalue;  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="练习4-8"><a href="#练习4-8" class="headerlink" title="练习4.8"></a>练习4.8</h2><blockquote><p>说明在逻辑与、逻辑或及相等性运算符中运算对象的求值顺序。</p></blockquote><ul><li>逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为<strong>短路求值</strong>。</li><li>相等性运算符未定义求值顺序。</li></ul><span id="more"></span><h2 id="练习4-9"><a href="#练习4-9" class="headerlink" title="练习4.9"></a>练习4.9</h2><blockquote><p>解释在下面的if语句中条件部分的判断过程。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *cp = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (cp &amp;&amp; *cp)</span><br></pre></td></tr></table></figure><p>首先判断 <code>cp</code> ，<code>cp</code> 不是一个空指针，因此 <code>cp</code> 为真。然后判断 <code>*cp</code>，<code>*cp</code> 的值是字符 &#39;H&#39;，非0。因此最后的结果为真。</p><h2 id="练习4-10"><a href="#练习4-10" class="headerlink" title="练习4.10"></a>练习4.10</h2><blockquote><p>为while 循环写一个条件，使其从标准输入中读取整数，遇到 42 时停止。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i &amp;&amp; i != <span class="number">42</span>)</span><br></pre></td></tr></table></figure><h2 id="练习4-11"><a href="#练习4-11" class="headerlink" title="练习4.11"></a>练习4.11</h2><blockquote><p>书写一条表达式用于测试4个值a、b、c、d的关系，确保a大于b、b大于c、c大于d。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&gt;b &amp;&amp; b&gt;c &amp;&amp; c&gt;d</span><br></pre></td></tr></table></figure><h2 id="练习4-12"><a href="#练习4-12" class="headerlink" title="练习4.12"></a>练习4.12</h2><blockquote><p>假设i、j 和k 是三个整数，说明表达式 i !&#x3D; j &lt; k 的含义。</p></blockquote><p>这个表达式等于 <code>i != (j &lt; k)</code>。首先得到 j &lt; k 的结果为 true 或 false，转换为整数值是 1 和 0，然后判断 i 不等于 1 和 0 ，最终的结果为 bool 值。</p><h2 id="练习4-13"><a href="#练习4-13" class="headerlink" title="练习4.13"></a>练习4.13</h2><blockquote><p>在下述语句中，当赋值完成后 i 和 d 的值分别是多少？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;   <span class="type">double</span> d;</span><br><span class="line">d = i = <span class="number">3.5</span>; <span class="comment">// i = 3, d = 3.0</span></span><br><span class="line">i = d = <span class="number">3.5</span>; <span class="comment">// d = 3.5, i = 3</span></span><br></pre></td></tr></table></figure><ul><li>赋值运算符的左侧运算对象必须是一个可修改的左值，赋值运算的结果是左侧运算对象。</li><li>若左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。</li><li>赋值运算符满足右结合律，因此可多重赋值，例如<code>s1=s2=&quot;Hello&quot;</code>。</li><li>赋值运算符优先级一般较低。</li><li>复合赋值运算符等价于：<code>a=a op b</code>，例如<code>a+=1等价于a=a+1</code>。</li></ul><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>左值和右值的概念是从C语言继承过来的。</p><p>在C语言中，左值可以位于赋值语句的左侧，右值则不能。</p><p>在C++语言中，区别则复杂一些。当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</p><h2 id="练习4-14"><a href="#练习4-14" class="headerlink" title="练习4.14"></a>练习4.14</h2><blockquote><p>执行下述 if 语句后将发生什么情况？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">42</span> = i)   <span class="comment">// 编译错误。赋值运算符左侧必须是一个可修改的左值。而字面值是右值。</span></span><br><span class="line"><span class="keyword">if</span> (i = <span class="number">42</span>)   <span class="comment">// true.</span></span><br></pre></td></tr></table></figure><h2 id="练习4-15"><a href="#练习4-15" class="headerlink" title="练习4.15"></a>练习4.15</h2><blockquote><p>下面的赋值是非法的，为什么？应该如何修改？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval; <span class="type">int</span> ival; <span class="type">int</span> *pi;</span><br><span class="line">dval = ival = pi = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>pi 是指针，不能赋值给 int 类型，应该改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dval = ival = <span class="number">0</span>;</span><br><span class="line">pi = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="练习4-16"><a href="#练习4-16" class="headerlink" title="练习4.16"></a>练习4.16</h2><blockquote><p>尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p = <span class="built_in">getPtr</span>() != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (i = <span class="number">1024</span>)</span><br></pre></td></tr></table></figure><ul><li><code>p=getPtr() != 0</code>中赋值运算符优先级低于不相等运算符，因此这个条件判断首先执行<code>getPtr() != 0</code>，返回一个bool值，之后将bool值赋值给变量p，因此条件判断可能为true或者false。</li><li><code>i = 1024</code>条件判断总是为 true</li></ul><p>代码修改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p=<span class="built_in">getPtr</span>()) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1024</span>)</span><br></pre></td></tr></table></figure><h2 id="练习4-17"><a href="#练习4-17" class="headerlink" title="练习4.17"></a>练习4.17</h2><blockquote><p>说明前置递增运算符和后置递增运算符的区别。</p></blockquote><p>这两种运算符必须作用于左值运算对象。前置递增运算符将对象本身作为左值返回，而后置递增运算符将对象原始值的副本作为右值返回。</p><p>P.S.如无必要，例如不需要修改前的值，那么不要使用递增递减运算符的后置版本。</p><h2 id="练习4-18"><a href="#练习4-18" class="headerlink" title="练习4.18"></a>练习4.18</h2><blockquote><p>如果132页那个输出vector对象元素的while循环使用前置递增运算符，将得到什么结果？</p></blockquote><p>将会从第二个元素开始取值，并且如果序列中没有负值时，最后对 v.end() 进行取值，结果是未定义的，因为end成员返回的迭代器是尾后迭代器，指向一个本不存在的尾后元素（尾后迭代器是标记作用，无实际含义）。</p><h2 id="练习4-19"><a href="#练习4-19" class="headerlink" title="练习4.19"></a>练习4.19</h2><blockquote><p>假设 ptr 的类型是指向 int 的指针、vec 的类型是vector<int>、ival 的类型是int，说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a) ptr != <span class="number">0</span> &amp;&amp; *ptr++</span><br><span class="line">(b) ival++ &amp;&amp; <span class="built_in">ival</span></span><br><span class="line">(c) vec[ival++] &lt;= vec[ival]</span><br></pre></td></tr></table></figure><ul><li>(a) 判断ptr不是一个空指针，并且ptr当前指向的元素的值也为真，然后将ptr指向下一个元素</li><li>(b) 判断(ival + 1)的值为真，并且ival的值也为真</li><li>(c) 表达式有误。C++标准中并没有规定 <code>&lt;=</code> 运算符两边的求值顺序，因此编译器既有可能先求左侧的值，也有可能先求右侧的值，而这两种方式导致的结果也不同，这种是未定义行为undefined behavior（详见P133）。应该改为 <code>vec[ival] &lt;= vec[ival+1]</code>。</li></ul><h2 id="练习4-20"><a href="#练习4-20" class="headerlink" title="练习4.20"></a>练习4.20</h2><blockquote><p>假设 iter 的类型是 vector&lt;string&gt;::iterator, 说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(a) *iter++;</span><br><span class="line">(b) (*iter)++;</span><br><span class="line">(c) *iter.<span class="built_in">empty</span>();</span><br><span class="line">(d) iter-&gt;<span class="built_in">empty</span>();</span><br><span class="line">(e) ++*iter;</span><br><span class="line">(f) iter++-&gt;<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure><ul><li>(a)合法。返回迭代器所指向的元素，然后迭代器递增。</li><li>(b)不合法。因为vector元素类型是 string，没有 ++ 操作。</li><li>(c)不合法。解引用运算符的优先级低于点运算，iter是一个迭代器，没有名为empty的成员，这里应该加括号。</li><li>(d)合法。判断迭代器当前的元素是否为空。</li><li>(e)不合法。string 类型没有 ++ 操作。</li><li>(f)合法。判断迭代器当前元素是否为空，然后迭代器递增。</li></ul><h3 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h3><p>点运算符和箭头运算符都可用于访问成员，获取类对象的一个成员的的运算符形式如下（设定cls是一个类对象，ptr是指向cls的指针或者迭代器，访问其中men成员）：</p><ul><li>点运算符：<code>cls.men</code>或者<code>(*ptr).men</code>，点运算符作用于对象类型</li><li>箭头运算符：<code>ptr-&gt;men</code>，箭头运算符作用于指针类型</li></ul><h2 id="练习4-21"><a href="#练习4-21" class="headerlink" title="练习4.21"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap4/4_21.cpp">练习4.21</a></h2><blockquote><p>编写一段程序，使用条件运算符从 vector<int> 中找到哪些元素的值是奇数，然后将这些奇数值翻倍。</p></blockquote><p>条件运算符（?:）允许我们把简单的 if-else 逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond ? exprl : expr2</span><br></pre></td></tr></table></figure><p>其中 cond 是判断条件的表达式，而 expr1 和 expr2 是两个类型相同或可能转换为某个公共类型的表达式。条件运算符的执行过程是：首先求 cond 的值，如果条件为真对expr1求值并返回该值，否则对expr2求值并返回该值。</p><ul><li>当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值：否则运算的结果是右值。</li><li>条件运算符允许嵌套，为了保证代码的可读性，嵌套不要超过两三层。</li><li>条件运算符满足右结合律，即运算对象一般按照从右向左的顺序组合。</li></ul><h2 id="练习4-22"><a href="#练习4-22" class="headerlink" title="练习4.22"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap4/4_22.cpp">练习4.22</a></h2><blockquote><p>本节的示例程序将成绩划分为high pass、pass 和 fial 三种，扩展该程序使其进一步将 60 分到 75 分之间的成绩设定为 low pass。要求程序包含两个版本：一个版本只使用条件运算符；另一个版本使用1个或多个if语句。哪个版本的程序更容易理解呢？为什么？</p></blockquote><p>if-else版本更容易理解。当条件运算符嵌套层数变多之后，代码的可读性急剧下降。而if-else的逻辑很清晰。</p><h2 id="练习4-23"><a href="#练习4-23" class="headerlink" title="练习4.23"></a>练习4.23</h2><blockquote><p>因为运算符的优先级问题，下面这条表达式无法通过编译。根据4.12节中的表（第147页）指出它的问题在哪里？应该如何修改？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;word&quot;</span>;</span><br><span class="line">string pl = s + s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">&#x27;s&#x27;</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;s&quot;</span> ;</span><br></pre></td></tr></table></figure><p>加法运算符的优先级高于条件运算符。因此要改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string pl = s + (s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">&#x27;s&#x27;</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;s&quot;</span>) ;</span><br></pre></td></tr></table></figure><h2 id="练习4-24"><a href="#练习4-24" class="headerlink" title="练习4.24"></a>练习4.24</h2><blockquote><p>本节的示例程序将成绩划分为 high pass、pass、和fail三种，它的依据是条件运算符满足右结合律。假如条件运算符满足的是左结合律，求值的过程将是怎样的？</p></blockquote><p>如果条件运算符满足的是左结合律。那么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finalgrade = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span> : (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finalgrade = ((grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span> : (grade &lt; <span class="number">60</span>)) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br></pre></td></tr></table></figure><p>假如此时 grade &gt; 90 ，第一个条件表达式的结果是 &quot;high pass&quot; ，而字符串字面值的类型是 const char *，非空所以为真。因此第二个条件表达式的结果是 &quot;fail&quot;。这样就出现了自相矛盾的逻辑。</p><h2 id="练习4-25"><a href="#练习4-25" class="headerlink" title="练习4.25"></a>练习4.25</h2><blockquote><p>如果一台机器上 int 占 32 位、char 占8位，用的是 Latin-1 字符集，其中字符&#39;q&#39; 的二进制形式是 01110001，那么表达式&#39;q&#39; &lt;&lt; 6的值是什么？</p></blockquote><p>首先将char类型提升为int 类型，等同于 00000000 00000000 00000000 01110001 &lt;&lt; 6，结果是 00000000 00000000 00011100 01000000，转换十进制为7232。</p><h3 id="位运算符的总结"><a href="#位运算符的总结" class="headerlink" title="位运算符的总结"></a>位运算符的总结</h3><ul><li>位运算符操作可能会改变符号为的值，关于符号位如何处理没有明确的规定，具体依赖于机器，因此强烈建议仅将位运算符用于处理无符号类型。</li><li>移位运算符满足左结合律，移位运算符又名IO运算符（重载版本，用以IO操作）</li></ul><h2 id="练习4-26"><a href="#练习4-26" class="headerlink" title="练习4.26"></a>练习4.26</h2><blockquote><p>在本节关于测验成绩的例子中，如果使用unsigned int 作为quiz1 的类型会发生什么情况？</p></blockquote><p>C++标准中并未以字节的单位指定int的大小，但指定了它们必须能够容纳的最小范围。<code>unsigned int</code>的最小取值范围是0到65535。但在有的机器上，unsigned int类型可能只有16位，而这结果是未定义行为。</p><h2 id="练习4-27"><a href="#练习4-27" class="headerlink" title="练习4.27"></a>练习4.27</h2><blockquote><p>下列表达式的结果是什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ul1 = <span class="number">3</span>, ul2 = <span class="number">7</span>;</span><br><span class="line">(a) <span class="function">ul1 &amp; <span class="title">ul2</span></span></span><br><span class="line"><span class="function"><span class="params">(b)</span> ul1 | <span class="title">ul2</span></span></span><br><span class="line"><span class="function"><span class="params">(c)</span> ul1 &amp;&amp; <span class="title">ul2</span></span></span><br><span class="line"><span class="function"><span class="params">(d)</span> ul1 || ul2</span></span><br></pre></td></tr></table></figure><ul><li>(a) 3</li><li>(b) 7</li><li>(c) true</li><li>(d) true</li></ul><h2 id="练习4-28"><a href="#练习4-28" class="headerlink" title="练习4.28"></a><a href="https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap4/4_28.cpp">练习4.28</a></h2><blockquote><p>编写一段程序，输出每一种内置类型所占空间的大小。</p></blockquote><h2 id="练习4-29"><a href="#练习4-29" class="headerlink" title="练习4.29"></a>练习4.29</h2><blockquote><p>推断下面代码的输出结果并说明理由。实际运行这段程序，结果和你想象的一样吗？如不一样，为什么？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[<span class="number">10</span>];   <span class="type">int</span> *p = x;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(x)/<span class="built_in">sizeof</span>(*x) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p)/<span class="built_in">sizeof</span>(*p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>第一个输出结果是 10。第二个结果是未定义。</p><p>参考：<a href="http://stackoverflow.com/a/2428809">Why the size of a pointer is 4bytes in C++</a></p><p>sizeof运算符的总结：</p><ul><li>对char或者类型为char的表达式执行sizeof运算，结果得1。</li><li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。</li><li>对指针执行sizeof运算得到指针本身所占空间的大小。</li><li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。</li><li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和（因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数：<code>sizeof(ia)/sizeof(*ia)</code>返回ia的元素数量）。注意，sizeof运算不会把数组转换成指针来处理。</li><li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li></ul><h2 id="练习4-30"><a href="#练习4-30" class="headerlink" title="练习4.30"></a>练习4.30</h2><blockquote><p>根据4.12节中的表，在下述表达式的适当位置加上括号，使得加上括号之后的表达式的含义与原来的含义相同。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="keyword">sizeof</span> x + <span class="built_in">y</span></span><br><span class="line">(b) <span class="keyword">sizeof</span> p-&gt;mem[i]</span><br><span class="line">(c) <span class="keyword">sizeof</span> a &lt; <span class="built_in">b</span></span><br><span class="line">(d) <span class="function"><span class="keyword">sizeof</span> <span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>(a) (sizeof x) + y</li><li>(b) sizeof(p-&gt;mem[i])</li><li>(c) sizeof(a) &lt; b</li><li>(d) sizeof(f())</li></ul><h2 id="练习4-31"><a href="#练习4-31" class="headerlink" title="练习4.31"></a>练习4.31</h2><blockquote><p>本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节的程序。</p></blockquote><p>在<a href="#%E7%BB%83%E4%B9%A04-17">练习4.17</a>（4.5节，132页）已经说过了，<strong>除非必须，否则不用递增递减运算符的后置版本</strong>。在这里要使用后置版本的递增递减运算符不影响程序结果，不需要任何改动。</p><h2 id="练习4-32"><a href="#练习4-32" class="headerlink" title="练习4.32"></a>练习4.32</h2><blockquote><p>解释下面这个循环的含义。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> ia[size] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> *ptr = ia, ix = <span class="number">0</span>;</span><br><span class="line">    ix != size &amp;&amp; ptr != ia+size;</span><br><span class="line">    ++ix, ++ptr) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>这个循环在遍历数组 ia，指针 ptr 和 整型 ix 都是起到一个计数的功能，任意选择其中一个都可以完成遍历。</p><h2 id="练习4-33"><a href="#练习4-33" class="headerlink" title="练习4.33"></a>练习4.33</h2><blockquote><p>根据4.12节中的表说明下面这条表达式的含义。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someValue ? ++x, ++y : --x, --y</span><br></pre></td></tr></table></figure><p>逗号表达式的优先级是最低的。因此这条表达式也等于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(someValue ? ++x, ++y : --x), --y</span><br></pre></td></tr></table></figure><p>如果someValue的值为真，x和y的值都自增并返回y值，然后丢弃y值，y递减并返回y值。如果someValue的值为假，x递减并返回x值，然后丢弃x值，y递减并返回y值。</p><h2 id="练习4-34"><a href="#练习4-34" class="headerlink" title="练习4.34"></a>练习4.34</h2><blockquote><p>根据本节给出的变量定义，说明在下面的表达式中奖发生什么样的类型转换：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="keyword">if</span> (fval)</span><br><span class="line">(b) dval = fval + ival;</span><br><span class="line">(c) dval + ival * cval;</span><br></pre></td></tr></table></figure><p>需要注意每种运算符遵循的是左结合律还是右结合律。</p><ul><li>(a) fval 转换为 bool 类型</li><li>(b) ival 转换为 float ，相加的结果转换为 double</li><li>(c) cval 转换为 int，然后相乘的结果转换为 double</li></ul><h2 id="练习4-35"><a href="#练习4-35" class="headerlink" title="练习4.35"></a>练习4.35</h2><blockquote><p>假设有如下的定义：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> cval;</span><br><span class="line"><span class="type">int</span> ival;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line"><span class="type">float</span> fval;</span><br><span class="line"><span class="type">double</span> dval;</span><br></pre></td></tr></table></figure><p>请回答在下面的表达式中发生了隐式类型转换吗？如果有，指出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a) cval = <span class="string">&#x27;a&#x27;</span> + <span class="number">3</span>;</span><br><span class="line">(b) fval = ui - ival * <span class="number">1.0</span>;</span><br><span class="line">(c) dval = ui * fval;</span><br><span class="line">(d) cval = ival + fval + dval;</span><br></pre></td></tr></table></figure><ul><li>(a) &#39;a&#39; 转换为 int ，然后与 3 相加的结果转换为 char</li><li>(b) ival 转换为 double，ui 转换为 double，结果转换为 float</li><li>(c) ui 转换为 float，结果转换为 double</li><li>(d) ival 转换为 float，与fval相加后的结果转换为 double，最后的结果转换为char</li></ul><p>隐式转换：</p><ul><li>算术转换<ul><li>在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。</li><li>在条件中，非布尔值转换成布尔类型。</li><li>初始化过程中，初始值转换成变量的类型：在赋值语句中，右侧运算对象转换成左侧运算对象的类型。</li><li>如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。</li><li>如第 6 章将要介绍的，函数调用时也会发生类型转换。</li></ul></li><li>其他隐式类型转换（详见P143-P144）<ul><li>数组转换成指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。</li><li>指针的转换</li><li>转换成布尔类型</li><li>转换成常量</li><li>类类型定义的转换</li></ul></li></ul><h2 id="练习4-36"><a href="#练习4-36" class="headerlink" title="练习4.36"></a>练习4.36</h2><blockquote><p>假设 i 是int类型，d 是double类型，书写表达式 i*&#x3D;d 使其执行整数类型的乘法而非浮点类型的乘法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i *= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d);</span><br></pre></td></tr></table></figure><h2 id="练习4-37"><a href="#练习4-37" class="headerlink" title="练习4.37"></a>练习4.37</h2><blockquote><p>用命名的强制类型转换改写下列旧式的转换语句。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i; <span class="type">double</span> d; <span class="type">const</span> string *ps; <span class="type">char</span> *pc; <span class="type">void</span> *pv;</span><br><span class="line">(a) pv = (<span class="type">void</span>*)ps;</span><br><span class="line">(b) i = <span class="built_in">int</span>(*pc);</span><br><span class="line">(c) pv = &amp;d;</span><br><span class="line">(d) pc = (<span class="type">char</span>*)pv;</span><br></pre></td></tr></table></figure><ul><li>(a) pv &#x3D; static_cast&lt;void*&gt;(const_cast&lt;string*&gt;(ps));</li><li>(b) i &#x3D; static_cast<int>(*pc);</li><li>(c) pv &#x3D; static_cast&lt;void*&gt;(&amp;d);</li><li>(d) pc &#x3D; static_cast&lt;char*&gt;(pv);</li></ul><h2 id="练习4-38"><a href="#练习4-38" class="headerlink" title="练习4.38"></a>练习4.38</h2><blockquote><p>说明下面这条表达式的含义。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j/i);</span><br></pre></td></tr></table></figure><p>将 <code>j/i</code> 的结果值转换为 double，然后赋值给slope。</p><p>显式转换（如无必要，尽可能避免强制类型转换，因为会干扰正常的类型检查）</p><ul><li>命名的强制类型转换：<code>cast-name&lt;type&gt;(expression);</code>其中，type是转换的目标类型，而expression是要转换的值。如果type是引用类型，则结果是左值。 cast-name有以下四种类型<ul><li>static_cast<ul><li>任何具有明确定义的类型转换，只要不包含底层const ，都可以使用 static_cast。例如，通过将一个运算对象强制转换成 double 类型就能使表达式执行浮点数除法：<code>double slope=static_cast&lt;double&gt;(j)/i</code>。</li><li>当需要把一个较大的算术类型赋值给较小的类型时， static_cast非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。一般来说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息；但是当我们执行了显式的类型转换后，警告信息就会被关闭了。</li><li>static_cast对于编译器无法自动执行的类型转换也非常有用。</li></ul></li><li>dynamic_cast：支持运行时类型识别。</li><li>const_cast：只能改变运算对象的底层const（详见P145）。const_cast常常用于有函数重载的上下文中。</li><li>reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释。使用这个类型是非常危险的。reinterpret_cast本质上依赖于机器。要想安全地使用reinterpret_cast，必须对涉及的类型和编译器实现转换的过程都非常了解。</li></ul></li><li>旧式的强制类型转换<ul><li><code>type(expr);</code>：函数形式</li><li><code>(type)expr;</code>：C语言风格</li></ul></li></ul><h3 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a><strong>运算符优先级表</strong></h3><table><thead><tr><th align="left">运算符</th><th align="left">功能</th><th align="left">用法</th><th align="left">结合律</th><th align="left">参考页码</th></tr></thead><tbody><tr><td align="left">::</td><td align="left">全局作用域</td><td align="left">::name</td><td align="left">左</td><td align="left">P256</td></tr><tr><td align="left">::</td><td align="left">类作用域</td><td align="left">class::name</td><td align="left">左</td><td align="left">P79</td></tr><tr><td align="left">::</td><td align="left">命名空间作用域</td><td align="left">namespace::name</td><td align="left">左</td><td align="left">P74</td></tr><tr><td align="left">.</td><td align="left">成员选择</td><td align="left">object::member</td><td align="left">左</td><td align="left">P20</td></tr><tr><td align="left">-&gt;</td><td align="left">成员选择</td><td align="left">pointer-&gt;member</td><td align="left">左</td><td align="left">P98</td></tr><tr><td align="left">[]</td><td align="left">下标</td><td align="left">expr[expr]</td><td align="left">左</td><td align="left">P104</td></tr><tr><td align="left">()</td><td align="left">函数调用</td><td align="left">name(expr_list)</td><td align="left">左</td><td align="left">P20</td></tr><tr><td align="left">()</td><td align="left">类型构造</td><td align="left">type(expr_list)</td><td align="left">左</td><td align="left">P145</td></tr><tr><td align="left">++</td><td align="left">后置递增运算</td><td align="left">lvalue++</td><td align="left">右</td><td align="left">P131</td></tr><tr><td align="left">--</td><td align="left">后置递减运算</td><td align="left">lvalue--</td><td align="left">右</td><td align="left">P131</td></tr><tr><td align="left">typeid</td><td align="left">类型ID</td><td align="left">typeid(type)</td><td align="left">右</td><td align="left">P731</td></tr><tr><td align="left">typeid</td><td align="left">运行时类型ID</td><td align="left">typeid(type)</td><td align="left">右</td><td align="left">P731</td></tr><tr><td align="left">explicit cast</td><td align="left">类型转换</td><td align="left">cast_nam&lt;type&gt;(expr)</td><td align="left">右</td><td align="left">P144</td></tr><tr><td align="left">++</td><td align="left">前置递增运算</td><td align="left">++lvalue</td><td align="left">右</td><td align="left">P131</td></tr><tr><td align="left">--</td><td align="left">前置递减运算</td><td align="left">--lvalue</td><td align="left">右</td><td align="left">P131</td></tr><tr><td align="left">~</td><td align="left">位求反</td><td align="left">~expr</td><td align="left">右</td><td align="left">P136</td></tr><tr><td align="left">!</td><td align="left">逻辑非</td><td align="left">!expr</td><td align="left">右</td><td align="left">P126</td></tr><tr><td align="left">-</td><td align="left">一元负号</td><td align="left">-expr</td><td align="left">右</td><td align="left">P124</td></tr><tr><td align="left">+</td><td align="left">一元正号</td><td align="left">+expr</td><td align="left">右</td><td align="left">P124</td></tr><tr><td align="left">*</td><td align="left">解引用</td><td align="left">*expr</td><td align="left">右</td><td align="left">P48</td></tr><tr><td align="left">&amp;</td><td align="left">取地址</td><td align="left">&amp;lvalue</td><td align="left">右</td><td align="left">P47</td></tr><tr><td align="left">()</td><td align="left">类型转换</td><td align="left">(type)expr</td><td align="left">右</td><td align="left">P145</td></tr><tr><td align="left">sizeof</td><td align="left">对象的大小</td><td align="left">sizeof expr</td><td align="left">右</td><td align="left">P139</td></tr><tr><td align="left">sizeof</td><td align="left">类型的大小</td><td align="left">sizeof(type)</td><td align="left">右</td><td align="left">P139</td></tr><tr><td align="left">sizeof...</td><td align="left">参数包的大小</td><td align="left">sizeof...(name)</td><td align="left">右</td><td align="left">P619</td></tr><tr><td align="left">new</td><td align="left">创建对象</td><td align="left">new type</td><td align="left">右</td><td align="left">P407</td></tr><tr><td align="left">new[]</td><td align="left">创建数组</td><td align="left">new typep[size]</td><td align="left">右</td><td align="left">P407</td></tr><tr><td align="left">delete</td><td align="left">释放对象</td><td align="left">delete expr</td><td align="left">右</td><td align="left">P409</td></tr><tr><td align="left">delete[]</td><td align="left">释放数组</td><td align="left">delete[] expr</td><td align="left">右</td><td align="left">P409</td></tr><tr><td align="left">noexcept</td><td align="left">能否抛出异常</td><td align="left">noexpect(expr)</td><td align="left">右</td><td align="left">P690</td></tr><tr><td align="left">-&gt;*</td><td align="left">指向成员选择的指针</td><td align="left">ptr-&gt;*ptr_to_member</td><td align="left">左</td><td align="left">P740</td></tr><tr><td align="left">.*</td><td align="left">指向成员选择的指针</td><td align="left">obj.*ptr_to_member</td><td align="left">左</td><td align="left">P740</td></tr><tr><td align="left">*</td><td align="left">乘法</td><td align="left">expr*expr</td><td align="left">左</td><td align="left">P124</td></tr><tr><td align="left">&#x2F;</td><td align="left">除法</td><td align="left">expr&#x2F;expr</td><td align="left">左</td><td align="left">P124</td></tr><tr><td align="left">%</td><td align="left">取模（取余）</td><td align="left">expr%expr</td><td align="left">左</td><td align="left">P124</td></tr><tr><td align="left">+</td><td align="left">加法</td><td align="left">expr+expr</td><td align="left">左</td><td align="left">P124</td></tr><tr><td align="left">-</td><td align="left">减法</td><td align="left">expr-expr</td><td align="left">左</td><td align="left">P124</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">向左移位</td><td align="left">expr&lt;&lt;expr</td><td align="left">左</td><td align="left">P136</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">向右移位</td><td align="left">exp&gt;&gt;expr</td><td align="left">左</td><td align="left">P136</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td><td align="left">exp&lt;expr</td><td align="left">左</td><td align="left">P126</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">小于等于</td><td align="left">exp&lt;&#x3D;expr</td><td align="left">左</td><td align="left">P126</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td><td align="left">expr&gt;expr</td><td align="left">左</td><td align="left">P126</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">大于等于</td><td align="left">exp&gt;&#x3D;expr</td><td align="left">左</td><td align="left">P126</td></tr><tr><td align="left">&#x3D;&#x3D;</td><td align="left">相等</td><td align="left">exp&#x3D;&#x3D;expr</td><td align="left">左</td><td align="left">P126</td></tr><tr><td align="left">!&#x3D;</td><td align="left">不相等</td><td align="left">exp!&#x3D;expr</td><td align="left">左</td><td align="left">P126</td></tr><tr><td align="left">&amp;</td><td align="left">位与</td><td align="left">exp&amp;expr</td><td align="left">左</td><td align="left">P136</td></tr><tr><td align="left">^</td><td align="left">位异或</td><td align="left">exp^expr</td><td align="left">左</td><td align="left">P136</td></tr><tr><td align="left">|</td><td align="left">位或</td><td align="left">exp|expr</td><td align="left">左</td><td align="left">P136</td></tr><tr><td align="left">&amp;&amp;</td><td align="left">逻辑与</td><td align="left">exp&amp;&amp;expr</td><td align="left">左</td><td align="left">P126</td></tr><tr><td align="left">||</td><td align="left">逻辑或</td><td align="left">exp||expr</td><td align="left">左</td><td align="left">P126</td></tr><tr><td align="left">?:</td><td align="left">条件</td><td align="left">exp?expr:expr</td><td align="left">右</td><td align="left">P134</td></tr><tr><td align="left">&#x3D;</td><td align="left">赋值</td><td align="left">lvalue&#x3D;expr</td><td align="left">右</td><td align="left">P129</td></tr><tr><td align="left">*&#x3D;, &#x2F;&#x3D;, %&#x3D;, +&#x3D;, -&#x3D;, &lt;&lt;&#x3D;, &gt;&gt;&#x3D;, &amp;&#x3D;, |&#x3D;, ^&#x3D;</td><td align="left">复合赋值</td><td align="left">lvalue+&#x3D;expr等</td><td align="left">右</td><td align="left">P129</td></tr><tr><td align="left">throw</td><td align="left">抛出异常</td><td align="left">throw expr</td><td align="left">右</td><td align="left">P173</td></tr><tr><td align="left">,</td><td align="left">逗号</td><td align="left">expr, expr</td><td align="left">左</td><td align="left">P140</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第四章：表达式&quot;&gt;&lt;a href=&quot;#第四章：表达式&quot; class=&quot;headerlink&quot; title=&quot;第四章：表达式&quot;&gt;&lt;/a&gt;第四章：表达式&lt;/h1&gt;&lt;h2 id=&quot;练习4-1&quot;&gt;&lt;a href=&quot;#练习4-1&quot; class=&quot;headerlink&quot; title=&quot;练习4.1&quot;&gt;&lt;/a&gt;练习4.1&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;表达式 5 + 10 * 20 &amp;#x2F; 2 的求值结果是多少？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;105&lt;/p&gt;
&lt;h2 id=&quot;练习4-2&quot;&gt;&lt;a href=&quot;#练习4-2&quot; class=&quot;headerlink&quot; title=&quot;练习4.2&quot;&gt;&lt;/a&gt;练习4.2&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;(a) *vec.begin()&lt;/li&gt;
&lt;li&gt;(b) *vec.begin() + 1&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;*(vec.begin())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(*(vec.begin())) + 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;练习4-3&quot;&gt;&lt;a href=&quot;#练习4-3&quot; class=&quot;headerlink&quot; title=&quot;练习4.3&quot;&gt;&lt;/a&gt;练习4.3&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以接受。C++的设计思想是尽可能地“相信”程序员，将效率最大化。然而这种思想却有着潜在的危害，就是无法控制程序员自身引发的错误。因此 Java 的诞生也是必然，Java的思想就是尽可能地“不相信”程序员。&lt;/p&gt;
&lt;h2 id=&quot;练习4-4&quot;&gt;&lt;a href=&quot;#练习4-4&quot; class=&quot;headerlink&quot; title=&quot;练习4.4&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Mister-Kin/CodeTraining/blob/master/cpp_primer_v5/chap4/4_4.cpp&quot;&gt;练习4.4&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在下面的表达式中添加括号，说明其求值过程及最终结果。编写程序编译该（不加括号的）表达式并输出结果验证之前的推断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt; % &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;((12&amp;#x2F;3)*4) + (5*15) + ((24%4)&amp;#x2F;2)&lt;/p&gt;
&lt;p&gt;实际输出结果：91。&lt;/p&gt;
&lt;h2 id=&quot;练习4-5&quot;&gt;&lt;a href=&quot;#练习4-5&quot; class=&quot;headerlink&quot; title=&quot;练习4.5&quot;&gt;&lt;/a&gt;练习4.5&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;写出下列表达式的求值结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;-30&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// -90+4 = -86&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;-30&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// -30+63/5 = -30+12 = -18&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt; % &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// 10*21%5 = 210%5 = 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;-30&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt; % &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// -10*21%4 = -210%4 = -2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;练习4-6&quot;&gt;&lt;a href=&quot;#练习4-6&quot; class=&quot;headerlink&quot; title=&quot;练习4.6&quot;&gt;&lt;/a&gt;练习4.6&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;写出一条表达式用于确定一个整数是奇数还是偶数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i % &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;练习4-7&quot;&gt;&lt;a href=&quot;#练习4-7&quot; class=&quot;headerlink&quot; title=&quot;练习4.7&quot;&gt;&lt;/a&gt;练习4.7&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;溢出是何含义？写出三条将导致溢出的表达式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;溢出含义：当计算的结果超出该类型所能表示的范围时就会产生溢出。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;short&lt;/span&gt; svalue = &lt;span class=&quot;number&quot;&gt;32767&lt;/span&gt;; ++svalue; &lt;span class=&quot;comment&quot;&gt;// -32768&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;unsigned&lt;/span&gt; uivalue = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; --uivalue;  &lt;span class=&quot;comment&quot;&gt;// 4294967295&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;short&lt;/span&gt; usvalue = &lt;span class=&quot;number&quot;&gt;65535&lt;/span&gt;; ++usvalue;  &lt;span class=&quot;comment&quot;&gt;// 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;练习4-8&quot;&gt;&lt;a href=&quot;#练习4-8&quot; class=&quot;headerlink&quot; title=&quot;练习4.8&quot;&gt;&lt;/a&gt;练习4.8&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;说明在逻辑与、逻辑或及相等性运算符中运算对象的求值顺序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为&lt;strong&gt;短路求值&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;相等性运算符未定义求值顺序。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="code-training" scheme="https://mister-kin.github.io/categories/code-training/"/>
    
    <category term="cpp-primer-v5" scheme="https://mister-kin.github.io/categories/code-training/cpp-primer-v5/"/>
    
    
    <category term="C++" scheme="https://mister-kin.github.io/tags/C/"/>
    
    <category term="C++ Primer" scheme="https://mister-kin.github.io/tags/C-Primer/"/>
    
    <category term="习题答案" scheme="https://mister-kin.github.io/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
    <category term="练习总结" scheme="https://mister-kin.github.io/tags/%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="第四章" scheme="https://mister-kin.github.io/tags/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    
    <category term="表达式" scheme="https://mister-kin.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>VSCode配置总结笔记</title>
    <link href="https://mister-kin.github.io/code/vscode/"/>
    <id>https://mister-kin.github.io/code/vscode/</id>
    <published>2023-07-26T20:49:05.000Z</published>
    <updated>2023-07-27T18:40:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载及安装VSCode">1 &nbsp&nbsp<a href="#下载及安装VSCode" class="headerlink" title="下载及安装VSCode"></a>下载及安装VSCode</h1><ul><li>下载：<a href="https://code.visualstudio.com/Download">VSCode System Installer</a></li><li>安装：默认及路径安装，选项额外添选上下文菜单（文件和目录）</li></ul><h2 id="配置C-C">1.1 &nbsp&nbsp<a href="#配置C-C" class="headerlink" title="配置C&#x2F;C++"></a>配置C&#x2F;C++</h2><p>编译器：<a href="https://visualstudio.microsoft.com/zh-hans/downloads/">MSVC CL 编译器（Visual Studio 2022 生成工具）</a></p><h1 id="CL编译器的环境设置">2 &nbsp&nbsp<a href="#CL编译器的环境设置" class="headerlink" title="CL编译器的环境设置"></a>CL编译器的环境设置</h1><ol><li>安装cl开发环境</li><li>将CL路径添加到系统path中：<code>C:/Program Files (x86)/Microsoft Visual Studio/2022/BuildTools/VC/Tools/MSVC/14.35.32215/bin/Hostx64/x64/</code></li><li>拷贝.vscode配置文件夹</li></ol><h2 id="更新MSVC后找不到CL命令">2.1 &nbsp&nbsp<a href="#更新MSVC后找不到CL命令" class="headerlink" title="更新MSVC后找不到CL命令"></a>更新MSVC后找不到CL命令</h2><p>更新MSVC后，版本号可能会变更，如果终端运行cl命令后查不到，需要手动更新两个文件中的CL路径：</p><ul><li>系统PATH</li><li>c_cpp_properties.json</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;下载及安装VSCode&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#下载及安装VSCode&quot; class=&quot;headerlink&quot; title=&quot;下载及安装VSCode&quot;&gt;&lt;/a&gt;下载及安装VSCode&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;下载：&lt;a</summary>
        
      
    
    
    
    <category term="code" scheme="https://mister-kin.github.io/categories/code/"/>
    
    
    <category term="编译" scheme="https://mister-kin.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
    <category term="vsc" scheme="https://mister-kin.github.io/tags/vsc/"/>
    
    <category term="vscode" scheme="https://mister-kin.github.io/tags/vscode/"/>
    
    <category term="编辑器" scheme="https://mister-kin.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    <category term="链接" scheme="https://mister-kin.github.io/tags/%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>网站收藏夹</title>
    <link href="https://mister-kin.github.io/bookmark/"/>
    <id>https://mister-kin.github.io/bookmark/</id>
    <published>2023-07-25T13:15:01.000Z</published>
    <updated>2023-09-09T12:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三方站点导航推荐">1 &nbsp&nbsp<a href="#第三方站点导航推荐" class="headerlink" title="第三方站点导航推荐"></a>第三方站点导航推荐</h1><ul><li><a href="https://arandintday.github.io/2020/02/28/goodwebsite/">个人收藏的良心网站（持续更新）</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;第三方站点导航推荐&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#第三方站点导航推荐&quot; class=&quot;headerlink&quot; title=&quot;第三方站点导航推荐&quot;&gt;&lt;/a&gt;第三方站点导航推荐&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="书签" scheme="https://mister-kin.github.io/tags/%E4%B9%A6%E7%AD%BE/"/>
    
    <category term="收藏夹" scheme="https://mister-kin.github.io/tags/%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
    
    <category term="网址" scheme="https://mister-kin.github.io/tags/%E7%BD%91%E5%9D%80/"/>
    
    <category term="站点" scheme="https://mister-kin.github.io/tags/%E7%AB%99%E7%82%B9/"/>
    
    <category term="导航" scheme="https://mister-kin.github.io/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="推荐" scheme="https://mister-kin.github.io/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>CAD总结笔记</title>
    <link href="https://mister-kin.github.io/cad/cad/"/>
    <id>https://mister-kin.github.io/cad/cad/</id>
    <published>2023-07-24T18:11:40.000Z</published>
    <updated>2023-10-12T15:17:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>cad软件操作</p><h1 id="参考文献">1 &nbsp&nbsp<a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;cad软件操作&lt;/p&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;1 &amp;nbsp&amp;nbsp&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="cad" scheme="https://mister-kin.github.io/categories/cad/"/>
    
    
  </entry>
  
</feed>
